<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模版方法模式的定义模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 二、模版方法模式的结构模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。 模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。 模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。模板方法模式的静态结构图如下所示： 这里涉及到两个角色： 抽象模板(Abstract Template)角色有如下责任： ■ 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 ■ 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任： ■ 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 ■ 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 抽象模板角色类，abstractMethod()、hookMethod()等基本方法是顶级逻辑的组成步骤，这个顶级逻辑由templateMethod()方法代表。 12345678910111213141516171819202122232425public abstract class AbstractTemplate &#123; /** * 模板方法 */ public void templateMethod()&#123; //调用基本方法 abstractMethod(); hookMethod(); concreteMethod(); &#125; /** * 基本方法的声明（由子类实现） */ protected abstract void abstractMethod(); /** * 基本方法(空方法) */ protected void hookMethod()&#123;&#125; /** * 基本方法（已经实现） */ private final void concreteMethod()&#123; //业务相关的代码 &#125;&#125; 具体模板角色类，实现了父类所声明的基本方法，abstractMethod()方法所代表的就是强制子类实现的剩余逻辑，而hookMethod()方法是可选择实现的逻辑，不是必须实现的。 123456789101112public class ConcreteTemplate extends AbstractTemplate&#123; //基本方法的实现 @Override public void abstractMethod() &#123; //业务相关的代码 &#125; //重写父类的方法 @Override public void hookMethod() &#123; //业务相关的代码 &#125;&#125; 模板模式的关键是：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。 每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。 三、模板方法模式中的方法模板方法中的方法可以分为两大类：模板方法和基本方法。 模板方法一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。 一个抽象类可以有任意多个模板方法，而不限于一个。每一个模板方法都可以调用任意多个具体方法。 基本方法基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。 ● 抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在Java语言里抽象方法以abstract关键字标示。 ● 具体方法：一个具体方法由抽象类声明并实现，而子类并不实现或置换。 ● 钩子方法：一个钩子方法由抽象类声明并实现，而子类会加以扩展。通常抽象类给出的实现是一个空实现，作为方法的默认实现。 在上面的例子中，AbstractTemplate是一个抽象类，它带有三个方法。其中abstractMethod()是一个抽象方法，它由抽象类声明为抽象方法，并由子类实现；hookMethod()是一个钩子方法，它由抽象类声明并提供默认实现，并且由子类置换掉。concreteMethod()是一个具体方法，它由抽象类声明并实现。 默认钩子方法一个钩子方法常常由抽象类给出一个空实现作为此方法的默认实现。这种空的钩子方法叫做“Do Nothing Hook”。具体模版类中可以选择是否重写钩子方法，通常重写钩子方法是为了对模版方法中的步骤进行控制，判断钩子方法中的状态，是否进行下一步操作。 四、模版方法的具体实例考虑一个计算存款利息的例子。假设系统需要支持两种存款账号，即货币市场(Money Market)账号和定期存款(Certificate of Deposite)账号。这两种账号的存款利息是不同的，因此，在计算一个存户的存款利息额时，必须区分两种不同的账号类型。 这个系统的总行为应当是计算出利息，这也就决定了作为一个模板方法模式的顶级逻辑应当是利息计算。由于利息计算涉及到两个步骤：一个基本方法给出账号种类，另一个基本方法给出利息百分比。这两个基本方法构成具体逻辑，因为账号的类型不同，所以具体逻辑会有所不同。 显然，系统需要一个抽象角色给出顶级行为的实现，而将两个作为细节步骤的基本方法留给具体子类实现。由于需要考虑的账号有两种：一是货币市场账号，二是定期存款账号。系统的类结构如下图所示。 抽象模板角色类 1234567891011121314151617181920212223242526272829public abstract class Account &#123; /** * 模板方法，计算利息数额 * @return 返回利息数额 */ public final double calculateInterest()&#123; double interestRate = doCalculateInterestRate(); String accountType = doCalculateAccountType(); double amount = calculateAmount(accountType); return amount * interestRate; &#125; /** * 基本方法留给子类实现 */ protected abstract String doCalculateAccountType(); /** * 基本方法留给子类实现 */ protected abstract double doCalculateInterestRate(); /** * 基本方法，已经实现 */ private double calculateAmount(String accountType)&#123; /** * 省略相关的业务逻辑 */ return 7243.00; &#125;&#125; 具体模板角色类 123456789101112131415public class MoneyMarketAccount extends Account &#123; @Override protected String doCalculateAccountType() &#123; return "Money Market"; &#125; @Override protected double doCalculateInterestRate() &#123; return 0.045; &#125;&#125; 12345678910111213public class CDAccount extends Account &#123; @Override protected String doCalculateAccountType() &#123; return "Certificate of Deposite"; &#125; @Override protected double doCalculateInterestRate() &#123; return 0.06; &#125;&#125; 客户端类 12345678910public class Client &#123; public static void main(String[] args) &#123; Account account = new MoneyMarketAccount(); System.out.println("货币市场账号的利息数额为：" + account.calculateInterest()); account = new CDAccount(); System.out.println("定期账号的利息数额为：" + account.calculateInterest()); &#125;&#125; 五、模板方法模式效果与适用场景模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）。 在以下情况下可以考虑使用模板方法模式： (1) 对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。 (2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。 (3) 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。 六、模版方法模式的优缺点优点(1) 在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 (2) 模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。 (3) 可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 (4) 在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。 缺点需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型模式</category>
      </categories>
      <tags>
        <tag>模板方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、策略模式的简介1.定义策略模式属于对象的行为模式。其用意是针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。 2.使用场景针对一个对象，其行为有些是固定的不变的，有些是容易变化的，针对不同情况有不同的表现形式。那么对于这些容易变化的行为，我们不希望将其实现绑定在对象中，而是希望以动态的形式，针对不同情况产生不同的应对策略。那么这个时候就要用到策略模式了。简言之，策略模式就是为了应对对象中复杂多变的行为而产生的。 二、策略模式的结构策略模式是对算法的包装，是把调用算法的责任（行为）和算法本身（行为实现）分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。下面就以一个示意性的实现讲解策略模式实例的结构。 这个模式涉及到三个角色： ● 环境(Context)角色：持有一个Strategy的引用，即具有复杂多变行为的对象。 ● 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 ● 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 三、具体场景实现假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。 根据描述，折扣是根据以下的几个算法中的一个进行的： 算法一：对初级会员没有折扣。 算法二：对中级会员提供10%的促销折扣。 算法三：对高级会员提供20%的促销折扣。 使用策略模式来实现的结构图如下： 抽象折扣类 12345678public interface MemberStrategy &#123; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice);&#125; 初级会员折扣类 12345678910public class PrimaryMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于初级会员的没有折扣"); return booksPrice; &#125;&#125; 中级会员折扣类 12345678910public class IntermediateMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于中级会员的折扣为10%"); return booksPrice * 0.9; &#125;&#125; 高级会员折扣类 123456789public class AdvancedMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println("对于高级会员的折扣为20%"); return booksPrice * 0.8; &#125;&#125; 价格类 1234567891011121314151617181920public class Price &#123; //持有一个具体的策略对象 private MemberStrategy strategy; /** * 构造函数，传入一个具体的策略对象 * @param strategy 具体的策略对象 */ public Price(MemberStrategy strategy)&#123; this.strategy = strategy; &#125; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double quote(double booksPrice)&#123; return this.strategy.calcPrice(booksPrice); &#125;&#125; 具体调用： 123456789public static void main(String[] args) &#123; //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); //创建环境 Price price = new Price(strategy); //计算价格 double quote = price.quote(300); System.out.println("图书的最终价格为：" + quote);&#125; 四、对策略模式的深入认识策略模式对多态的使用 通过让环境类持有一个抽象策略类（超类）的引用，在生成环境类实例对象时，让该引用指向具体的策略子类。再对应的方法调用中，就会通过Java的多态，调用对应策略子类的方法。从而可以相互替换，不需要修改环境类内部的实现。同时，在有新的需求的情况下，也只需要修改策略类即可，降低与环境类之间的耦合度。 策略模式的重心 策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。 算法的平等性 策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。 所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。 运行时策略的唯一性 运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。 公有的行为 经常见到的是，所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。 这其实也是典型的将代码向继承等级结构的上方集中的标准做法。 五、策略模式的优缺点策略模式的优点 （1）策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。 （2）使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。 策略模式的缺点 （1）客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道算法或行为的情况。 （2）由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型模式</category>
      </categories>
      <tags>
        <tag>策略模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、观察者模式的概念观察者模式是对象的行为模式，又叫发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器(Source/Listener)模式或从属者(Dependents)模式。 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 二、观察者模式的结构一个软件系统里面包含了各种对象，就像一片欣欣向荣的森林充满了各种生物一样。在一片森林中，各种生物彼此依赖和约束，形成一个个生物链。一种生物的状态变化会造成其他一些生物的相应行动，每一个生物都处于别的生物的互动之中。 同样，一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。做到这一点的设计方案有很多，但是为了使系统能够易于复用，应该选择低耦合度的设计方案。减少对象之间的耦合有利于系统的复用，但是同时设计师需要使这些低耦合度的对象之间能够维持行动的协调一致，保证高度的协作。观察者模式是满足这一要求的各种设计方案中最重要的一种。 下面以一个简单的示意性实现为例，讨论观察者模式的结构。 观察者模式所涉及的角色有： ● 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个聚集（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色。 ● 具体主题(ConcreteSubject)角色：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 ● 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 ● 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 三、观察者模式的代码实现抽象主题角色类(此处是抽象类，改成接口将会提高复用) 12345678910111213141516171819202122232425262728293031323334353637383940public abstract class Subject &#123; /** * 用来保存注册的观察者对象 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer)&#123; list.add(observer); System.out.println("Attached an observer"); &#125; /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer)&#123; list.remove(observer); &#125; /** * 通知所有注册的观察者对象 */ public void nodifyObservers(String newState)&#123; for(Observer observer : list)&#123; observer.update(newState); &#125; &#125;&#125; 具体主题角色类 123456789101112131415public class ConcreteSubject extends Subject&#123; private String state; public String getState() &#123; return state; &#125; public void change(String newState)&#123; state = newState; System.out.println("主题状态为：" + state); //状态发生改变，通知各个观察者 this.nodifyObservers(state); &#125;&#125; 抽象观察者角色类 1234567public interface Observer &#123; /** * 更新接口 * @param state 更新的状态 */ public void update(String state);&#125; 具体观察者角色类 12345678910111213public class ConcreteObserver implements Observer &#123; //观察者的状态 private String observerState; @Override public void update(String state) &#123; /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = state; System.out.println("状态为："+observerState); &#125;&#125; 具体使用： 12345678910111213public class Client &#123; public static void main(String[] args) &#123; //创建主题对象 ConcreteSubject subject = new ConcreteSubject(); //创建观察者对象 Observer observer = new ConcreteObserver(); //将观察者对象登记到主题对象上 subject.attach(observer); //改变主题对象的状态 subject.change("new state"); &#125;&#125; 当主题对象的状态改变时，将通知所有观察者，观察者接收到主题对象的通知后，将可以进行其他操作，进行响应。 四、推模型和拉模型 在观察者模式中，又分为推模型和拉模型两种方式。 ● 推模型 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 ● 拉模型 主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 根据上面的描述，发现前面的例子就是典型的推模型，下面给出一个拉模型的实例。 拉模型的抽象观察者类 拉模型通常都是把主题对象当做参数传递。 1234567public interface Observer &#123; /** * 更新接口 * @param subject 传入主题对象，方面获取相应的主题对象的状态 */ public void update(Subject subject);&#125; 拉模型的具体观察者类 1234567891011121314public class ConcreteObserver implements Observer &#123; //观察者的状态 private String observerState; @Override public void update(Subject subject) &#123; /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = ((ConcreteSubject)subject).getState(); System.out.println("观察者状态为："+observerState); &#125;&#125; 拉模型的抽象主题类拉模型的抽象主题类主要的改变是nodifyObservers()方法。在循环通知观察者的时候，也就是循环调用观察者的update()方法的时候，传入的参数不同了。 12345678910111213141516171819202122232425262728293031323334353637383940public abstract class Subject &#123; /** * 用来保存注册的观察者对象 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer)&#123; list.add(observer); System.out.println("Attached an observer"); &#125; /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer)&#123; list.remove(observer); &#125; /** * 通知所有注册的观察者对象 */ public void nodifyObservers()&#123; for(Observer observer : list)&#123; observer.update(this); &#125; &#125;&#125; 拉模型的具体主题类跟推模型相比，有一点变化，就是调用通知观察者的方法的时候，不需要传入参数了。 123456789101112131415public class ConcreteSubject extends Subject&#123; private String state; public String getState() &#123; return state; &#125; public void change(String newState)&#123; state = newState; System.out.println("主题状态为：" + state); //状态发生改变，通知各个观察者 this.nodifyObservers(); &#125;&#125; 两种模式的比较 ■ 推模型是假定主题对象知道观察者需要的数据；而拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。 ■ 推模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，就可能提供新的update()方法，或者是干脆重新实现观察者；而拉模型就不会造成这样的情况，因为拉模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。 五、JAVA提供的对观察者模式的支持在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。 Observer接口这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 1234public interface Observer &#123; void update(Observable o, Object arg);&#125; Observable类被观察者类都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public class Observable &#123; private boolean changed = false; private Vector obs; /** Construct an Observable with zero Observers. */ public Observable() &#123; obs = new Vector(); &#125; /** * 将一个观察者添加到观察者聚集上面 */ public synchronized void addObserver(Observer o) &#123; if (o == null) throw new NullPointerException(); if (!obs.contains(o)) &#123; obs.addElement(o); &#125; &#125; /** * 将一个观察者从观察者聚集上删除 */ public synchronized void deleteObserver(Observer o) &#123; obs.removeElement(o); &#125; public void notifyObservers() &#123; notifyObservers(null); &#125; /** * 如果本对象有变化（那时hasChanged 方法会返回true） * 调用本方法通知所有登记的观察者，即调用它们的update()方法 * 传入this和arg作为参数 */ public void notifyObservers(Object arg) &#123; Object[] arrLocal; synchronized (this) &#123; if (!changed) return; arrLocal = obs.toArray(); clearChanged(); &#125; for (int i = arrLocal.length-1; i&gt;=0; i--) ((Observer)arrLocal[i]).update(this, arg); &#125; /** * 将观察者聚集清空 */ public synchronized void deleteObservers() &#123; obs.removeAllElements(); &#125; /** * 将“已变化”设置为true */ protected synchronized void setChanged() &#123; changed = true; &#125; /** * 将“已变化”重置为false */ protected synchronized void clearChanged() &#123; changed = false; &#125; /** * 检测本对象是否已变化 */ public synchronized boolean hasChanged() &#123; return changed; &#125; /** * Returns the number of observers of this &lt;tt&gt;Observable&lt;/tt&gt; object. * * @return the number of observers of this object. */ public synchronized int countObservers() &#123; return obs.size(); &#125;&#125; 这个类代表一个被观察者对象，有时称之为主题对象。一个被观察者对象可以有数个观察者对象，每个观察者对象都是实现Observer接口的对象。在被观察者发生变化时，会调用Observable的notifyObservers()方法，此方法调用所有的具体观察者的update()方法，从而使所有的观察者都被通知更新自己。 使用JAVA对观察者模式的支持这里给出一个非常简单的例子，说明怎样使用JAVA所提供的对观察者模式的支持。在这个例子中，被观察对象叫做Watched；而观察者对象叫做Watcher。Watched对象继承自java.util.Observable类；而Watcher对象实现了java.util.Observer接口。另外有一个Test类扮演客户端角色。被观察者Watched类 12345678910111213141516171819public class Watched extends Observable&#123; private String data = ""; public String getData() &#123; return data; &#125; public void setData(String data) &#123; if(!this.data.equals(data))&#123; this.data = data; setChanged(); notifyObservers(); &#125; &#125;&#125; 观察者Watcher 类 123456789101112public class Watcher implements Observer&#123; public Watcher(Observable o)&#123; o.addObserver(this); &#125; @Override public void update(Observable o, Object arg) &#123; System.out.println("状态发生改变：" + ((Watched)o).getData()); &#125;&#125; 具体使用： 123456789101112public static void main(String[] args) &#123; //创建被观察者对象 Watched watched = new Watched(); //创建观察者对象，并将被观察者对象登记 Observer watcher = new Watcher(watched); //给被观察者状态赋值 watched.setData("start"); watched.setData("run"); watched.setData("stop"); &#125; 总结：观察者模式一般是一对多的情形，本文中篇幅有限，都是一对一的例子。当一对多时，通过Java内置的观察者模式时，通知多个观察者的顺序不是固定的。所以如果依赖此顺序的话，要自己实现观察者模式。同时Java内置的观察者模式中，Observerable是个类，所以在子类继承了该类后就不能继承其他类，导致复用受到限制，自己实现观察者模式时可以设置为接口，提高复用。]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型模式</category>
      </categories>
      <tags>
        <tag>观察者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、迭代器模式定义迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所。 二、迭代器模式结构 迭代器模式涉及到以下几个角色： ● 抽象迭代器(Iterator)角色：此抽象角色定义出遍历元素所需的接口。 ● 具体迭代器(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。 ● 聚集(Aggregate)角色：此抽象角色给出创建迭代器(Iterator)对象的接口。 ● 具体聚集(ConcreteAggregate)角色：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。 ● 客户端(Client)角色：持有对聚集及其迭代器对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。 抽象聚集角色类，这个角色规定出所有的具体聚集必须实现的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。 123456public abstract class Aggregate &#123; /** * 工厂方法，创建相应迭代子对象的接口 */ public abstract Iterator createIterator();&#125; 具体聚集角色类，实现了抽象聚集角色类所要求的接口，也就是createIterator()方法。此外，还有方法getElement()向外界提供聚集元素，而方法size()向外界提供聚集的大小等。 1234567891011121314151617181920212223242526272829303132333435public class ConcreteAggregate extends Aggregate &#123; private Object[] objArray = null; /** * 构造方法，传入聚合对象的具体内容 */ public ConcreteAggregate(Object[] objArray)&#123; this.objArray = objArray; &#125; @Override public Iterator createIterator() &#123; return new ConcreteIterator(this); &#125; /** * 取值方法：向外界提供聚集元素 */ public Object getElement(int index)&#123; if(index &lt; objArray.length)&#123; return objArray[index]; &#125;else&#123; return null; &#125; &#125; /** * 取值方法：向外界提供聚集的大小 */ public int size()&#123; return objArray.length; &#125;&#125; 抽象迭代器角色类 123456789101112131415161718public interface Iterator &#123; /** * 迭代方法：移动到第一个元素 */ public void first(); /** * 迭代方法：移动到下一个元素 */ public void next(); /** * 迭代方法：是否为最后一个元素 */ public boolean isDone(); /** * 迭代方法：返还当前元素 */ public Object currentItem();&#125; 具体迭代器角色类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class ConcreteIterator implements Iterator &#123; //持有被迭代的具体的聚合对象 private ConcreteAggregate agg; //内部索引，记录当前迭代到的索引位置 private int index = 0; //记录当前聚集对象的大小 private int size = 0; public ConcreteIterator(ConcreteAggregate agg)&#123; this.agg = agg; this.size = agg.size(); index = 0; &#125; /** * 迭代方法：返还当前元素 */ @Override public Object currentItem() &#123; return agg.getElement(index); &#125; /** * 迭代方法：移动到第一个元素 */ @Override public void first() &#123; index = 0; &#125; /** * 迭代方法：是否为最后一个元素 */ @Override public boolean isDone() &#123; return (index &gt;= size); &#125; /** * 迭代方法：移动到下一个元素 */ @Override public void next() &#123; if(index &lt; size) &#123; index ++; &#125; &#125;&#125; 客户端类 1234567891011121314151617181920public class Client &#123; public void operation()&#123; Object[] objArray = &#123;"One","Two","Three","Four","Five","Six"&#125;; //创建聚合对象 Aggregate agg = new ConcreteAggregate(objArray); //循环输出聚合对象中的值 Iterator it = agg.createIterator(); while(!it.isDone())&#123; System.out.println(it.currentItem()); it.next(); &#125; &#125; public static void main(String[] args) &#123; Client client = new Client(); client.operation(); &#125;&#125; 三、迭代器模式的应用如果要问Java中使用最多的一种模式，答案不是单例模式，也不是工厂模式，更不是策略模式，而是迭代器模式，先来看一段代码吧： 1234567public static void print(Collection coll)&#123; Iterator it = coll.iterator(); while(it.hasNext())&#123; String str = (String)it.next(); System.out.println(str); &#125; &#125; 这个方法的作用是循环打印一个字符串集合，里面就用到了迭代器模式，java语言已经完整地实现了迭代器模式，例如List，Set，Map，而迭代器的作用就是把容器中的对象一个一个地遍历出来。 四、迭代器模式的优缺点优点①简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。 ②可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。 ③封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。 缺点对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。 五、迭代器的应用场景迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。 但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型模式</category>
      </categories>
      <tags>
        <tag>迭代器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、命令模式的概念命令模式属于对象的行为模式。命令模式又称为行动(Action)模式或交易(Transaction)模式。 命令模式把一个请求或者操作封装到一个对象中。命令模式允许系统使用不同的请求把客户端参数化，具有请求排队或者记录请求日志，提供命令的撤销和恢复的功能。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 二、命令模式的结构命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。 每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。 下面以一个示意性的系统，说明命令模式的结构。 命令模式涉及到五个角色，它们分别是： ● 客户端(Client)角色：创建请求者，接收者以及命令对象，执行具体逻辑。 ● 命令(Command)角色：声明了一个给所有具体命令类的抽象接口。 ● 具体命令(ConcreteCommand)角色：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。 ● 请求者(Invoker)角色：负责调用命令对象执行请求，相关的方法叫做行动方法。 ● 接收者(Receiver)角色：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。 时序图 接收者角色类 12345678public class Receiver &#123; /** * 真正执行命令相应的操作 */ public void action()&#123; System.out.println("执行操作"); &#125;&#125; 抽象命令角色类 123456public interface Command &#123; /** * 执行方法 */ void execute();&#125; 具体命令角色类 12345678910111213141516public class ConcreteCommand implements Command &#123; //持有相应的接收者对象 private Receiver receiver = null; /** * 构造方法 */ public ConcreteCommand(Receiver receiver)&#123; this.receiver = receiver; &#125; @Override public void execute() &#123; //通常会转调接收者对象的相应方法，让接收者来真正执行功能 receiver.action(); &#125;&#125; 请求者角色类 12345678910111213141516171819public class Invoker &#123; /** * 持有命令对象 */ private Command command = null; /** * 构造方法 */ public Invoker(Command command)&#123; this.command = command; &#125; /** * 行动方法 */ public void action()&#123; command.execute(); &#125;&#125; 客户端角色类 1234567891011121314public class Client &#123; public static void main(String[] args) &#123; //创建接收者 Receiver receiver = new Receiver(); //创建命令对象，设定它的接收者 Command command = new ConcreteCommand(receiver); //创建请求者，把命令对象设置进去 Invoker invoker = new Invoker(command); //执行方法 invoker.action(); &#125;&#125; 三、命令模式的具体实例AudioPlayer系统 小女孩茱丽(Julia)有一个盒式录音机，此录音机有播音(Play)、倒带(Rewind)和停止(Stop)功能，录音机的键盘便是请求者(Invoker)角色；茱丽(Julia)是客户端角色，而录音机便是接收者角色。Command类扮演抽象命令角色，而PlayCommand、StopCommand和RewindCommand便是具体命令类。茱丽(Julia)不需要知道播音(play)、倒带(rewind)和停止(stop)功能是怎么具体执行的，这些命令执行的细节全都由键盘(Keypad)具体实施。茱丽(Julia)只需要在键盘上按下相应的键便可以了。 录音机是典型的命令模式。录音机按键把客户端与录音机的操作细节分割开来。 接收者角色，由录音机类扮演 1234567891011121314public class AudioPlayer &#123; public void play()&#123; System.out.println("播放..."); &#125; public void rewind()&#123; System.out.println("倒带..."); &#125; public void stop()&#123; System.out.println("停止..."); &#125;&#125; 抽象命令角色类 123456public interface Command &#123; /** * 执行方法 */ public void execute();&#125; 具体命令角色类 12345678910111213141516public class PlayCommand implements Command &#123; private AudioPlayer myAudio; public PlayCommand(AudioPlayer audioPlayer)&#123; myAudio = audioPlayer; &#125; /** * 执行方法 */ @Override public void execute() &#123; myAudio.play(); &#125;&#125; 12345678910111213public class RewindCommand implements Command &#123; private AudioPlayer myAudio; public RewindCommand(AudioPlayer audioPlayer)&#123; myAudio = audioPlayer; &#125; @Override public void execute() &#123; myAudio.rewind(); &#125;&#125; 123456789101112public class StopCommand implements Command &#123; private AudioPlayer myAudio; public StopCommand(AudioPlayer audioPlayer)&#123; myAudio = audioPlayer; &#125; @Override public void execute() &#123; myAudio.stop(); &#125;&#125; 请求者角色，由键盘类扮演 123456789101112131415161718192021222324252627282930313233public class Keypad &#123; private Command playCommand; private Command rewindCommand; private Command stopCommand; public void setPlayCommand(Command playCommand) &#123; this.playCommand = playCommand; &#125; public void setRewindCommand(Command rewindCommand) &#123; this.rewindCommand = rewindCommand; &#125; public void setStopCommand(Command stopCommand) &#123; this.stopCommand = stopCommand; &#125; /** * 执行播放方法 */ public void play()&#123; playCommand.execute(); &#125; /** * 执行倒带方法 */ public void rewind()&#123; rewindCommand.execute(); &#125; /** * 执行播放方法 */ public void stop()&#123; stopCommand.execute(); &#125;&#125; 客户端角色，由茱丽小女孩扮演 123456789101112131415161718192021public class Julia &#123; public static void main(String[]args)&#123; //创建接收者对象 AudioPlayer audioPlayer = new AudioPlayer(); //创建命令对象 Command playCommand = new PlayCommand(audioPlayer); Command rewindCommand = new RewindCommand(audioPlayer); Command stopCommand = new StopCommand(audioPlayer); //创建请求者对象 Keypad keypad = new Keypad(); keypad.setPlayCommand(playCommand); keypad.setRewindCommand(rewindCommand); keypad.setStopCommand(stopCommand); //测试 keypad.play(); keypad.rewind(); keypad.stop(); keypad.play(); keypad.stop(); &#125;&#125; 运行结果： 四、宏命令宏命令所谓宏命令简单点说就是包含多个命令的命令，是一个命令的组合。 设想茱丽的录音机有一个记录功能，可以把一个一个的命令记录下来，再在任何需要的时候重新把这些记录下来的命令一次性执行，这就是所谓的宏命令集功能。因此，茱丽的录音机系统现在有四个键，分别为播音、倒带、停止和宏命令功能。此时系统的设计与前面的设计相比有所增强，主要体现在Julia类现在有了一个新方法，用以操作宏命令键。 系统需要一个代表宏命令的接口，以定义出具体宏命令所需要的接口。 123456789101112public interface MacroCommand extends Command &#123; /** * 宏命令聚集的管理方法 * 可以添加一个成员命令 */ public void add(Command cmd); /** * 宏命令聚集的管理方法 * 可以删除一个成员命令 */ public void remove(Command cmd);&#125; 具体的宏命令MacroAudioCommand类负责把个别的命令合成宏命令。 123456789101112131415161718192021222324252627282930313233343536public class MacroAudioCommand implements MacroCommand &#123; private List&lt;Command&gt; commandList = new ArrayList&lt;Command&gt;(); /** * 宏命令聚集管理方法 */ @Override public void add(Command cmd) &#123; commandList.add(cmd); &#125; /** * 宏命令聚集管理方法 */ @Override public void remove(Command cmd) &#123; commandList.remove(cmd); &#125; /** * 执行方法 */ @Override public void execute() &#123; for(Command cmd : commandList)&#123; cmd.execute(); &#125; &#125;&#125; 客户端类Julia 123456789101112131415161718public class Julia &#123; public static void main(String[]args)&#123; //创建接收者对象 AudioPlayer audioPlayer = new AudioPlayer(); //创建命令对象 Command playCommand = new PlayCommand(audioPlayer); Command rewindCommand = new RewindCommand(audioPlayer); Command stopCommand = new StopCommand(audioPlayer); MacroCommand marco = new MacroAudioCommand(); marco.add(playCommand); marco.add(rewindCommand); marco.add(stopCommand); marco.execute(); &#125;&#125; 这样执行MacroCommand 的execute()方法就会一次性执行多条命令。 五、命令模式的优缺点优点 ● 更松散的耦合 命令模式使得发起命令的对象，和具体实现命令的对象完全解耦，也就是说发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现。 ● 更动态的控制 命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，从而使得系统更灵活。 ● 很自然的复合命令 命令模式中的命令对象能够很容易地组合成复合命令，也就是宏命令，从而使系统操作更简单，功能更强大。 ● 更好的扩展性 由于发起命令的对象和具体的实现完全解耦，因此扩展新的命令就很容易，只需要实现新的命令对象，然后在装配的时候，把具体的实现对象设置到命令对象中，然后就可以使用这个命令对象，已有的实现完全不用变化。 缺点使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。]]></content>
      <categories>
        <category>设计模式</category>
        <category>行为型模式</category>
      </categories>
      <tags>
        <tag>命令模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式定义代理模式(Proxy Pattern) ：给某一个对象提供一个代 理，并由代理对象控制对原对象的引用。代理模式的英 文叫做Proxy或Surrogate，它是一种对象结构型模式。 二、模式结构代理模式包含如下角色： Subject: 抽象主题角色 Proxy: 代理主题角色 RealSubject: 真实主题角色 三、时序图 四、模式的简单实现抽象对象角色 1234public abstract class AbstractObject &#123; //操作 public abstract void operation();&#125; 目标对象角色 1234567public class RealObject extends AbstractObject &#123; @Override public void operation() &#123; //一些操作 System.out.println(&quot;一些操作&quot;); &#125;&#125; 代理对象角色 1234567891011public class ProxyObject extends AbstractObject&#123; RealObject realObject = new RealObject(); @Override public void operation() &#123; //调用目标对象之前可以做相关操作 System.out.println(&quot;before&quot;); realObject.operation(); //调用目标对象之后可以做相关操作 System.out.println(&quot;after&quot;); &#125;&#125; 客户端 123456public class Client &#123; public static void main(String[] args) &#123; AbstractObject obj = new ProxyObject(); obj.operation(); &#125;&#125; 五、代理模式在Binder中的使用直观来说，Binder是Android中的一个类，它继承了IBinder接口。从IPC角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager（ActivityManager、WindowManager，etc）和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当你bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于AIDL的服务。 Binder一个很重要的作用是：将客户端的请求参数通过Parcel包装后传到远程服务端，远程服务端解析数据并执行对应的操作，同时客户端线程挂起，当服务端方法执行完毕后，再将返回结果写入到另外一个Parcel中并将其通过Binder传回到客户端，客户端接收到返回数据的Parcel后，Binder会解析数据包中的内容并将原始结果返回给客户端，至此，整个Binder的工作过程就完成了。由此可见，Binder更像一个数据通道，Parcel对象就在这个通道中跨进程传输，至于双方如何通信，这并不负责，只需要双方按照约定好的规范去打包和解包数据即可。 为了更好地说明Binder，这里我们先手动实现了一个Binder。为了使得逻辑更清晰，这里简化一下，我们来模拟一个银行系统，这个银行提供的功能只有一个：即查询余额，只有传递一个int的id过来，银行就会将你的余额设置为id*10，满足下大家的发财梦。 先定义一个Binder接口 123456789101112131415package com.ryg.design.manualbinder;import android.os.IBinder;import android.os.IInterface;import android.os.RemoteException;public interface IBank extends IInterface &#123; static final String DESCRIPTOR = "com.ryg.design.manualbinder.IBank"; static final int TRANSACTION_queryMoney = (IBinder.FIRST_CALL_TRANSACTION + 0); public long queryMoney(int uid) throws RemoteException;&#125; 2.创建一个Binder并实现这个上述接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package com.ryg.design.manualbinder;import android.os.Binder;import android.os.IBinder;import android.os.Parcel;import android.os.RemoteException;public class BankImpl extends Binder implements IBank &#123; public BankImpl() &#123; this.attachInterface(this, DESCRIPTOR); &#125; public static IBank asInterface(IBinder obj) &#123; if ((obj == null)) &#123; return null; &#125; android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin != null) &amp;&amp; (iin instanceof IBank))) &#123; return ((IBank) iin); &#125; return new BankImpl.Proxy(obj); &#125; @Override public IBinder asBinder() &#123; return this; &#125; @Override public boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException &#123; switch (code) &#123; case INTERFACE_TRANSACTION: &#123; reply.writeString(DESCRIPTOR); return true; &#125; case TRANSACTION_queryMoney: &#123; data.enforceInterface(DESCRIPTOR); int uid = data.readInt(); long result = this.queryMoney(uid); reply.writeNoException(); reply.writeLong(result); return true; &#125; &#125; return super.onTransact(code, data, reply, flags); &#125; @Override public long queryMoney(int uid) throws RemoteException &#123; return uid * 10l; &#125; private static class Proxy implements IBank &#123; private IBinder mRemote; Proxy(IBinder remote) &#123; mRemote = remote; &#125; @Override public IBinder asBinder() &#123; return mRemote; &#125; public java.lang.String getInterfaceDescriptor() &#123; return DESCRIPTOR; &#125; @Override public long queryMoney(int uid) throws RemoteException &#123; Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); long result; try &#123; data.writeInterfaceToken(DESCRIPTOR); data.writeInt(uid); mRemote.transact(TRANSACTION_queryMoney, data, reply, 0); reply.readException(); result = reply.readLong(); &#125; finally &#123; reply.recycle(); data.recycle(); &#125; return result; &#125; &#125;&#125; ok，到此为止，我们的Binder就完成了，这里只要创建服务端和客户端，二者就能通过我们的Binder来通信了。这里就不做这个示例了，我们的目的是分析代理模式在Binder中的使用。 我们看上述Binder的实现中，有一个叫做“Proxy”的类，它的构造方法如下： 123Proxy(IBinder remote) &#123; mRemote = remote;&#125; Proxy类接收一个IBinder参数，这个参数实际上就是服务端Service中的onBind方法返回的Binder对象在客户端重新打包后的结果，因为客户端无法直接通过这个打包的Binder和服务端通信，因此客户端必须借助Proxy类来和服务端通信，这里Proxy的作用就是代理的作用，客户端所有的请求全部通过Proxy来代理，具体工作流程为：Proxy接收到客户端的请求后，会将客户端的请求参数打包到Parcel对象中，然后将Parcel对象通过它内部持有的Ibinder对象传送到服务端，服务端接收数据、执行方法后返回结果给客户端的Proxy，Proxy解析数据后返回给客户端的真正调用者。很显然，上述所分析的就是典型的代理模式。至于Binder如何传输数据，这涉及到很底层的知识，这个很难搞懂，但是数据传输的核心思想是共享内存。 六、优缺点优点 给对象增加了本地化的扩展性，增加了存取操作控制 缺点 会产生多余的代理类]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰者模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、装饰者模式的概念装饰者模式又名包装(Wrapper)模式。装饰者模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。 装饰者模式动态地将责任附加到对象身上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 二、装饰者模式的结构装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任。换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰者模式可以在不使用创造更多子类的情况下，将对象的功能加以扩展。 装饰者模式的类图如下： 在装饰模式中的角色有： ● 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收附加责任的对象。 ● 具体构件(ConcreteComponent)角色：定义一个将要接收附加责任的类。 ● 装饰(Decorator)角色：持有一个构件(Component)对象的实例，并定义一个与抽象构件接口一致的接口。 ● 具体装饰(ConcreteDecorator)角色：负责给构件对象“贴上”附加的责任。抽象构件角色 12345public interface Component &#123; public void sampleOperation();&#125; 具体构件角色 1234567public class ConcreteComponent implements Component &#123; @Override public void sampleOperation() &#123; // 写相关的业务代码 &#125;&#125; 装饰角色 12345678910111213public class Decorator implements Component&#123; private Component component; public Decorator(Component component)&#123; this.component = component; &#125; @Override public void sampleOperation() &#123; // 委派给构件 component.sampleOperation(); &#125; &#125; 具体装饰角色 12345678910111213public class ConcreteDecoratorA extends Decorator &#123; public ConcreteDecoratorA(Component component) &#123; super(component); &#125; @Override public void sampleOperation() &#123; // 写相关的业务代码 super.sampleOperation(); // 写相关的业务代码 &#125;&#125; 三、装饰者模式实例演示齐天大圣的例子孙悟空有七十二般变化，他的每一种变化都给他带来一种附加的本领。他变成鱼儿时，就可以到水里游泳；他变成鸟儿时，就可以在天上飞行。 本例中，Component的角色便由鼎鼎大名的齐天大圣扮演；ConcreteComponent的角色属于大圣的本尊，就是猢狲本人；Decorator的角色由大圣的七十二变扮演。而ConcreteDecorator的角色便是鱼儿、鸟儿等七十二般变化。 抽象构件角色“齐天大圣”接口定义了一个move()方法，这是所有的具体构件类和装饰类必须实现的。 12345//大圣的尊号public interface TheGreatestSage &#123; public void move();&#125; 具体构件角色“大圣本尊”猢狲类 12345678public class Monkey implements TheGreatestSage &#123; @Override public void move() &#123; //代码 System.out.println("Monkey Move"); &#125;&#125; 抽象装饰角色“七十二变” 123456789101112public class Change implements TheGreatestSage &#123; private TheGreatestSage sage; public Change(TheGreatestSage sage)&#123; this.sage = sage; &#125; @Override public void move() &#123; // 代码 sage.move(); &#125;&#125; 具体装饰角色“鱼儿” 123456789101112public class Fish extends Change &#123; public Fish(TheGreatestSage sage) &#123; super(sage); &#125; @Override public void move() &#123; // 代码 System.out.println("Fish Move"); &#125;&#125; 具体装饰角色“鸟儿” 123456789101112public class Bird extends Change &#123; public Bird(TheGreatestSage sage) &#123; super(sage); &#125; @Override public void move() &#123; // 代码 System.out.println("Bird Move"); &#125;&#125; 客户端调用 123456789101112public class Client &#123; public static void main(String[] args) &#123; TheGreatestSage sage = new Monkey(); // 第一种写法 单层装饰 TheGreatestSage bird = new Bird(sage); TheGreatestSage fish = new Fish(bird); // 第二种写法 双层装饰 //TheGreatestSage fish = new Fish(new Bird(sage)); fish.move(); &#125;&#125; “大圣本尊”是ConcreteComponent类，而“鸟儿”、“鱼儿”是装饰类。要装饰的是“大圣本尊”，也即“猢狲”实例。 上面的例子中，第二种些方法：系统把大圣从一只猢狲装饰成了一只鸟儿（把鸟儿的功能加到了猢狲身上），然后又把鸟儿装饰成了一条鱼儿（把鱼儿的功能加到了猢狲+鸟儿身上，得到了猢狲+鸟儿+鱼儿）。 如上图所示，大圣的变化首先将鸟儿的功能附加到了猢狲身上，然后又将鱼儿的功能附加到猢狲+鸟儿身上。 四、装饰者模式的一些变化1.装饰者模式的简化大多数情况下，装饰者模式的实现都要比上面给出的示意性例子要简单。 如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类。如下图所示： 如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。甚至在只有两个ConcreteDecorator类的情况下，都可以这样做。如下图所示： 2.透明性的要求装饰者模式对客户端的透明性要求程序不要声明一个ConcreteComponent类型的变量，而应当声明一个Component类型的变量。 用孙悟空的例子来说，必须永远把孙悟空的所有变化都当成孙悟空来对待，而如果把老孙变成的鱼儿当成鱼儿，而不是老孙，那就被老孙骗了，而这时不应当发生的。下面的做法是对的： 12TheGreatestSage sage = new Monkey();TheGreatestSage bird = new Bird(sage); 而下面的做法是不对的： 12Monkey sage = new Monkey();Bird bird = new Bird(sage); 3.半透明的装饰者模式然而，纯粹的装饰者模式很难找到。装饰者模式的用意是在不改变接口的前提下，增强所考虑的类的性能。在增强性能的时候，往往需要建立新的公开的方法。即便是在孙大圣的系统里，也需要新的方法。比如齐天大圣类并没有飞行的能力，而鸟儿有。这就意味着鸟儿应当有一个新的fly()方法。再比如，齐天大圣类并没有游泳的能力，而鱼儿有，这就意味着在鱼儿类里应当有一个新的swim()方法。 这就导致了大多数的装饰者模式的实现都是“半透明”的，而不是完全透明的。换言之，允许装饰者模式改变接口，增加新的方法。这意味着客户端可以声明ConcreteDecorator类型的变量，从而可以调用ConcreteDecorator类中才有的方法： 123TheGreatestSage sage = new Monkey();Bird bird = new Bird(sage);bird.fly(); 半透明的装饰者模式是介于装饰者模式和适配器模式之间的。适配器模式的用意是改变所考虑的类的接口，也可以通过改写一个或几个方法，或增加新的方法来增强或改变所考虑的类的功能。大多数的装饰者模式实际上是半透明的装饰者模式，这样的装饰者模式也称做半装饰、半适配器模式。 五、装饰者模式的优缺点装饰模式的优点 （1）装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。 （2）通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 装饰模式的缺点 由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。 六、装饰者模式在Java IO流中的应用装饰者模式在Java语言中的最著名的应用莫过于Java I/O标准库的设计了。 由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现。而如果采用装饰者模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰者模式是Java I/O库的基本模式。 Java I/O库的对象结构图如下，由于Java I/O的对象众多，因此只画出InputStream的部分。 根据上图可以看出： ● 抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。 ● 具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。 ● 抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。 ● 具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。 半透明的装饰者模式装饰者模式和适配器模式都是“包装模式(Wrapper Pattern)”，它们都是通过封装其他对象达到设计的目的的，但是它们的形态有很大区别。 理想的装饰者模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。而适配器模式则不然，一般而言，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。 装饰者模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。透明的装饰者模式也就是理想的装饰者模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，装饰角色实际上已经成了一个适配器角色，这种装饰者模式也是可以接受的，称为“半透明”的装饰模式，如下图所示。 在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类接口宽。 显然，半透明的装饰者模式实际上就是处于适配器模式与装饰者模式之间的灰色地带。如果将装饰者模式与适配器模式合并成为一个“包装模式”的话，那么半透明的装饰者模式倒可以成为这种合并后的“包装模式”的代表。 InputStream类型中的装饰者模式InputStream类型中的装饰者模式是半透明的。为了说明这一点，不妨看一看作装饰者模式的抽象构件角色的InputStream的源代码。这个抽象类声明了九个方法，并给出了其中八个的实现，另外一个是抽象方法，需要由子类实现。 123456789101112131415161718192021public abstract class InputStream implements Closeable &#123; public abstract int read() throws IOException; public int read(byte b[]) throws IOException &#123;&#125; public int read(byte b[], int off, int len) throws IOException &#123;&#125; public long skip(long n) throws IOException &#123;&#125; public int available() throws IOException &#123;&#125; public void close() throws IOException &#123;&#125; public synchronized void mark(int readlimit) &#123;&#125; public synchronized void reset() throws IOException &#123;&#125; public boolean markSupported() &#123;&#125;&#125; 下面是作为装饰模式的抽象装饰角色FilterInputStream类的源代码。可以看出，FilterInputStream的接口与InputStream的接口是完全一致的。也就是说，直到这一步，还是与装饰模式相符合的。 123456789101112131415161718192021public class FilterInputStream extends InputStream &#123; protected FilterInputStream(InputStream in) &#123;&#125; public int read() throws IOException &#123;&#125; public int read(byte b[]) throws IOException &#123;&#125; public int read(byte b[], int off, int len) throws IOException &#123;&#125; public long skip(long n) throws IOException &#123;&#125; public int available() throws IOException &#123;&#125; public void close() throws IOException &#123;&#125; public synchronized void mark(int readlimit) &#123;&#125; public synchronized void reset() throws IOException &#123;&#125; public boolean markSupported() &#123;&#125;&#125; 下面是具体装饰角色PushbackInputStream的源代码。 1234567891011121314151617181920212223242526272829public class PushbackInputStream extends FilterInputStream &#123; private void ensureOpen() throws IOException &#123;&#125; public PushbackInputStream(InputStream in, int size) &#123;&#125; public PushbackInputStream(InputStream in) &#123;&#125; public int read() throws IOException &#123;&#125; public int read(byte[] b, int off, int len) throws IOException &#123;&#125; public void unread(int b) throws IOException &#123;&#125; public void unread(byte[] b, int off, int len) throws IOException &#123;&#125; public void unread(byte[] b) throws IOException &#123;&#125; public int available() throws IOException &#123;&#125; public long skip(long n) throws IOException &#123;&#125; public boolean markSupported() &#123;&#125; public synchronized void mark(int readlimit) &#123;&#125; public synchronized void reset() throws IOException &#123;&#125; public synchronized void close() throws IOException &#123;&#125;&#125; 查看源码，你会发现，这个装饰类提供了额外的方法unread()，这就意味着PushbackInputStream是一个半透明的装饰类。换言 之，它破坏了理想的装饰者模式的要求。如果客户端持有一个类型为InputStream对象的引用in的话，那么如果in的真实类型是 PushbackInputStream的话，只要客户端不需要使用unread()方法，那么客户端一般没有问题。但是如果客户端必须使用这个方法，就 必须进行向下类型转换。将in的类型转换成为PushbackInputStream之后才可能调用这个方法。但是，这个类型转换意味着客户端必须知道它 拿到的引用是指向一个类型为PushbackInputStream的对象。这就破坏了使用装饰者模式的原始用意。 现实世界与理论总归是有一段差距的。纯粹的装饰者模式在真实的系统中很难找到。一般所遇到的，都是这种半透明的装饰者模式。 下面是使用I/O流读取文件内容的简单操作示例。 123456789101112131415161718192021public class IOTest &#123; public static void main(String[] args) throws IOException &#123; // 流式读取文件 DataInputStream dis = null; try&#123; dis = new DataInputStream( new BufferedInputStream( new FileInputStream("test.txt") ) ); //读取文件内容 byte[] bs = new byte[dis.available()]; dis.read(bs); String content = new String(bs); System.out.println(content); &#125;finally&#123; dis.close(); &#125; &#125;&#125; 观察上面的代码，会发现最里层是一个FileInputStream对象，然后把它传递给一个BufferedInputStream对象，经过BufferedInputStream处理，再把处理后的对象传递给了DataInputStream对象进行处理，这个过程其实就是装饰器的组装过程，FileInputStream对象相当于原始的被装饰的对象，而BufferedInputStream对象和DataInputStream对象则相当于装饰器。]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>装饰者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、外观模式概述1.定义外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 2.定义阐述医院的例子 现代的软件系统都是比较复杂的，设计师处理复杂系统的一个常见方法便是将其“分而治之”，把一个系统划分为几个较小的子系统。如果把医院作为一个子系统，按照部门职能，这个系统可以划分为挂号、门诊、划价、化验、收费、取药等。看病的病人要与这些部门打交道，就如同一个子系统的客户端与一个子系统的各个类打交道一样，不是一件容易的事情。 首先病人必须先挂号，然后门诊。如果医生要求化验，病人必须首先划价，然后缴费，才可以到化验部门做化验。化验后再回到门诊室。 上图描述的是病人在医院里的体验，图中的方框代表医院。 解决这种不便的方法便是引进外观模式，医院可以设置一个接待员的位置，由接待员负责代为挂号、划价、缴费、取药等。这个接待员就是外观模式的体现，病人只接触接待员，由接待员与各个部门打交道。 二、外观模式结构外观模式没有一个一般化的类图描述，最好的描述方法实际上就是以一个例子说明。 由于门面模式的结构图过于抽象，因此把它稍稍具体点。假设子系统内有三个模块，分别是ModuleA、ModuleB和ModuleC，它们分别有一个示例方法，那么此时示例的整体结构图如下： 在这个对象图中，出现了两个角色：● 外观(Facade)角色 ：客户端可以调用这个角色的方法。此角色知晓相关的（一个或者多个）子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。 ● 子系统(SubSystem)角色 ：可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。 时序图 子系统角色中的类： 123456public class ModuleA &#123; //示意方法 public void testA()&#123; System.out.println("调用ModuleA中的testA方法"); &#125;&#125; 123456public class ModuleB &#123; //示意方法 public void testB()&#123; System.out.println("调用ModuleB中的testB方法"); &#125;&#125; 123456public class ModuleC &#123; //示意方法 public void testC()&#123; System.out.println("调用ModuleC中的testC方法"); &#125;&#125; 外观角色类: 1234567891011public class Facade &#123; //示意方法，满足客户端需要的功能 public void test()&#123; ModuleA a = new ModuleA(); a.testA(); ModuleB b = new ModuleB(); b.testB(); ModuleC c = new ModuleC(); c.testC(); &#125;&#125; 客户端角色类： 123456789public class Client &#123; public static void main(String[] args) &#123; Facade facade = new Facade(); facade.test(); &#125;&#125; Facade类其实相当于A、B、C模块的外观界面，有了这个Facade类，那么客户端就不需要亲自调用子系统中的A、B、C模块了，也不需要知道系统内部的实现细节，甚至都不需要知道A、B、C模块的存在，客户端只需要跟Facade类交互就好了，从而更好地实现了客户端和子系统中A、B、C模块的解耦，让客户端更容易地使用系统。 三、外观模式的扩展使用外观模式还有一个附带的好处，就是能够有选择性地暴露方法。一个模块中定义的方法可以分成两部分，一部分是给子系统外部使用的，一部分是子系统内部模块之间相互调用时使用的。有了Facade类，那么用于子系统内部模块之间相互调用的方法就不用暴露给子系统外部了。 比如，定义如下A、B、C模块。 123456789101112public class Module &#123; /** * 提供给子系统外部使用的方法 */ public void a1()&#123;&#125;; /** * 子系统内部模块之间相互调用时使用的方法 */ public void a2()&#123;&#125;; public void a3()&#123;&#125;;&#125; 123456789101112public class ModuleB &#123; /** * 提供给子系统外部使用的方法 */ public void b1()&#123;&#125;; /** * 子系统内部模块之间相互调用时使用的方法 */ public void b2()&#123;&#125;; public void b3()&#123;&#125;;&#125; 123456789101112public class ModuleC &#123; /** * 提供给子系统外部使用的方法 */ public void c1()&#123;&#125;; /** * 子系统内部模块之间相互调用时使用的方法 */ public void c2()&#123;&#125;; public void c3()&#123;&#125;;&#125; 123456789101112131415161718public class ModuleFacade &#123; ModuleA a = new ModuleA(); ModuleB b = new ModuleB(); ModuleC c = new ModuleC(); /** * 下面这些是A、B、C模块对子系统外部提供的方法 */ public void a1()&#123; a.a1(); &#125; public void b1()&#123; b.b1(); &#125; public void c1()&#123; c.c1(); &#125;&#125; 这样定义一个ModuleFacade类可以有效地屏蔽内部的细节，免得客户端去调用Module类时，发现一些不需要它知道的方法。比如a2()和a3()方法就不需要让客户端知道，否则既暴露了内部的细节，又让客户端迷惑。 一个系统可以有几个外观类在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个外观类，而仅仅是说对每一个子系统只有一个外观类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个外观类，整个系统可以有数个外观类。 为子系统增加新行为初学者往往以为通过继承一个外观类便可在子系统中加入新的行为，这是错误的。外观模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。 四、外观模式的实例1.实例说明某软件公司欲开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括三个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这三个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这三个操作的业务代码封装在三个不同的类中。 2.实例类图 EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。 3.实例代码FileReader：文件读取类，充当子系统类。 1234567891011121314151617181920212223242526272829class FileReader &#123; public string Read(string fileNameSrc) &#123; Console.Write("读取文件，获取明文："); FileStream fs = null; StringBuilder sb = new StringBuilder(); try &#123; fs = new FileStream(fileNameSrc, FileMode.Open); int data; while((data = fs.ReadByte())!= -1) &#123; sb = sb.Append((char)data); &#125; fs.Close(); Console.WriteLine(sb.ToString()); &#125; catch(FileNotFoundException e) &#123; Console.WriteLine("文件不存在！"); &#125; catch(IOException e) &#123; Console.WriteLine("文件操作错误！"); &#125; return sb.ToString(); &#125; &#125; CipherMachine：数据加密类，充当子系统类。 12345678910111213141516class CipherMachine &#123; public string Encrypt(string plainText) &#123; Console.Write("数据加密，将明文转换为密文："); string es = ""; char[] chars = plainText.ToCharArray(); foreach(char ch in chars) &#123; string c = (ch % 7).ToString(); es += c; &#125; Console.WriteLine(es); return es; &#125; &#125; FileWriter：文件保存类，充当子系统类。 12345678910111213141516171819202122232425class FileWriter &#123; public void Write(string encryptStr,string fileNameDes) &#123; Console.WriteLine("保存密文，写入文件。"); FileStream fs = null; try &#123; fs = new FileStream(fileNameDes, FileMode.Create); byte[] str = Encoding.Default.GetBytes(encryptStr); fs.Write(str,0,str.Length); fs.Flush(); fs.Close(); &#125; catch(FileNotFoundException e) &#123; Console.WriteLine("文件不存在！"); &#125; catch(IOException e) &#123; Console.WriteLine(e.Message); Console.WriteLine("文件操作错误！"); &#125; &#125; &#125; EncryptFacade：加密外观类，充当外观类。 12345678910111213141516171819202122class EncryptFacade &#123; //维持对其他对象的引用 private FileReader reader; private CipherMachine cipher; private FileWriter writer; public EncryptFacade() &#123; reader = new FileReader(); cipher = new CipherMachine(); writer = new FileWriter(); &#125; //调用其他对象的业务方法 public void FileEncrypt(string fileNameSrc, string fileNameDes) &#123; string plainStr = reader.Read(fileNameSrc); string encryptStr = cipher.Encrypt(plainStr); writer.Write(encryptStr, fileNameDes); &#125; &#125; Program：客户端测试类 123456789class Program &#123; static void Main(string[] args) &#123; EncryptFacade ef = new EncryptFacade(); ef.FileEncrypt("src.txt", "des.txt"); Console.Read(); &#125; &#125; 五、外观模式的优点● 松散耦合 外观模式松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护。 ● 简单易用 外观模式让子系统更加易用，客户端不再需要了解子系统内部的实现，也不需要跟众多子系统内部的模块进行交互，只需要跟外观类交互就可以了。 ● 更好的划分访问层次 通过合理使用Facade，可以帮助我们更好地划分访问的层次。有些方法是对系统外的，有些方法是系统内部使用的。把需要暴露给外部的功能集中到外观中，这样既方便客户端使用，也很好地隐藏了内部的细节。]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>外观模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、适配器模式简介1.定义适配器模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。 2.定义阐述适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。 例如： 用电器做例子，笔记本电脑的插头一般都是三相的，即除了阳极、阴极外，还有一个地极。而有些地方的电源插座却只有两极，没有地极。电源插座与笔记本电脑的电源插头不匹配使得笔记本电脑无法使用。这时候一个三相到两相的转换器（适配器）就能解决此问题，而这正像是本模式所做的事情。 二、适配器模式结构适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。 类适配器模式类的适配器模式把适配的类的API转换成为目标类的API。 在上图中可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，提供一个中间环节，即类Adapter，把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是继承关系，这决定了这个适配器模式是类的： 模式所涉及的角色有： ● 目标(Target)角色：这就是所期待得到的接口。注意：由于这里讨论的是类适配器模式，因此目标不可以是类。 ● 源(Adapee)角色：现在需要适配的接口。 ● 适配器(Adaper)角色：适配器类是本模式的核心。适配器把源接口转换成目标接口。显然，这一角色不可以是接口，而必须是具体类。 12345678910public interface Target &#123; /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); &#125; 上面给出的是目标角色的源代码，这个角色是以一个JAVA接口的形式实现的。可以看出，这个接口声明了两个方法：sampleOperation1()和sampleOperation2()。而源角色Adaptee是一个具体类，它有一个sampleOperation1()方法，但是没有sampleOperation2()方法。 12345public class Adaptee &#123; public void sampleOperation1()&#123;&#125;&#125; 适配器角色Adapter扩展了Adaptee,同时又实现了目标(Target)接口。由于Adaptee没有提供sampleOperation2()方法，而目标接口又要求这个方法，因此适配器角色Adapter实现了这个方法。 1234567891011public class Adapter extends Adaptee implements Target &#123; /** * 由于源类Adaptee没有方法sampleOperation2() * 因此适配器补充上这个方法 */ @Override public void sampleOperation2() &#123; //写相关的代码 &#125;&#125; 对象适配器模式与类的适配器模式一样，对象的适配器模式把被适配的类的API转换成为目标类的API，与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。 从上图可以看出，Adaptee类并没有sampleOperation2()方法，而客户端则期待这个方法。为使客户端能够使用Adaptee类，需要提供一个包装(Wrapper)类Adapter。这个包装类包装了一个Adaptee的实例，从而此包装类能够把Adaptee的API与Target类的API衔接起来。Adapter与Adaptee是委派关系，这决定了适配器模式是对象的。 12345678910public interface Target &#123; /** * 这是源类Adaptee也有的方法 */ public void sampleOperation1(); /** * 这是源类Adapteee没有的方法 */ public void sampleOperation2(); &#125; 12345public class Adaptee &#123; public void sampleOperation1()&#123;&#125;&#125; 123456789101112131415161718192021public class Adapter &#123; private Adaptee adaptee; public Adapter(Adaptee adaptee)&#123; this.adaptee = adaptee; &#125; /** * 源类Adaptee有方法sampleOperation1 * 因此适配器类直接委派即可 */ public void sampleOperation1()&#123; this.adaptee.sampleOperation1(); &#125; /** * 源类Adaptee没有方法sampleOperation2 * 因此由适配器类需要补充此方法 */ public void sampleOperation2()&#123; //写相关的代码 &#125;&#125; 时序图 三、类适配器和对象适配器的权衡● 类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。 ● 对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了。 ● 对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。 ● 对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。 ● 对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。 ● 对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。 ● 对于对象适配器，需要额外的引用来间接得到Adaptee。 建议尽量使用对象适配器的实现方式，多用合成/聚合、少用继承。当然，具体问题具体分析，根据需要来选用实现方式，最适合的才是最好的。 四、缺省适配器缺省适配(Default Adapter)模式为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。 当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。 五、Java中适配器模式的使用JDK1.1 之前提供的容器有 Arrays,Vector,Stack,Hashtable,Properties,BitSet，其中定义了一种访问群集内各元素的标准方式，称为 Enumeration（列举器）接口。 12345Vector v=new Vector();for (Enumeration enum =v.elements(); enum.hasMoreElements();) &#123; Object o = enum.nextElement(); processObject(o);&#125; JDK1.2 版本中引入了 Iterator 接口，新版本的集合对（HashSet,HashMap,WeakHeahMap,ArrayList,TreeSet,TreeMap, LinkedList）是通过 Iterator 接口访问集合元素。 1234List list=new ArrayList();for(Iterator it=list.iterator();it.hasNext();)&#123; System.out.println(it.next());&#125; 这样，如果将老版本的程序运行在新的 Java 编译器上就会出错。因为 List 接口中已经没有 elements()，而只有 iterator() 了。那么如何将老版本的程序运行在新的 Java 编译器上呢? 如果不加修改，是肯定不行的，但是修改要遵循“开－闭”原则。我们可以用 Java 设计模式中的适配器模式解决这个问题。 12345678910111213141516171819202122232425public class NewEnumeration implements Enumeration &#123; Iterator it; public NewEnumeration(Iterator it) &#123; this.it = it; &#125; public boolean hasMoreElements() &#123; return it.hasNext(); &#125; public Object nextElement() &#123; return it.next(); &#125; public static void main(String[] args) &#123; List list = new ArrayList(); list.add("a"); list.add("b"); list.add("C"); for (Enumeration e = new NewEnumeration(list.iterator()); e.hasMoreElements(); ) &#123; System.out.println(e.nextElement()); &#125; &#125;&#125; NewEnumeration 是一个适配器类，通过它实现了从 Iterator 接口到 Enumeration 接口的适配，这样我们就可以使用老版本的代码来使用新的集合对象了。 六、Android中适配器模式的使用在开发过程中,ListView的Adapter是我们最为常见的类型之一。一般的用法大致如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 // 代码省略 ListView myListView = (ListView) findViewById(listview_id);// 设置适配器 myListView.setAdapter(new MyAdapter(context,myDatas));// 适配器public class MyAdapter extends BaseAdapter &#123; private LayoutInflater mInflater; List&lt;String&gt; mDatas; public MyAdapter(Context context, List&lt;String&gt; datas) &#123; this.mInflater = LayoutInflater.from(context); mDatas = datas; &#125; @Override public int getCount() &#123; return mDatas.size(); &#125; @Override public String getItem(int pos) &#123; return mDatas.get(pos); &#125; @Override public long getItemId(int pos) &#123; return pos; &#125; // 解析、设置、缓存convertView以及相关内容 @Override public View getView(int position, View convertView, ViewGroup parent) &#123; ViewHolder holder = null; // Item View的复用 if (convertView == null) &#123; holder = new ViewHolder(); convertView = mInflater.inflate(R.layout.my_listview_item, null); // 获取title holder.title = (TextView) convertView.findViewById(R.id.title); convertView.setTag(holder); &#125; else &#123; holder = (ViewHolder) convertView.getTag(); &#125; holder.title.setText(mDatas.get(position)); return convertView; &#125;&#125; 我们知道，作为最重要的View，ListView需要能够显示各式各样的视图，每个人需要的显示效果各不相同，显示的数据类型、数量等也千变万化。那么如何隔离这种变化尤为重要。 Android的做法是增加一个Adapter层来应对变化，将ListView需要的接口抽象到Adapter对象中，这样只要用户实现了Adapter的接口，ListView就可以按照用户设定的显示效果、数量、数据来显示特定的Item View。 通过代理数据集来告知ListView数据的个数( getCount函数 )以及每个数据的类型( getItem函数 )，最重要的是要解决Item View的输出。Item View千变万化，但终究它都是View类型，Adapter统一将Item View输出为View ( getView函数 )，这样就很好的应对了Item View的可变性。 那么ListView是如何通过Adapter模式 ( 不止Adapter模式 )来运作的呢 ？我们一起来看一看。ListView继承自AbsListView，Adapter定义在AbsListView中，我们看一看这个类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback &#123; ListAdapter mAdapter; // 关联到Window时调用的函数 @Override protected void onAttachedToWindow() &#123; super.onAttachedToWindow(); // 代码省略 // 给适配器注册一个观察者。 if (mAdapter != null&amp;&amp; mDataSetObserver == null)&#123; mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); // Data may have changed while we were detached. Refresh. mDataChanged = true; mOldItemCount = mItemCount // 获取Item的数量,调用的是mAdapter的getCount方法 mItemCount = mAdapter.getCount(); &#125; mIsAttached = true; &#125; /** * 子类需要覆写layoutChildren()函数来布局child view,也就是Item View */ @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; super.onLayout(changed, l, t, r, b); mInLayout = true; if (changed) &#123; int childCount = getChildCount(); for (int i = 0; i&lt;childCount; i++) &#123; getChildAt(i).forceLayout(); &#125; mRecycler.markChildrenDirty(); &#125; if (mFastScroller != null&amp;&amp; mItemCount != mOldItemCount)&#123; mFastScroller.onItemCountChanged(mOldItemCount, mItemCount); &#125; // 布局Child View layoutChildren(); mInLayout = false; mOverscrollMax = (b - t) / OVERSCROLL_LIMIT_DIVISOR; &#125; // 获取一个Item View View obtainView(int position, boolean[] isScrap) &#123; isScrap[0] = false; View scrapView; // 从缓存的Item View中获取,ListView的复用机制就在这里 scrapView = mRecycler.getScrapView(position); View child; if (scrapView != null) &#123; // 代码省略 child = mAdapter.getView(position, scrapView, this); // 代码省略 &#125; else &#123; child = mAdapter.getView(position, null, this); // 代码省略 &#125; return child; &#125;&#125; 通过增加Adapter一层来将Item View的操作抽象起来，ListView等集合视图通过Adapter对象获得Item的个数、数据元素、Item View等，从而达到适配各种数据、各种Item视图的效果。 因为Item View和数据类型千变万化，Android的架构师们将这些变化的部分交给用户来处理，通过getCount、getItem、getView等几个方法抽象出来，也就是将Item View的构造过程交给用户来处理，灵活地运用了适配器模式，达到了无限适配、拥抱变化的目的。 七、适配器模式的优缺点适配器模式的优点更好的复用性 系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。 更好的扩展性 在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。 适配器模式的缺点过多的使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是A接口，其实内部被适配成了B接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。]]></content>
      <categories>
        <category>设计模式</category>
        <category>结构型模式</category>
      </categories>
      <tags>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、模式定义造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。 二、模式结构建造者模式包含如下角色： Builder：抽象建造者 ConcreteBuilder：具体建造者 Director：指挥者 Product：产品角色 三、时序图 四、简单实现电脑的组装过程较为复杂，步骤繁多，但是顺序却是不固定的。下面我们以组装电脑为例来演示一下简单且经典的builder模式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159package com.dp.example.builder;/** * Computer产品抽象类, 为了例子简单, 只列出这几个属性 * * @author mrsimple * */public abstract class Computer &#123; protected int mCpuCore = 1; protected int mRamSize = 0; protected String mOs = "Dos"; protected Computer() &#123; &#125; // 设置CPU核心数 public abstract void setCPU(int core); // 设置内存 public abstract void setRAM(int gb); // 设置操作系统 public abstract void setOs(String os); @Override public String toString() &#123; return "Computer [mCpuCore=" + mCpuCore + ", mRamSize=" + mRamSize + ", mOs=" + mOs + "]"; &#125;&#125;package com.dp.example.builder;/** * Apple电脑 */public class AppleComputer extends Computer &#123; protected AppleComputer() &#123; &#125; @Override public void setCPU(int core) &#123; mCpuCore = core; &#125; @Override public void setRAM(int gb) &#123; mRamSize = gb; &#125; @Override public void setOs(String os) &#123; mOs = os; &#125;&#125;package com.dp.example.builder;package com.dp.example.builder;/** * builder抽象类 * */public abstract class Builder &#123; // 设置CPU核心数 public abstract void buildCPU(int core); // 设置内存 public abstract void buildRAM(int gb); // 设置操作系统 public abstract void buildOs(String os); // 创建Computer public abstract Computer create();&#125;package com.dp.example.builder;public class ApplePCBuilder extends Builder &#123; private Computer mApplePc = new AppleComputer(); @Override public void buildCPU(int core) &#123; mApplePc.setCPU(core); &#125; @Override public void buildRAM(int gb) &#123; mApplePc.setRAM(gb); &#125; @Override public void buildOs(String os) &#123; mApplePc.setOs(os); &#125; @Override public Computer create() &#123; return mApplePc; &#125;&#125;package com.dp.example.builder;public class Director &#123; Builder mBuilder = null; /** * * @param builder */ public Director(Builder builder) &#123; mBuilder = builder; &#125; /** * 构建对象 * * @param cpu * @param ram * @param os */ public void construct(int cpu, int ram, String os) &#123; mBuilder.buildCPU(cpu); mBuilder.buildRAM(ram); mBuilder.buildOs(os); &#125;&#125;/** * 经典实现较为繁琐 * * @author mrsimple * */public class Test &#123; public static void main(String[] args) &#123; // 构建器 Builder builder = new ApplePCBuilder(); // Director Director pcDirector = new Director(builder); // 封装构建过程, 4核, 内存2GB, Mac系统 pcDirector.construct(4, 2, "Mac OS X 10.9.1"); // 构建电脑, 输出相关信息 System.out.println("Computer Info : " + builder.create().toString()); &#125;&#125; 五、Android源码中模式实现在Android源码中，我们最常用到的Builder模式就是AlertDialog.Builder， 使用该Builder来构建复杂的AlertDialog对象。简单示例如下 : 1234567891011121314151617181920212223242526//显示基本的AlertDialog private void showDialog(Context context) &#123; AlertDialog.Builder builder = new AlertDialog.Builder(context); builder.setIcon(R.drawable.icon); builder.setTitle("Title"); builder.setMessage("Message"); builder.setPositiveButton("Button1", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的Button1"); &#125; &#125;); builder.setNeutralButton("Button2", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的Button2"); &#125; &#125;); builder.setNegativeButton("Button3", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int whichButton) &#123; setTitle("点击了对话框上的Button3"); &#125; &#125;); builder.create().show(); // 构建AlertDialog， 并且显示&#125; 结果 : 下面我们看看AlertDialog的相关源码 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106// AlertDialogpublic class AlertDialog extends Dialog implements DialogInterface &#123; // Controller, 接受Builder成员变量P中的各个参数 private AlertController mAlert; // 构造函数 protected AlertDialog(Context context, int theme) &#123; this(context, theme, true); &#125; // 4 : 构造AlertDialog AlertDialog(Context context, int theme, boolean createContextWrapper) &#123; super(context, resolveDialogTheme(context, theme), createContextWrapper); mWindow.alwaysReadCloseOnTouchAttr(); mAlert = new AlertController(getContext(), this, getWindow()); &#125; // 实际上调用的是mAlert的setTitle方法 @Override public void setTitle(CharSequence title) &#123; super.setTitle(title); mAlert.setTitle(title); &#125; // 实际上调用的是mAlert的setCustomTitle方法 public void setCustomTitle(View customTitleView) &#123; mAlert.setCustomTitle(customTitleView); &#125; public void setMessage(CharSequence message) &#123; mAlert.setMessage(message); &#125; // AlertDialog其他的代码省略 // ************ Builder为AlertDialog的内部类 ******************* public static class Builder &#123; // 1 : 存储AlertDialog的各个参数, 例如title, message, icon等. private final AlertController.AlertParams P; // 属性省略 /** * Constructor using a context for this builder and the &#123;@link AlertDialog&#125; it creates. */ public Builder(Context context) &#123; this(context, resolveDialogTheme(context, 0)); &#125; public Builder(Context context, int theme) &#123; P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, theme))); mTheme = theme; &#125; // Builder的其他代码省略 ...... // 2 : 设置各种参数 public Builder setTitle(CharSequence title) &#123; P.mTitle = title; return this; &#125; public Builder setMessage(CharSequence message) &#123; P.mMessage = message; return this; &#125; public Builder setIcon(int iconId) &#123; P.mIconId = iconId; return this; &#125; public Builder setPositiveButton(CharSequence text, final OnClickListener listener) &#123; P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; &#125; public Builder setView(View view) &#123; P.mView = view; P.mViewSpacingSpecified = false; return this; &#125; // 3 : 构建AlertDialog, 传递参数 public AlertDialog create() &#123; // 调用new AlertDialog构造对象， 并且将参数传递个体AlertDialog final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); // 5 : 将P中的参数应用的dialog中的mAlert对象中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) &#123; dialog.setCanceledOnTouchOutside(true); &#125; dialog.setOnCancelListener(P.mOnCancelListener); if (P.mOnKeyListener != null) &#123; dialog.setOnKeyListener(P.mOnKeyListener); &#125; return dialog; &#125; &#125; &#125; 可以看到，通过Builder来设置AlertDialog中的title, message, button等参数， 这些参数都存储在类型为AlertController.AlertParams的成员变量P中，AlertController.AlertParams中包含了与之对应的成员变量。在调用Builder类的create函数时才创建AlertDialog, 并且将Builder成员变量P中保存的参数应用到AlertDialog的mAlert对象中，即P.apply(dialog.mAlert)代码段。我们看看apply函数的实现 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void apply(AlertController dialog) &#123; if (mCustomTitleView != null) &#123; dialog.setCustomTitle(mCustomTitleView); &#125; else &#123; if (mTitle != null) &#123; dialog.setTitle(mTitle); &#125; if (mIcon != null) &#123; dialog.setIcon(mIcon); &#125; if (mIconId &gt;= 0) &#123; dialog.setIcon(mIconId); &#125; if (mIconAttrId &gt; 0) &#123; dialog.setIcon(dialog.getIconAttributeResId(mIconAttrId)); &#125; &#125; if (mMessage != null) &#123; dialog.setMessage(mMessage); &#125; if (mPositiveButtonText != null) &#123; dialog.setButton(DialogInterface.BUTTON_POSITIVE, mPositiveButtonText, mPositiveButtonListener, null); &#125; if (mNegativeButtonText != null) &#123; dialog.setButton(DialogInterface.BUTTON_NEGATIVE, mNegativeButtonText, mNegativeButtonListener, null); &#125; if (mNeutralButtonText != null) &#123; dialog.setButton(DialogInterface.BUTTON_NEUTRAL, mNeutralButtonText, mNeutralButtonListener, null); &#125; if (mForceInverseBackground) &#123; dialog.setInverseBackgroundForced(true); &#125; // For a list, the client can either supply an array of items or an // adapter or a cursor if ((mItems != null) || (mCursor != null) || (mAdapter != null)) &#123; createListView(dialog); &#125; if (mView != null) &#123; if (mViewSpacingSpecified) &#123; dialog.setView(mView, mViewSpacingLeft, mViewSpacingTop, mViewSpacingRight, mViewSpacingBottom); &#125; else &#123; dialog.setView(mView); &#125; &#125;&#125; 实际上就是把P中的参数挨个的设置到AlertController中， 也就是AlertDialog中的mAlert对象。从AlertDialog的各个setter方法中我们也可以看到，实际上也都是调用了mAlert对应的setter方法。在这里，Builder同时扮演了上文中提到的builder、ConcreteBuilder、Director的角色，简化了Builder模式的设计。 六、优缺点优点 良好的封装性， 使用建造者模式可以使客户端不必知道产品内部组成的细节； 建造者独立，容易扩展； 在对象创建过程中会使用到系统中的一些其它对象，这些对象在产品对象的创建过程中不易得到。 缺点 会产生多余的Builder对象以及Director对象，消耗内存； 对象的构建过程暴露。]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、单例模式1.定义作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 2.特点单例类只能有一个实例。 单例类必须自己创建自己的唯一实例。 单例类必须给所有其他对象提供这一实例。 二、创建单例模式的方式①懒汉式，线程不安全懒汉式其实是一种比较形象的称谓。既然懒，那么在创建对象实例的时候就不着急。会一直等到马上要使用对象实例的时候才会创建，懒人嘛，总是推脱不开的时候才会真正去执行工作，因此在装载对象的时候不创建对象实例。 1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 这段代码简单明了，而且使用了懒加载模式，但是却存在致命的问题。当有多个线程并行调用 getInstance() 的时候，就会创建多个实例。也就是说在多线程下不能正常工作。 ②懒汉式，线程安全为了解决上面的问题，最简单的方法是将整个 getInstance() 方法设为同步（synchronized）。 123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance;&#125; 虽然做到了线程安全，并且解决了多实例的问题，但是它并不高效。因为在任何时候只能有一个线程调用 getInstance() 方法。但是同步操作只需要在第一次调用时才被需要，即第一次创建单例实例对象时。这就引出了双重检验锁。 ③双重检验锁双重检验锁模式（double checked locking pattern），是一种使用同步块加锁的方法。程序员称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了。 12345678910public static Singleton getSingleton() &#123; if (instance == null) &#123; //Single Checked synchronized (Singleton.class) &#123; if (instance == null) &#123; //Double Checked instance = new Singleton(); &#125; &#125; &#125; return instance ;&#125; 这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存 2.调用 Singleton 的构造函数来初始化成员变量 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。 我们只需要将 instance 变量声明成 volatile 就可以了。 12345678910111213141516public class Singleton &#123; private volatile static Singleton instance; //声明成 volatile private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (instance == null) &#123; synchronized (Singleton.class) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 instance 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。 从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。 但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。 相信你不会喜欢这种复杂又隐含问题的方式，当然我们有更好的实现线程安全的单例模式的办法。 ④饿汉式 static final field饿汉式其实是一种比较形象的称谓。既然饿，那么在创建对象实例的时候就比较着急，饿了嘛，于是在装载类的时候就创建对象实例。 这种方法非常简单，因为单例的实例被声明成 static 和 final 变量了，在第一次加载类到内存中时就会初始化，所以创建实例本身是线程安全的。 12345678910public class Singleton&#123; //类加载时就初始化 private static final Singleton instance = new Singleton(); private Singleton()&#123;&#125; public static Singleton getInstance()&#123; return instance; &#125;&#125; 缺点是它不是一种懒加载模式（lazy initialization），单例会在加载类后一开始就被初始化，即使客户端没有调用 getInstance()方法。 饿汉式的创建方式在一些场景中将无法使用：譬如 Singleton 实例的创建是依赖参数或者配置文件的，在 getInstance() 之前必须调用某个方法设置参数给它，那样这种单例写法就无法使用了。 ⑤静态内部类 static nested class这种方法也是《Effective Java》上所推荐的。 123456789public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125; 这种写法仍然使用JVM本身机制保证了线程安全问题。由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类SingletonHolder，在该内部类中定义了一个static类型的变量INSTANCE ，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。 由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。 ⑥枚举 Enum用枚举写单例实在太简单了！这也是它最大的优点。下面这段代码就是声明枚举实例的通常做法。 123public enum EasySingleton&#123; INSTANCE;&#125; 我们可以通过EasySingleton.INSTANCE来访问实例，这比调用getInstance()方法简单多了。创建枚举默认就是线程安全的，所以不需要担心double checked locking，而且还能防止反序列化导致重新创建新的对象。 三、总结一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，上文中第一种方式线程不安全，排除。 一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）倾向于使用静态内部类。如果涉及到反序列化创建对象时会试着使用枚举的方式来实现单例。]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、抽象工厂模式简介1.定义抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。 定义很难懂？没错，看起来是很抽象，不过这正反应了这种模式的强大。下面具体阐述下定义。 2.定义阐述在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种或几种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个不同种类产品对象，而不是单一种类的产品对象。 为了更清晰地理解工厂方法模式，需要先引入两个概念： 产品等级结构 ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 产品族 ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。 当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。 二、抽象工厂模式结构1.模式结构 抽象工厂模式包含如下角色： AbstractFactory：抽象工厂ConcreteFactory：具体工厂AbstractProduct：抽象产品Product：具体产品 2.时序图 ①先调用具体工厂对象中的方法createProductX()。根据具体工厂不同可以选择不同的方法，针对同一种工厂也可以选择不同的方法创建不同类型的产品对象。 ②根据传入产品类型参数（也可以无参），获得具体的产品对象 ③返回产品对象并使用 三、抽象工厂的使用实例假设有一个移动终端工厂，可以制造苹果系列的移动产品和三星系列的移动产品。这个工厂下有两个子厂，一个负责制造苹果系列的Pad和三星系列的Pad，另一个负责制造苹果系列的手机和三星系列的手机。这便是一个典型的抽象工厂的实例。抽象产品： 苹果系列 1234public interface Apple &#123; void AppleStyle(); &#125; 抽象产品： 三星系列 1234public interface Sumsung &#123; void BangziStyle(); &#125; 具体产品：iphone 1234567public class iphone implements Apple &#123; public void AppleStyle() &#123; Console.WriteLine("Apple's style: iPhone!"); &#125; &#125; 具体产品：ipad 123456789public class ipad implements Apple &#123; public void AppleStyle() &#123; Console.WriteLine("Apple's style: iPad!"); &#125; &#125; 具体产品：note2 12345678public class note2 implements Sumsung &#123; public void BangziStyle() &#123; Console.WriteLine("Bangzi's style : Note2!"); &#125; &#125; 具体产品：tabs 1234567public class Tabs implements Sumsung &#123; public void BangziStyle() &#123; Console.WriteLine("Bangzi's style : Tab!"); &#125; &#125; 抽象工厂 12345public interface Factory &#123; Apple createAppleProduct(); Sumsung createSumsungProduct(); &#125; 手机工厂 123456789101112public class Factory_Phone implements Factory &#123; public Apple createAppleProduct() &#123; return new iphone(); &#125; public Sumsung createSumsungProduct() &#123; return new note2(); &#125; &#125; pad工厂 123456789101112public class Factory_Pad implements Factory &#123; public Apple createAppleProduct() &#123; return new ipad(); &#125; public Sumsung createSumsungProduct() &#123; return new Tabs(); &#125; &#125; 客户端调用 1234567891011121314151617public static void Main(string[] args) &#123; //采购商要一台iPad和一台Tab Factory factory = new Factory_Pad(); Apple apple = factory.createAppleProduct(); apple.AppleStyle(); Sumsung sumsung = factory.createSumsungProduct(); sumsung.BangziStyle(); //采购商又要一台iPhone和一台Note2 factory = new Factory_Phone(); apple = factory.createAppleProduct(); apple.AppleStyle(); sumsung = factory.createSumsungProduct(); sumsung.BangziStyle(); Console.ReadKey(); &#125; 抽象工厂可以通过多态，来动态设置不同的工厂，生产不同的产品，同时每个工厂中的产品又不属于同一个产品等级结构。 四、抽象工厂模式优缺点优点①抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用。 ②增加新的具体工厂和产品族很方便，因为一个具体的工厂实现代表的是一个产品族，无须修改已有系统，符合“开闭原则”。 缺点在添加新的产品对象（不同于现有的产品等级结构）时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。 开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦）。 适用环境在以下情况下可以使用抽象工厂模式： ①一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。 ②系统中有多于一个的产品族，而每次只使用其中某一产品族。与工厂方法模式的区别 ③属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。 ④系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、工厂方法模式简介1.定义工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。 在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 2.使用动机现在对该系统（上篇文章提到）进行修改，不再设计一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成。 我们先定义一个抽象的按钮工厂类，再定义具体的工厂类来生成圆形按钮、矩形按钮、菱形按钮等，它们实现在抽象按钮工厂类中定义的方法。这种抽象化的结果使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮创建一个具体的工厂类就可以获得该新按钮的实例，这一特点无疑使得工厂方法模式具有超越简单工厂模式的优越性，更加符合“开闭原则”。 二、工厂方法模式结构1.模式结构 工厂方法模式包含如下角色： ●Product：抽象产品，工厂方法模式所创建的对象的超类，也就是所有产品类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。 ●ConcreteProduct：具体产品，这个角色实现了抽象产品（Product）所声明的接口，工厂方法模式所创建的每一个对象都是某个具体产品的实例。 ●Factory：抽象工厂，担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。 ●ConcreteFactory：具体工厂，担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建具体产品对象。 2.时序图 ①先调用具体工厂对象中的方法createProduct() ②根据传入产品类型参数（也可以无参），获得具体的产品对象 ③返回产品对象并使用 三、工厂方法模式的使用实例 上面的类图中，在灯这个品类下，有灯泡和灯管两种产品，并且都实现了灯的通用方法：关灯和开灯。在工厂类下，有各种生产具体产品的子工厂负责生产相应的两种灯具。 如果还不是太明白，那我们来假设一个情景。小明（客户端）想要买一个灯泡，他不认识工厂，只能去供销店（工厂类）买，于是和老板说“我要一个灯泡”，老板说 “没问题！您稍等”。转身到了后院，对生产灯泡的小弟（灯泡工厂子类）吆喝一声，给我造个灯泡！不一会灯泡造好了，老板拿给小明，“嘿嘿，灯泡给您作了一个，您试试？”，小明把灯泡拧在灯口上，开关了两下（灯的通用方法）“嘿！挺好，没问题！”，付了钱高高兴兴走了。 抽象的产品接口ILight 12345public interface ILight &#123; void TurnOn(); void TurnOff(); &#125; 具体的产品类：BulbLight 1234567891011public class BulbLight implements ILight &#123; public void TurnOn() &#123; Console.WriteLine("BulbLight turns on."); &#125; public void TurnOff() &#123; Console.WriteLine("BulbLight turns off."); &#125; &#125; 具体的产品类：TubeLight 12345678910111213public class TubeLight implements ILight &#123; public void TurnOn() &#123; Console.WriteLine("TubeLight turns on."); &#125; public void TurnOff() &#123; Console.WriteLine("TubeLight turns off."); &#125; &#125; 抽象的工厂类 1234public interface ICreator &#123; ILight CreateLight(); &#125; 具体的工厂类:BulbCreator 12345678public class BulbCreator implements ICreator &#123; public ILight CreateLight() &#123; return new BulbLight(); &#125; &#125; 具体的工厂类:TubeCreator 1234567public class TubeCreator implements ICreator &#123; public ILight CreateLight() &#123; return new TubeLight(); &#125; &#125; 客户端调用 123456789101112131415static void Main(string[] args) &#123; //先给我来个灯泡 ICreator creator = new BulbCreator(); ILight light = creator.CreateLight(); light.TurnOn(); light.TurnOff(); //再来个灯管看看 creator = new TubeCreator(); light = creator.CreateLight(); light.TurnOn(); light.TurnOff(); &#125; 通过一个引用变量ICreator来创建产品对象，创建何种产品对象由指向的具体工厂类决定。通过工厂方法模式，将具体的应用逻辑和产品的创建分离开，促进松耦合。 本例中每个具体工厂类只负责生产一种类型的产品，当然每个具体工厂类也内部可以维护少数几种产品实例对象，类似于简单工厂模式。 四、工厂方法模式的优缺点优点①在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 ②基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。 ③使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”，这点比简单工厂模式更优秀。 缺点①在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 ②由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 适用场景在以下情况下可以使用工厂方法模式： ①一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。 ②一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。 ③将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 五、工厂方法模式在Java中应用JDBC中的工厂方法: 123Connection conn=DriverManager.getConnection("jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=");Statement statement=conn.createStatement();ResultSet rs=statement.executeQuery("select * from UserInfo");]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>工厂方法模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2018%2F06%2F09%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、简单工厂模式简介1.定义简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 2.使用动机考虑一个简单的软件应用场景：一个软件系统可以提供多个外观不同的按钮（如圆形按钮、矩形按钮、菱形按钮等）， 这些按钮都源自同一个基类，不过在继承基类后不同的子类修改了部分属性从而使得它们可以呈现不同的外观。 如果我们希望在使用这些按钮时，不需要知道这些具体按钮类的名字，只需要知道表示该按钮类的一个参数，并提供一个调用方便的方法，把该参数传入方法即可返回一个相应的按钮对象，此时，就可以使用简单工厂模式。 二、简单工厂模式结构1.模式结构 简单工厂模式包含如下角色： ●Factory：工厂角色工厂角色负责实现创建所有实例的内部逻辑 ●Product：抽象产品角色抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口 ●ConcreteProduct：具体产品角色具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。 2.时序图 ①先调用工厂类中的静态方法createProduct() ②根据传入产品类型参数，获得具体的产品对象 ③返回产品对象并使用 三、简单工厂的使用实例以登录功能来说，假如应用系统需要支持多种登录方式如：口令认证、域认证（口令认证通常是去数据库中验证用户，而域认证则是需要到微软的域中验证用户）。那么自然的做法就是建立一个各种登录方式都适用的接口，如下图所示： 抽象产品Login 1234public interface Login &#123; //登录验证 public boolean verify(String name , String password);&#125; 具体产品DomainLogin 1234567891011public class DomainLogin implements Login &#123; @Override public boolean verify(String name, String password) &#123; // TODO Auto-generated method stub /** * 业务逻辑 */ return true; &#125;&#125; 具体产品PasswordLogin 1234567891011public class PasswordLogin implements Login &#123; @Override public boolean verify(String name, String password) &#123; // TODO Auto-generated method stub /** * 业务逻辑 */ return true; &#125;&#125; 工厂类LoginManager根据调用者不同的要求，创建出不同的登录对象并返回。而如果碰到不合法的要求，会返回一个Runtime异常。 123456789101112131415161718public class LoginManager &#123; public static Login factory(String type)&#123; if(type.equals("password"))&#123; return new PasswordLogin(); &#125;else if(type.equals("passcode"))&#123; return new DomainLogin(); &#125;else&#123; /** * 这里抛出一个自定义异常会更恰当 */ throw new RuntimeException("没有找到登录类型"); &#125; &#125;&#125; 测试调用 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; String loginType = "password"; String name = "name"; String password = "password"; Login login = LoginManager.factory(loginType); boolean bool = login.verify(name, password); if (bool) &#123; /** * 业务逻辑 */ &#125; else &#123; /** * 业务逻辑 */ &#125; &#125;&#125; 假如不使用简单工厂模式则验证登录Servlet代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub String loginType = "password"; String name = "name"; String password = "password"; //处理口令认证 if(loginType.equals("password"))&#123; PasswordLogin passwordLogin = new PasswordLogin(); boolean bool = passwordLogin.verify(name, password); if (bool) &#123; /** * 业务逻辑 */ &#125; else &#123; /** * 业务逻辑 */ &#125; &#125; //处理域认证 else if(loginType.equals("passcode"))&#123; DomainLogin domainLogin = new DomainLogin(); boolean bool = domainLogin.verify(name, password); if (bool) &#123; /** * 业务逻辑 */ &#125; else &#123; /** * 业务逻辑 */ &#125; &#125;else&#123; /** * 业务逻辑 */ &#125; &#125;&#125; 可以看到非常麻烦，代码重复很多，而且不利于扩展维护。 四、简单工厂模式优缺点优点：通过使用工厂类，外界不再需要关心如何创造各种具体的产品，只要提供一个产品的名称作为参数传给工厂，就可以直接得到一个想要的产品对象，并且可以按照接口规范来调用产品对象的所有功能（方法）。 构造容易，逻辑简单。 缺点：1.简单工厂模式中的if else判断非常多，完全是Hard Code，如果有一个新产品要加进来，就要同时添加一个新产品类，并且必须修改工厂类，再加入一个 else if 分支才可以， 这样就违背了 “开放-关闭原则”中的对修改关闭的准则了。当系统中的具体产品类不断增多时候，就要不断的修改工厂类，对系统的维护和扩展不利。 2.一个工厂类中集合了所有的类的实例创建逻辑，违反了高内聚的责任分配原则，将全部的创建逻辑都集中到了一个工厂类当中，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。因此一般只在很简单的情况下应用，比如当工厂类负责创建的对象比较少时。 3.简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 适用环境在以下情况下可以使用简单工厂模式： 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。 五、简单工厂模式在Java中的应用①JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。 1234public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style,Localelocale); ②Java加密技术获取不同加密算法的密钥生成器: 1KeyGenerator keyGen=KeyGenerator.getInstance("DESede"); 创建密码器: 1Cipher cp=Cipher.getInstance("DESede");]]></content>
      <categories>
        <category>设计模式</category>
        <category>创建型模式</category>
      </categories>
      <tags>
        <tag>简单工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于http]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8Ehttp%2F</url>
    <content type="text"><![CDATA[一、 HTTP请求和响应步骤 以上完整表示了HTTP请求和响应的7个步骤，下面从TCP/IP协议模型的角度来理解HTTP请求和响应如何传递的。 二、TCP/IP协议TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议，通过20多年的发展已日渐成熟，并被广泛应用于局域网和广域网中，目前已成为事实上的国际标准。TCP/IP协议簇是一组不同层次上的多个协议的组合，通常被认为是一个四层协议系统，与OSI的七层模型相对应。 HTTP协议就是基于TCP/IP协议模型来传输信息的。 (1). 链路层 也称作数据链路层或网络接口层（在第一个图中为网络接口层和硬件层），通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。它们一起处理与电缆（或其他任何传输媒介）的物理接口细节。ARP（地址解析协议）和RARP（逆地址解析协议）是某些网络接口（如以太网和令牌环网）使用的特殊协议，用来转换IP层和网络接口层使用的地址。 (2). 网络层 也称作互联网层（在第一个图中为网际层），处理分组在网络中的活动，例如分组的选路。在TCP/IP协议族中，网络层协议包括IP协议（网际协议），ICMP协议（Internet互联网控制报文协议），以及IGMP协议（Internet组管理协议）。 IP是一种网络层协议，提供的是一种不可靠的服务，它只是尽可能快地把分组从源结点送到目的结点，但是并不提供任何可靠性保证。同时被TCP和UDP使用。TCP和UDP的每组数据都通过端系统和每个中间路由器中的IP层在互联网中进行传输。 ICMP是IP协议的附属协议。IP层用它来与其他主机或路由器交换错误报文和其他重要信息。 IGMP是Internet组管理协议。它用来把一个UDP数据报多播到多个主机。 (3). 传输层 主要为两台主机上的应用程序提供端到端的通信。在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。 TCP为两台主机提供高可靠性的数据通信。它所做的工作包括把应用程序交给它的数据分成合适的小块交给下面的网络层，确认接收到的分组，设置发送最后确认分组的超时时钟等。由于运输层提供了高可靠性的端到端的通信，因此应用层可以忽略所有这些细节。为了提供可靠的服务，TCP采用了超时重传、发送和接收端到端的确认分组等机制。 UDP则为应用层提供一种非常简单的服务。它只是把称作数据报的分组从一台主机发送到另一台主机，但并不保证该数据报能到达另一端。一个数据报是指从发送方传输到接收方的一个信息单元（例如，发送方指定的一定字节数的信息）。UDP协议任何必需的可靠性必须由应用层来提供。(4). 应用层 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。包括 HTTP，FTP（File Transfer Protocol，文件传输协议），DNS（Domain Name System，域名系统）服务。 当应用程序用TCP传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。其中每一层对收到的数据都要增加一些首部信息（有时还要增加尾部信息），该过程如图所示。 当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议盒都要去检查报文首部中的协议标识，以确定接收数据的上层协议。这个过程称作分用（Demultiplexing）。协议是通过目的端口号、源I P地址和源端口号进行解包的。 通过以上步骤我们从TCP/IP模型的角度来理解了一次HTTP请求与响应的过程。 下面这张图更清楚明白： 下面具体来看如何进行一步步操作的。 三、TCP三次握手TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 四、HTTP协议Http是什么？通俗来讲，他就是计算机通过网络进行通信的规则，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据。目前任何终端（手机，笔记本电脑。。）之间进行任何一种通信都必须按照Http协议进行，否则无法连接。 四个基于： 请求与响应：客户端发送请求，服务器端响应数据 无状态的：协议对于事务处理没有记忆能力，客户端第一次与服务器建立连接发送请求时需要进行一系列的安全认证匹配等，因此增加页面等待时间，当客户端向服务器端发送请求，服务器端响应完毕后，两者断开连接，也不保存连接状态，一刀两断！恩断义绝！从此路人！下一次客户端向同样的服务器发送请求时，由于他们之前已经遗忘了彼此，所以需要重新建立连接。 应用层：Http是属于应用层的协议，配合TCP/IP使用。 TCP/IP：Http使用TCP作为它的支撑运输协议。HTTP客户机发起一个与服务器的TCP连接，一旦连接建立，浏览器（客户机）和服务器进程就可以通过套接字接口访问TCP。 针对无状态的一些解决策略： 有时需要对用户之前的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。于是引入了Cookie技术。 HTTP/1.1想出了持久连接（HTTP keep-alive）方法。其特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接。等等还有很多。。。。。。 下面开始讲解重头戏：HTTP请求报文，响应报文，对应于上述步骤的2，3，4，5，6。 HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。 五、HTTP请求报文一个HTTP请求报文由请求行（request line）、请求头部（header）、空行和请求数据4个部分组成，下图给出了请求报文的一般格式。 1.请求行请求行分为三个部分：请求方法、请求地址和协议版本 请求方法 HTTP/1.1 定义的请求方法有8种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。 最常的两种GET和POST，如果是RESTful接口的话一般会用到GET、POST、DELETE、PUT。 请求地址 URL:统一资源定位符，是一种自愿位置的抽象唯一识别方法。 组成：&lt;协议&gt;：//&lt;主机&gt;：&lt;端口&gt;/&lt;路径&gt; 端口和路径有时可以省略（HTTP默认端口号是80） 如下例： 有时会带参数，GET请求 协议版本 协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1 2.请求头部请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。 常见请求头如下： 请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据，这一行非常重要，必不可少。 3.请求数据可选部分，比如GET请求就没有请求数据。 下面是一个POST方法的请求报文： POST /index.php HTTP/1.1 请求行Host: localhostUser-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2 请求头Accept: text/html,application/xhtml+xml,application/xml;q=0.9,/;q=0.8Accept-Language: zh-cn,zh;q=0.5Accept-Encoding: gzip, deflateConnection: keep-aliveReferer:http://localhost/Content-Length：25Content-Type：application/x-www-form-urlencoded 空行username=aa&amp;password=1234 请求数据 六、HTTP响应报文 HTTP响应报文主要由状态行、响应头部、空行以及响应数据组成。 1.状态行由3部分组成，分别为：协议版本，状态码，状态码描述。 其中协议版本与请求报文一致，状态码描述是对状态码的简单描述，所以这里就只介绍状态码。 状态码 状态代码为3位数字。1xx：指示信息–表示请求已接收，继续处理。2xx：成功–表示请求已被成功接收、理解、接受。3xx：重定向–要完成请求必须进行更进一步的操作。4xx：客户端错误–请求有语法错误或请求无法实现。5xx：服务器端错误–服务器未能实现合法的请求。 下面列举几个常见的： 2.响应头部与请求头部类似，为响应报文添加了一些附加信息 常见响应头部如下： 3.响应数据用于存放需要返回给客户端的数据信息。 下面是一个响应报文的实例： HTTP/1.1 200 OK 状态行Date: Sun, 17 Mar 2013 08:12:54 GMT 响应头部Server: Apache/2.2.8 (Win32) PHP/5.2.5X-Powered-By: PHP/5.2.5Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheContent-Length: 4393Keep-Alive: timeout=5, max=100Connection: Keep-AliveContent-Type: text/html; charset=utf-8 空行 &lt;html&gt; 响应数据&lt;head&gt;&lt;title&gt;HTTP响应示例&lt;title&gt;&lt;/head&gt;&lt;body&gt;Hello HTTP!&lt;/body&gt;&lt;/html&gt; 关于请求头部和响应头部的知识点很多，这里只是简单介绍。 通过以上步骤，数据已经传递完毕，HTTP/1.1会维持持久连接，但持续一段时间总会有关闭连接的时候，这时候据需要断开TCP连接。 七、TCP四次挥手当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 通过以上步骤便完成了HTTP的请求和响应，进行了数据传递，这其中涉及到需要知识点，都进行了逐一了解。 GET和POST的区别 GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456. POST方法是把提交的数据放在HTTP包的Body中. GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制. GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。 GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码. COOKIE和SESSION有什么区别？ 由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.典型的场景比如购物车，当你点击下单按钮时，由于HTTP协议无状态，所以并不知道是哪个用户操作的，所以服务端要为特定的用户创建了特定的Session，用用于标识这个用户，并且跟踪用户，这样才知道购物车里面有几本书。这个Session是保存在服务端的，有一个唯一标识。在服务端保存Session的方法很多，内存、数据库、文件都有。集群的时候也要考虑Session的转移，在大型的网站，一般会有专门的Session服务器集群，用来保存用户会话，这个时候 Session 信息都是放在内存的，使用一些缓存服务比如Memcached之类的来放 Session。2. 思考一下服务端如何识别特定的客户？这个时候Cookie就登场了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。有人问，如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。3. Cookie其实还可以用在一些方便用户的场景下，设想你某次登陆过一个网站，下次登录的时候不想再次输入账号了，怎么办？这个信息可以写到Cookie里面，访问网站的时候，网站页面的脚本可以读取这个信息，就自动帮你把用户名给填了，能够方便一下用户。这也是Cookie名称的由来，给用户的一点甜头。所以总结一下： Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中； Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于https]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8Ehttps%2F</url>
    <content type="text"><![CDATA[我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取。所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。 HTTPS简介HTTPS其实是有两部分组成：HTTP + SSL / TLS，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。具体是如何进行加密，解密，验证的，且看下图。 1. 客户端发起HTTPS请求这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。 2. 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。 3. 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 4. 客户端解析证书这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。 5. 传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 6. 服务段加密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 7. 传输加密后的信息这部分信息是服务段用私钥加密后的信息，可以在客户端被还原 8. 客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TCP/IP]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8ETCP-IP%2F</url>
    <content type="text"><![CDATA[一、TCP/IP模型TCP/IP协议模型（Transmission Control Protocol/Internet Protocol），包含了一系列构成互联网基础的网络协议，是Internet的核心协议。 基于TCP/IP的参考模型将协议分成四个层次，它们分别是链路层、网络层、传输层和应用层。下图表示TCP/IP模型与OSI模型各层的对照关系。 TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。 上图清楚地表示了TCP/IP协议中每个层的作用，而TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。 上图以HTTP协议为例，具体说明。 二、数据链路层物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。 封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。 透明传输:零比特填充、转义字符。 可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。 差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。 三、网络层1.IP协议IP协议是TCP/IP协议的核心，所有的TCP，UDP，ICMP，IGCP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。 1.1 IP地址在数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。 32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。 A类IP地址: 1.0.0.0~127.0.0.0B类IP地址:128.0.0.0~191.255.255.255C类IP地址:192.0.0.0~223.255.255.255 1.2 IP协议头 这里只介绍:八位的TTL字段。这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。 2.ARP及RARP协议ARP 是根据IP地址获取MAC地址的一种协议。 ARP（地址解析）协议是一种解析协议，本来主机是完全不知道这个IP对应的是哪个主机的哪个接口，当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个IP-MAC地址对应表缓存）。 如果查询的IP－MAC值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的MAC地址的ARP包传送给发送ARP广播的主机。 而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。 RARP协议的工作与此相反，不做赘述。 3. ICMP协议IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。其中一个重要的模块就是ICMP(网络控制报文)协议。ICMP不是高层协议，而是IP层的协议。 当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。给主机一个处理错误的机会，这 也就是为什么说建立在IP层以上的协议是可能做到安全的原因。 四、pingping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。 例如：当我们某一个网站上不去的时候。通常会ping一下这个网站。ping会回显出一些有用的信息。一般的信息如下: ping这个单词源自声纳定位，而这个程序的作用也确实如此，它利用ICMP协议包来侦测另一个主机是否可达。原理是用类型码为0的ICMP发请 求，受到请求的主机则用类型码为8的ICMP回应。 ping程序来计算间隔时间，并计算有多少个包被送达。用户就可以判断网络大致的情况。我们可以看到， ping给出来了传送的时间和TTL的数据。 五、TracerouteTraceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。 Traceroute的原理是非常非常的有意思，它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。如此往复直到到达目的主机。这样，traceroute就拿到了所有的路由器IP。 六、TCP/UDPTCP/UDP都是是传输层协议，但是两者具有不同的特性，同时也具有不同的应用场景，下面以图表的形式对比分析。 面向报文面向报文的传输方式是应用层交给UDP多长的报文，UDP就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则IP层需要分片，降低效率。若太短，会是IP太小。 面向字节流面向字节流的话，虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序看成是一连串的无结构的字节流。TCP有一个缓冲，当应用程序传送的数据块太长，TCP就可以把它划分短一些再传送。 关于拥塞控制，流量控制，是TCP的重点，后面讲解。 TCP和UDP协议的一些应用 什么时候应该使用TCP？当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。 什么时候应该使用UDP？当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用UDP。 七、DNSDNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。 八、TCP连接的建立与终止1.三次握手TCP是面向连接的，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中，TCP协议提供可靠的连接服务，连接是通过三次握手进行初始化的。三次握手的目的是同步连接双方的序列号和确认号并交换 TCP窗口大小信息。 第一次握手: 建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手: 服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手: 客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 为什么要三次握手？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 具体例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。” 2.四次挥手当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。 第一次分手: 主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了； 第二次分手: 主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求； 第三次分手: 主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态； 第四次分手 主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 为什么要四次分手？TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 为什么要等待2MSL？MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。原因有二： 保证TCP协议的全双工连接能够可靠关闭 保证这次连接的重复数据段从网络中消失 第一点：如果主机1直接CLOSED了，那么由于IP协议的不可靠性或者是其它网络原因，导致主机2没有收到主机1最后回复的ACK。那么主机2就会在超时之后继续发送FIN，此时由于主机1已经CLOSED了，就找不到与重发的FIN对应的连接。所以，主机1不是直接进入CLOSED，而是要保持TIME_WAIT，当再次收到FIN的时候，能够保证对方收到ACK，最后正确的关闭连接。 第二点：如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。 九、TCP流量控制如果发送方把数据发送得过快，接收方可能会来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。 利用滑动窗口机制可以很方便地在TCP连接上实现对发送方的流量控制。 设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。 从图中可以看出，B进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。B向A发送的三个报文段都设置了 ACK = 1 ，只有在ACK=1时确认号字段才有意义。 TCP为每一个连接设有一个持续计时器(persistence timer)。只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），那么收到这个报文段的一方就重新设置持续计时器。 十、TCP拥塞控制1.慢开始和拥塞避免发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口。 发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。 慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。 通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。 每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 一个传输轮次所经历的时间其实就是往返时间RTT。 不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。 另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。 为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。慢开始门限ssthresh的用法如下： 当 cwnd&lt; ssthresh 时，使用上述的慢开始算法。 当 cwnd&gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。 拥塞避免让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。 无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送 方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。 这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。 如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。 2.快重传和快恢复快重传快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。 显然，接收方不能确认M4，因为M4是收到的失序报文段。根据 可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。 但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让 发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了 接收方的四个对M2的确认，其中后三个都是重复确认。 快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必 继续等待M3设置的重传计时器到期。 由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。 快恢复与快重传配合使用的还有快恢复算法，其过程有以下两个要点： 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。 与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为 慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IPC机制（图）]]></title>
    <url>%2F2018%2F06%2F09%2FIPC%E6%9C%BA%E5%88%B6%EF%BC%88%E5%9B%BE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[海量数据处理]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、海量数据处理所谓海量数据处理，无非就是基于海量数据上的存储、处理、操作。何谓海量，就是数据量太大，所以导致要么是无法在较短时间内迅速解决，要么是数据太大，导致无法一次性装入内存。 那解决办法呢?针对时间，我们可以采用巧妙的算法搭配合适的数据结构，如Bloom filter/Hash/bit-map/堆/trie树。 针对空间，无非就一个办法：大而化小，分而治之（hash映射）。 二、算法/数据结构基础1.Bloom FilterBloom Filter（BF）是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。它是一个判断元素是否存在集合的快速的概率算法。Bloom Filter有可能会出现错误判断，但不会漏掉判断。也就是Bloom Filter判断元素不再集合，那肯定不在。如果判断元素存在集合中，有一定的概率判断错误。因此，Bloom Filter不适合那些“零错误”的应用场合。 而在能容忍低错误率的应用场合下，Bloom Filter比其他常见的算法（如hash，折半查找）极大节省了空间。 适用范围可以用来实现数据字典，进行数据的判重，或者集合求交集 具体参考：海量数据处理之Bloom Filter详解 2.HashHash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射， pre-image），通过散列算法，变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。 具体参考：从头到尾解析Hash表算法 3. Bit-map所谓的Bit-map就是用一个bit位来标记某个元素对应的值。由于采用了Bit为单位来存储数据，因此在存储空间方面，可以大大节省。 如果说了这么多还没明白什么是Bit-map，那么我们来看一个具体的例子，假设我们要对0-7内的5个元素(4,7,2,5,3)排序（这里假设这些元素没有重复）。那么我们就可以采用Bit-map的方法来达到排序的目的。要表示8个数，我们就只需要8个Bit（1Bytes），首先我们开辟1Byte的空间，将这些空间的所有Bit位都置为0(如下图：) 然后遍历这5个元素，首先第一个元素是4，那么就把4对应的位置为1（可以这样操作 p+(i/8)|(0x01&lt;&lt;(i%8)) 当然了这里的操作涉及到Big-ending和Little-ending的情况，这里默认为Big-ending）,因为是从零开始的，所以要把第五位置为一（如下图）： 然后再处理第二个元素7，将第八位置为1,，接着再处理第三个元素，一直到最后处理完所有的元素，将相应的位置为1，这时候的内存的Bit位的状态如下： 具体参考：数据结构：位图法 4.堆堆是一种特殊的二叉树，具备以下两种性质 1）每个节点的值都大于（或者都小于，称为最小堆）其子节点的值 2）树是完全平衡的，并且最后一层的树叶都在最左边这样就定义了一个最大堆。 如下图用一个数组来表示堆： 5.trie树下面我们有and,as,at,cn,com这些关键词，那么如何构建trie树呢？ 从上面的图中，我们或多或少的可以发现一些好玩的特性。 第一：根节点不包含字符，除根节点外的每一个子节点都包含一个字符。 第二：从根节点到某一节点，路径上经过的字符连接起来，就是该节点对应的字符串。 第三：每个单词的公共前缀作为一个字符节点保存。 适用范围： 前缀统计，词频统计。 具体参考：6天通吃树结构—— 第五天 Trie树 6.外排序适用范围： 大数据的排序，去重 基本原理及要点： 外部排序的两个独立阶段： 1）首先按内存大小，将外存上含n个记录的文件分成若干长度L的子文件或段。依次读入内存并利用有效的内部排序对他们进行排序，并将排序后得到的有序字文件重新写入外存，通常称这些子文件为归并段。 2）对这些归并段进行逐趟归并，使归并段逐渐由小到大，直至得到整个有序文件为之。 外排序的优化方法：置换选择 败者树原理，最优归并树 具体参考：选择置换+败者树搞定外部排序 三、面试问题解决①、海量日志数据，提取出某日访问百度次数最多的那个IP。算法思想：分而治之+Hash 1.IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理； 2.可以考虑采用“分而治之”的思想，按照IP地址的Hash(IP)%1024值，把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4MB个IP地址； 3.对于每一个小文件，可以构建一个IP为key，出现次数为value的Hash map，同时记录当前出现次数最多的那个IP地址； 4.可以得到1024个小文件中的出现次数最多的IP，再依据常规的排序算法得到总体上出现次数最多的IP； ②、 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录（这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门。），请你统计最热门的10个查询串，要求使用的内存不能超过1G。可以在内存中处理，典型的Top K算法 算法思想：hashmap+堆 1.先对这批海量数据预处理，在O（N）的时间内用Hash表完成统计； 2.借助堆这个数据结构，找出Top K，时间复杂度为O(N*logK)。 或者：采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。 ③、有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。算法思想：分而治之 + hash统计 + 堆排序 1.顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件（记为x0,x1,…x4999）中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。 2.对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。 3.取出出现频率最大的100个词（可以用含100个结点的最小堆）后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并（类似于归并排序）的过程了。 ④、有10个文件，每个文件1G，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求你按照query的频度排序。#### 方案1： 算法思想：分而治之 + hash统计 + 堆排序 顺序读取10个文件，按照hash(query)%10的结果将query写入到另外10个文件中。这样新生成的文件每个的大小大约也1G，大于1G继续按照上述思路分。 找一台内存在2G左右的机器，依次对用hash_map(query, query_count)来统计每个query出现的次数。利用快速/堆/归并排序按照出现次数进行排序。将排序好的query和对应的query_cout输出到文件中。这样得到了10个排好序的文件（记为）。 对这10个文件进行归并排序（内排序与外排序相结合）。 方案2： 算法思想：hashmap+堆 一般query的总量是有限的，只是重复的次数比较多而已，可能对于所有的query，一次性就可以加入到内存了。这样，我们就可以采用trie树/hash_map等直接来统计每个query出现的次数，然后按出现次数做快速/堆/归并排序就可以了。 ⑤、 给定a、b两个文件，各存放50亿个url，每个url各占64字节，内存限制是4G，让你找出a、b文件共同的url方案1：可以估计每个文件安的大小为5G×64=320G，远远大于内存限制的4G。所以不可能将其完全加载到内存中处理。考虑采取分而治之的方法。 算法思想：分而治之 + hash统计 遍历文件a，对每个url求取hash(url)%1000，然后根据所取得的值将url分别存储到1000个小文件（记为a0,a1,…,a999）中。这样每个小文件的大约为300M。 遍历文件b，采取和a相同的方式将url分别存储到1000小文件（记为b0,b1,…,b999）。这样处理后，所有可能相同的url都在对应的小文件（a0vsb0,a1vsb1,…,a999vsb999）中，不对应的小文件不可能有相同的url。然后我们只要求出1000对小文件中相同的url即可。 求每对小文件中相同的url时，可以把其中一个小文件的url存储到hash_set中。然后遍历另一个小文件的每个url，看其是否在刚才构建的hash_set中，如果是，那么就是共同的url，存到文件里面就可以了。 方案2：如果允许有一定的错误率，可以使用Bloom filter，4G内存大概可以表示340亿bit。将其中一个文件中的url使用Bloom filter映射为这340亿bit，然后挨个读取另外一个文件的url，检查是否与Bloom filter，如果是，那么该url应该是共同的url（注意会有一定的错误率）。 ⑥、在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数。采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存2^32 * 2 bit=1 GB内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。 ⑦、给40亿个不重复的unsigned int的整数，没排过序的，然后再给一个数，如何快速判断这个数是否在那40亿个数当中？方案1：申请512M的内存，一个bit位代表一个unsigned int值。读入40亿个数，设置相应的bit位，读入要查询的数，查看相应bit位是否为1，为1表示存在，为0表示不存在。 方案2：因为2^32为40亿多，所以给定一个数可能在，也可能不在其中； 这里我们把40亿个数中的每一个用32位的二进制来表示 假设这40亿个数开始放在一个文件中。 然后将这40亿个数分成两类: 1.最高位为0 2.最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=20亿，而另一个&gt;=20亿（这相当于折半了）； 与要查找的数的最高位比较并接着进入相应的文件再查找 再然后把这个文件为又分成两类: 1.次最高位为0 2.次最高位为1 并将这两类分别写入到两个文件中，其中一个文件中数的个数&lt;=10亿，而另一个&gt;=10亿（这相当于折半了）； 与要查找的数的次最高位比较并接着进入相应的文件再查找。 ……. 以此类推，就可以找到了。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>海量数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序基本思想:比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 Java实现 加入标记状态 flag 若在一次冒泡中，没有交换 则说明可以停止 减少运行时 1234567891011121314151617public static void bubbleSort(int[] numbers) &#123; int temp = 0; int size = numbers.length; boolean flag = true; for (int i = 0; i &lt; size - 1&amp;&amp;flag; i++) &#123; flag = false; for (int j = 0; j &lt; size - 1 - i; j++) &#123; if (numbers[j] &gt; numbers[j + 1]) // 交换两数位置 &#123; temp = numbers[j]; numbers[j] = numbers[j + 1]; numbers[j + 1] = temp; flag = true; &#125; &#125; &#125;&#125; 时间复杂度O(n*n) 选择排序算法基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 Java 实现 1234567891011121314151617public static void selectSort(int[] numbers) &#123; int size = numbers.length; // 数组长度 int temp = 0; // 中间变量 for (int i = 0; i &lt; size-1; i++) &#123; int k = i; // 待确定的位置 // 选择出应该在第i个位置的数 for (int j = size - 1; j &gt; i; j--) &#123; if (numbers[j] &lt; numbers[k]) &#123; k = j; &#125; &#125; // 交换两个数 temp = numbers[i]; numbers[i] = numbers[k]; numbers[k] = temp; &#125;&#125; 时间复杂度O(n*n) 性能上优于冒泡排序 交换次数少 插入排序算法基本思想：每步将一个待排序的记录，按其顺序码大小插入到前面已经排序的字序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。 Java 实现 12345678910111213public static void insertSort(int[] numbers) &#123; int size = numbers.length; int temp = 0; int j = 0; for (int i = 1; i &lt; size; i++) &#123; temp = numbers[i]; // 假如temp比前面的值小，则将前面的值后移 for (j = i; j &gt; 0 &amp;&amp; temp &lt; numbers[j - 1]; j--) &#123; numbers[j] = numbers[j - 1]; &#125; numbers[j] = temp; &#125;&#125; 时间复杂度 O(n*n) 性能上优于冒泡排序和选择排序 希尔排序算法基本思想：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 Java 实现 1234567891011121314151617181920212223242526/** * 希尔排序的原理:根据需求，如果你想要结果从小到大排列，它会首先将数组进行分组，然后将较小值移到前面，较大值 * 移到后面，最后将整个数组进行插入排序，这样比起一开始就用插入排序减少了数据交换和移动的次数， * 可以说希尔排序是加强 版的插入排序 拿数组5, 2,8, 9, 1, 3，4来说，数组长度为7，当increment为3时，数组分为两个序列 * 5，2，8和9，1，3，4，第一次排序，9和5比较，1和2比较，3和8比较，4和比其下标值小increment的数组值相比较 * 此例子是按照从小到大排列，所以小的会排在前面，第一次排序后数组为5, 1, 3, 4, 2, 8，9 * 第一次后increment的值变为3/2=1,此时对数组进行插入排序， 实现数组从大到小排 */public static void shellSort(int[] data) &#123; int j = 0; int temp = 0; // 每次将步长缩短为原来的一半 for (int increment = data.length / 2; increment &gt; 0; increment /= 2) &#123; for (int i = increment; i &lt; data.length; i++) &#123; temp = data[i]; for (j = i; j &gt;= increment; j -= increment) &#123; if (temp &lt; data[j - increment])// 从小到大排 &#123; data[j] = data[j - increment]; &#125; else &#123; break; &#125; &#125; data[j] = temp; &#125; &#125; 时间复杂度O(n^1.5） 堆排序算法基本思想:堆排序是一种树形选择排序，是对直接选择排序的有效改进。 堆的定义下：具有n个元素的序列 （h1,h2,…,hn),当且仅当满足（hi&gt;=h2i,hi&gt;=h2i+1）或（hi&lt;=h2i,hi&lt;=h2i+1） (i=1,2,…,n/2)时称之为堆。在这里只讨论满足前者条件的堆。由堆的定义可以看出，堆顶元素（即第一个元素）必为最大项（大顶堆）。完全二叉树可以很直观地表示堆的结构。堆顶为根，其它为左子树、右子树。 思想:初始时把要排序的数的序列看作是一棵顺序存储的二叉树，调整它们的存储序，使之成为一个 堆，这时堆的根节点的数最大。然后将根节点与堆的最后一个节点交换。然后对前面(n-1)个数重新调整使之成为堆。依此类推，直到只有两个节点的堆，并对 它们作交换，最后得到有n个节点的有序序列。从算法描述来看，堆排序需要两个过程，一是建立堆，二是堆顶与堆的最后一个元素交换位置。所以堆排序有两个函数组成。一是建堆的渗透函数，二是反复调用渗透函数实现排序的函数。 Java 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public static void heapSort(int[] a)&#123; int arrayLength = a.length; // 循环建堆 for (int i = 0; i &lt; arrayLength - 1; i++) &#123; // 建堆 buildMaxHeap(a, arrayLength - 1 - i); // 交换堆顶和最后一个元素 swap(a, 0, arrayLength - 1 - i); System.out.println(Arrays.toString(a)); &#125;&#125;// 对data数组从0到lastIndex建大顶堆public static void buildMaxHeap(int[] data, int lastIndex) &#123; // 从lastIndex处节点（最后一个节点）的父节点开始 for (int i = (lastIndex - 1) / 2; i &gt;= 0; i--) &#123; // k保存正在判断的节点 int k = i; // 如果当前k节点的子节点存在 while (k * 2 + 1 &lt;= lastIndex) &#123; // k节点的左子节点的索引 int biggerIndex = 2 * k + 1; // 如果biggerIndex小于lastIndex，即biggerIndex+1代表的k节点的右子节点存在 if (biggerIndex &lt; lastIndex) &#123; // 若果右子节点的值较大 if (data[biggerIndex] &lt; data[biggerIndex + 1]) &#123; // biggerIndex总是记录较大子节点的索引 biggerIndex++; &#125; &#125; // 如果k节点的值小于其较大的子节点的值 if (data[k] &lt; data[biggerIndex]) &#123; // 交换他们 swap(data, k, biggerIndex); // 将biggerIndex赋予k，开始while循环的下一次循环，重新保证k节点的值大于其左右子节点的值 k = biggerIndex; &#125; else &#123; break; &#125; &#125; &#125;&#125;// 交换private static void swap(int[] data, int i, int j) &#123; int tmp = data[i]; data[i] = data[j]; data[j] = tmp;&#125; 时间复杂度O(nlogn）不适合待排序序列较少的情况 快速排序算法基本思想：通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分关键字小，则分别对这两部分继续进行排序，直到整个序列有序。 Java 实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 快速排序 * * @param numbers * 带排序数组 */public static void quick(int[] numbers) &#123; if (numbers.length &gt; 0) // 查看数组是否为空 &#123; quickSort(numbers, 0, numbers.length - 1); &#125;&#125;/** * * @param numbers * 带排序数组 * @param low * 开始位置 * @param high * 结束位置 */public static void quickSort(int[] numbers, int low, int high) &#123; if (low &gt;= high) &#123; return; &#125; int middle = getMiddle(numbers, low, high); // 将numbers数组进行一分为二 quickSort(numbers, low, middle - 1); // 对低字段表进行递归排序 quickSort(numbers, middle + 1, high); // 对高字段表进行递归排序&#125;/** * 查找出中轴（默认是最低位low）的在numbers数组排序后所在位置 * * @param numbers * 带查找数组 * @param low * 开始位置 * @param high * 结束位置 * @return 中轴所在位置 */public static int getMiddle(int[] numbers, int low, int high) &#123; int temp = numbers[low]; // 数组的第一个作为中轴 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; numbers[high] &gt; temp) &#123; high--; &#125; numbers[low] = numbers[high];// 比中轴小的记录移到低端 while (low &lt; high &amp;&amp; numbers[low] &lt; temp) &#123; low++; &#125; numbers[high] = numbers[low]; // 比中轴大的记录移到高端 &#125; numbers[low] = temp; // 中轴记录到尾 return low; // 返回中轴的位置&#125; 时间复杂度O(nlogn） 快速排序在序列中元素很少时，效率将比较低，不如插入排序，因此一般在序列中元素很少时使用插入排序，这样可以提高整体效率。 归并排序算法基本思想:归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。 Java 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 归并排序 * 简介:将两个（或两个以上）有序表合并成一个新的有序表 即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列 * 时间复杂度为O(nlogn) * 稳定排序方式 * @param nums 待排序数组 * @return 输出有序数组 */public static int[] sort(int[] nums, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; // 左边 sort(nums, low, mid); // 右边 sort(nums, mid + 1, high); // 左右归并 merge(nums, low, mid, high); &#125; return nums;&#125;/** * 将数组中low到high位置的数进行排序 * @param nums 待排序数组 * @param low 待排的开始位置 * @param mid 待排中间位置 * @param high 待排结束位置 */public static void merge(int[] nums, int low, int mid, int high) &#123; int[] temp = new int[high - low + 1]; int i = low;// 左指针 int j = mid + 1;// 右指针 int k = 0; // 把较小的数先移到新数组中 while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (nums[i] &lt; nums[j]) &#123; temp[k++] = nums[i++]; &#125; else &#123; temp[k++] = nums[j++]; &#125; &#125; // 把左边剩余的数移入数组 while (i &lt;= mid) &#123; temp[k++] = nums[i++]; &#125; // 把右边边剩余的数移入数组 while (j &lt;= high) &#123; temp[k++] = nums[j++]; &#125; // 把新数组中的数覆盖nums数组 for (int k2 = 0; k2 &lt; temp.length; k2++) &#123; nums[k2 + low] = temp[k2]; &#125;&#125; 时间复杂度O(nlogn） 各种算法的时间复杂度等性能比较]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[散列查找]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[一、什么是哈希表哈希表就是一种以 键-值(key-indexed) 存储数据的结构，我们只要输入待查找的值即key，即可查找到其对应的值。 哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。 使用哈希查找有两个步骤: 使用哈希函数将被查找的键转换为数组的索引。在理想的情况下，不同的键会被转换为不同的索引值，但是在有些情况下我们需要处理多个键被哈希到同一个索引值的情况。所以哈希查找的第二个步骤就是处理冲突 处理哈希碰撞冲突。有很多处理哈希碰撞冲突的方法，本文后面会介绍拉链法和线性探测法。 哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。 二、哈希函数哈希查找第一步就是使用哈希函数将键映射成索引。这种映射函数就是哈希函数。如果我们有一个保存0-M数组，那么我们就需要一个能够将任意键转换为该数组范围内的索引（0~M-1）的哈希函数。哈希函数需要易于计算并且能够均匀分布所有键。比如举个简单的例子，使用手机号码后三位就比前三位作为key更好，因为前三位手机号码的重复率很高。再比如使用身份证号码出生年月位数要比使用前几位数要更好。 在实际中，我们的键并不都是数字，有可能是字符串，还有可能是几个值的组合等，所以我们需要实现自己的哈希函数。 1. 正整数获取正整数哈希值最常用的方法是使用除留余数法。即对于大小为素数M的数组，对于任意正整数k，计算k除以M的余数。M一般取素数。 2. 字符串将字符串作为键的时候，我们也可以将他作为一个大的整数，采用保留除余法。我们可以将组成字符串的每一个字符取值然后进行哈希，比如 12345678910public int GetHashCode(string str)&#123; char[] s = str.ToCharArray(); int hash = 0; for (int i = 0; i &lt; s.Length; i++) &#123; hash = s[i] + (31 * hash); &#125; return hash;&#125; 上面的哈希值是Horner计算字符串哈希值的方法，公式为: 举个例子，比如要获取”call”的哈希值，字符串c对应的unicode为99，a对应的unicode为97，L对应的unicode为108，所以字符串”call”的哈希值为 如果对每个字符去哈希值可能会比较耗时，所以可以通过间隔取N个字符来获取哈希值来节省时间，比如，可以 获取每8-9个字符来获取哈希值： 1234567891011public int GetHashCode(string str)&#123; char[] s = str.ToCharArray(); int hash = 0; int skip = Math.Max(1, s.Length / 8); for (int i = 0; i &lt; s.Length; i+=skip) &#123; hash = s[i] + (31 * hash); &#125; return hash;&#125; 但是，对于某些情况，不同的字符串会产生相同的哈希值，这就是前面说到的哈希冲突（Hash Collisions），比如下面的四个字符串： 如果我们按照每8个字符取哈希的话，就会得到一样的哈希值。所以下面来讲解如何解决哈希碰撞： 三、避免哈希冲突拉链法通过哈希函数，我们可以将键转换为数组的索引(0-M-1)，但是对于两个或者多个键具有相同索引值的情况，我们需要有一种方法来处理这种冲突。 一种比较直接的办法就是，将大小为M 的数组的每一个元素指向一个条链表，链表中的每一个节点都存储散列值为该索引的键值对，这就是拉链法。下图很清楚的描述了什么是拉链法。 图中，”John Smith”和”Sandra Dee” 通过哈希函数都指向了152 这个索引，该索引又指向了一个链表， 在链表中依次存储了这两个字符串。 该方法的基本思想就是选择足够大的M，使得所有的链表都尽可能的短小，以保证查找的效率。对采用拉链法的哈希实现的查找分为两步，首先是根据散列值找到对应的链表，然后沿着链表顺序找到相应的键。 实现基于拉链表的散列表，目标是选择适当的数组大小M，使得既不会因为空链表而浪费内存空间，也不会因为链表太而在查找上浪费太多时间。拉链表的优点在于，这种数组大小M的选择不是关键性的，如果存入的键多于预期，那么查找的时间只会比选择更大的数组稍长，另外，我们也可以使用更高效的结构来代替链表存储。如果存入的键少于预期，索然有些浪费空间，但是查找速度就会很快。所以当内存不紧张时，我们可以选择足够大的M，可以使得查找时间变为常数，如果内存紧张时，选择尽量大的M仍能够将性能提高M倍。 线性探测法线性探测法是开放寻址法解决哈希冲突的一种方法，基本原理为，使用大小为M的数组来保存N个键值对，其中M&gt;N，我们需要使用数组中的空位解决碰撞冲突。如下图所示： 对照前面的拉链法，在该图中，”Ted Baker” 是有唯一的哈希值153的，但是由于153被”Sandra Dee”占用了。而原先”Snadra Dee”和”John Smith”的哈希值都是152的，但是在对”Sandra Dee”进行哈希的时候发现152已经被占用了，所以往下找发现153没有被占用，所以存放在153上，然后”Ted Baker”哈希到153上，发现已经被占用了，所以往下找，发现154没有被占用，所以值存到了154上。 开放寻址法中最简单的是线性探测法：当碰撞发生时即一个键的散列值被另外一个键占用时，直接检查散列表中的下一个位置即将索引值加1，这样的线性探测会出现三种结果： 命中，该位置的键和被查找的键相同 未命中，键为空 继续查找，该位置的键和被查找的键不同。 线性探查（Linear Probing）方式虽然简单，但是有一些问题，它会导致同类哈希的聚集。在存入的时候存在冲突，在查找的时候冲突依然存在。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>散列查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Floyd算法]]></title>
    <url>%2F2018%2F06%2F09%2FFloyd%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、弗洛伊德算法介绍和Dijkstra算法一样，弗洛伊德(Floyd)算法也是一种用于寻找给定的加权图中顶点间最短路径的算法。该算法名称以创始人之一、1978年图灵奖获得者、斯坦福大学计算机科学系教授罗伯特·弗洛伊德命名。 基本思想 ​ 通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入一个矩阵S，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。 ​ 假设图G中顶点个数为N，则需要对矩阵S进行N次更新。初始时，矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。 接下来开始，对矩阵S进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]“(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]“。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k]+a[k][j]“，则更新a[i][j]为”a[i][k]+a[k][j]“。更新N次之后，操作完成！ ​ 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 二、弗洛伊德算法图解 以上图G4为例，来对弗洛伊德进行算法演示。 初始状态：S是记录各个顶点间最短路径的矩阵。 第1步：初始化S。 ​ 矩阵S中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞。实际上，就是将图的原始矩阵复制到S中。 ​ 注:a[i][j]表示矩阵S中顶点i(第i个顶点)到顶点j(第j个顶点)的距离。 第2步：以顶点A(第1个顶点)为中介点，若a[i][j] &gt; a[i][0]+a[0][j]，则设置a[i][j]=a[i][0]+a[0][j]。​ 以顶点a[1][6]，上一步操作之后，a[1][6]=∞；而将A作为中介点时，(B,A)=12，(A,G)=14，因此B和G之间的距离可以更新为16。 同理，依次将顶点B,C,D,E,F,G作为中介点，并更新a[i][j]的大小。 三、弗洛伊德算法的代码说明以”邻接矩阵”为例对弗洛伊德算法进行说明，对于”邻接表”实现的图在后面会给出相应的源码。 1. 基本定义 123456789public class MatrixUDG &#123; private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ...&#125; MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 弗洛伊德算法 12345678910111213141516171819202122232425262728293031323334353637383940414243/* * floyd最短路径。 * 即，统计图中各个顶点间的最短路径。 * * 参数说明： * path -- 路径。path[i][j]=k表示，"顶点i"到"顶点j"的最短路径会经过顶点k。 * dist -- 长度数组。即，dist[i][j]=sum表示，"顶点i"到"顶点j"的最短路径的长度是sum。 */public void floyd(int[][] path, int[][] dist) &#123; // 初始化 for (int i = 0; i &lt; mVexs.length; i++) &#123; for (int j = 0; j &lt; mVexs.length; j++) &#123; dist[i][j] = mMatrix[i][j]; // "顶点i"到"顶点j"的路径长度为"i到j的权值"。 path[i][j] = j; // "顶点i"到"顶点j"的最短路径是经过顶点j。 &#125; &#125; // 计算最短路径 for (int k = 0; k &lt; mVexs.length; k++) &#123; for (int i = 0; i &lt; mVexs.length; i++) &#123; for (int j = 0; j &lt; mVexs.length; j++) &#123; // 如果经过下标为k顶点路径比原两点间路径更短，则更新dist[i][j]和path[i][j] int tmp = (dist[i][k]==INF || dist[k][j]==INF) ? INF : (dist[i][k] + dist[k][j]); if (dist[i][j] &gt; tmp) &#123; // "i到j最短路径"对应的值设，为更小的一个(即经过k) dist[i][j] = tmp; // "i到j最短路径"对应的路径，经过k path[i][j] = path[i][k]; &#125; &#125; &#125; &#125; // 打印floyd最短路径的结果 System.out.printf("floyd: \n"); for (int i = 0; i &lt; mVexs.length; i++) &#123; for (int j = 0; j &lt; mVexs.length; j++) System.out.printf("%2d ", dist[i][j]); System.out.printf("\n"); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra算法]]></title>
    <url>%2F2018%2F06%2F09%2FDijkstra%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、迪杰斯特拉算法介绍迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。 基本思想 ​ 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。 ​ 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 ​ 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。 操作步骤 (1) 初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。 (2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。 (3) 更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。 (4) 重复步骤(2)和(3)，直到遍历完所有顶点。 单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。 二、迪杰斯特拉算法图解 以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。 初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！ 第1步：将顶点D加入到S中。 ​ 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。 注:C(3)表示C到起点D的距离是3。 第2步：将顶点C加入到S中。 ​ 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。 ​ 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。 第3步：将顶点E加入到S中。 ​ 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。 ​ 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。 第4步：将顶点F加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。 第5步：将顶点G加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。 第6步：将顶点B加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。 第7步：将顶点A加入到S中。 ​ 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。 此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。 三、迪杰斯特拉算法的代码说明以”邻接矩阵”为例对迪杰斯特拉算法进行说明。 1. 基本定义 123456789public class MatrixUDG &#123; private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ...&#125; MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 迪杰斯特拉算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * Dijkstra最短路径。 * 即，统计图中"顶点vs"到其它各个顶点的最短路径。 * * 参数说明： * vs -- 起始顶点(start vertex)。即计算"顶点vs"到其它顶点的最短路径。 * prev -- 前驱顶点数组。即，prev[i]的值是"顶点vs"到"顶点i"的最短路径所经历的全部顶点中，位于"顶点i"之前的那个顶点。 * dist -- 长度数组。即，dist[i]是"顶点vs"到"顶点i"的最短路径的长度。 */public void dijkstra(int vs, int[] prev, int[] dist) &#123; // flag[i]=true表示"顶点vs"到"顶点i"的最短路径已成功获取 boolean[] flag = new boolean[mVexs.length]; // 初始化 for (int i = 0; i &lt; mVexs.length; i++) &#123; flag[i] = false; // 顶点i的最短路径还没获取到。 prev[i] = 0; // 顶点i的前驱顶点为0。 dist[i] = mMatrix[vs][i]; // 顶点i的最短路径为"顶点vs"到"顶点i"的权。 &#125; // 对"顶点vs"自身进行初始化 flag[vs] = true; dist[vs] = 0; // 遍历mVexs.length-1次；每次找出一个顶点的最短路径。 int k=0; for (int i = 1; i &lt; mVexs.length; i++) &#123; // 寻找当前最小的路径； // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。 int min = INF; for (int j = 0; j &lt; mVexs.length; j++) &#123; if (flag[j]==false &amp;&amp; dist[j]&lt;min) &#123; min = dist[j]; k = j; &#125; &#125; // 标记"顶点k"为已经获取到最短路径 flag[k] = true; // 修正当前最短路径和前驱顶点 // 即，当已经"顶点k的最短路径"之后，更新"未获取最短路径的顶点的最短路径和前驱顶点"。 for (int j = 0; j &lt; mVexs.length; j++) &#123; int tmp = (mMatrix[k][j]==INF ? INF : (min + mMatrix[k][j])); if (flag[j]==false &amp;&amp; (tmp&lt;dist[j]) ) &#123; dist[j] = tmp; prev[j] = k; &#125; &#125; &#125; // 打印dijkstra最短路径的结果 System.out.printf("dijkstra(%c): \n", mVexs[vs]); for (int i=0; i &lt; mVexs.length; i++) System.out.printf(" shortest(%c, %c)=%d\n", mVexs[vs], mVexs[i], dist[i]);&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prim算法]]></title>
    <url>%2F2018%2F06%2F09%2FPrim%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、普里姆算法介绍普里姆(Prim)算法，是用来求加权连通图的最小生成树的算法。 基本思想 对于图G而言，V是所有顶点的集合；现在，设置两个新的集合U和T，其中U用于存放G的最小生成树中的顶点，T存放G的最小生成树中的边。 从所有uЄU，vЄ(V-U) (V-U表示出去U的所有顶点)的边中选取权值最小的边(u, v)，将顶点v加入集合U中，将边(u, v)加入集合T中，如此不断重复，直到U=V为止，最小生成树构造完毕，这时集合T中包含了最小生成树中的所有边。 二、普里姆算法图解 以上图G4为例，来对普里姆进行演示(从第一个顶点A开始通过普里姆算法生成最小生成树)。 初始状态：V是所有顶点的集合，即V={A,B,C,D,E,F,G}；U和T都是空！ 第1步：将顶点A加入到U中。 ​ 此时，U={A}。 第2步：将顶点B加入到U中。 ​ 上一步操作之后，U={A}, V-U={B,C,D,E,F,G}；因此，边(A,B)的权值最小。将顶点B添加到U中；此时，U={A,B}。 第3步：将顶点F加入到U中。 ​ 上一步操作之后，U={A,B}, V-U={C,D,E,F,G}；因此，边(B,F)的权值最小。将顶点F添加到U中；此时，U={A,B,F}。 第4步：将顶点E加入到U中。 ​ 上一步操作之后，U={A,B,F}, V-U={C,D,E,G}；因此，边(F,E)的权值最小。将顶点E添加到U中；此时，U={A,B,F,E}。 第5步：将顶点D加入到U中。 ​ 上一步操作之后，U={A,B,F,E}, V-U={C,D,G}；因此，边(E,D)的权值最小。将顶点D添加到U中；此时，U={A,B,F,E,D}。 第6步：将顶点C加入到U中。 ​ 上一步操作之后，U={A,B,F,E,D}, V-U={C,G}；因此，边(D,C)的权值最小。将顶点C添加到U中；此时，U={A,B,F,E,D,C}。 第7步：将顶点G加入到U中。 ​ 上一步操作之后，U={A,B,F,E,D,C}, V-U={G}；因此，边(F,G)的权值最小。将顶点G添加到U中；此时，U=V。 此时，最小生成树构造完成！它包括的顶点依次是：A B F E D C G。 三、普里姆算法的代码说明以”邻接矩阵”为例对普里姆算法进行说明。 1. 基本定义 12345678public class MatrixUDG &#123; private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ...&#125; MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 普里姆算法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* * prim最小生成树 * * 参数说明： * start -- 从图中的第start个元素开始，生成最小树 */public void prim(int start) &#123; int num = mVexs.length; // 顶点个数 int index=0; // prim最小树的索引，即prims数组的索引 char[] prims = new char[num]; // prim最小树的结果数组 int[] weights = new int[num]; // 顶点间边的权值 // prim最小生成树中第一个数是"图中第start个顶点"，因为是从start开始的。 prims[index++] = mVexs[start]; // 初始化"顶点的权值数组"， // 将每个顶点的权值初始化为"第start个顶点"到"该顶点"的权值。 for (int i = 0; i &lt; num; i++ ) weights[i] = mMatrix[start][i]; // 将第start个顶点的权值初始化为0。 // 可以理解为"第start个顶点到它自身的距离为0"。 weights[start] = 0; for (int i = 0; i &lt; num; i++) &#123; // 由于从start开始的，因此不需要再对第start个顶点进行处理。 if(start == i) continue; int j = 0; int k = 0; int min = INF; // 在未被加入到最小生成树的顶点中，找出权值最小的顶点。 while (j &lt; num) &#123; // 若weights[j]=0，意味着"第j个节点已经被排序过"(或者说已经加入了最小生成树中)。 if (weights[j] != 0 &amp;&amp; weights[j] &lt; min) &#123; min = weights[j]; k = j; &#125; j++; &#125; // 经过上面的处理后，在未被加入到最小生成树的顶点中，权值最小的顶点是第k个顶点。 // 将第k个顶点加入到最小生成树的结果数组中 prims[index++] = mVexs[k]; // 将"第k个顶点的权值"标记为0，意味着第k个顶点已经排序过了(或者说已经加入了最小树结果中)。 weights[k] = 0; // 当第k个顶点被加入到最小生成树的结果数组中之后，更新其它顶点的权值。 for (j = 0 ; j &lt; num; j++) &#123; // 当第j个节点没有被处理，并且需要更新时才被更新。 if (weights[j] != 0 &amp;&amp; mMatrix[k][j] &lt; weights[j]) weights[j] = mMatrix[k][j]; &#125; &#125; // 计算最小生成树的权值 int sum = 0; for (int i = 1; i &lt; index; i++) &#123; int min = INF; // 获取prims[i]在mMatrix中的位置 int n = getPosition(prims[i]); // 在vexs[0...i]中，找出到j的权值最小的顶点。 for (int j = 0; j &lt; i; j++) &#123; int m = getPosition(prims[j]); if (mMatrix[m][n]&lt;min) min = mMatrix[m][n]; &#125; sum += min; &#125; // 打印最小生成树 System.out.printf("PRIM(%c)=%d: ", mVexs[start], sum); for (int i = 0; i &lt; index; i++) System.out.printf("%c ", prims[i]); System.out.printf("\n");&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kruskal算法]]></title>
    <url>%2F2018%2F06%2F09%2FKruskal%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一、最小生成树在含有n个顶点的连通图中选择n-1条边，构成一棵极小连通子图，并使该连通子图中n-1条边上权值之和达到最小，则称其为连通网的最小生成树。 例如，对于如上图G4所示的连通网可以有多棵权值总和不相同的生成树。 二、克鲁斯卡尔算法介绍克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。 基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路。 具体做法：首先构造一个只含n个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止。 三、克鲁斯卡尔算法图解 以上图G4为例，来对克鲁斯卡尔进行演示(假设，用数组R保存最小生成树结果)。 第1步：将边加入R中。 ​ 边的权值最小，因此将它加入到最小生成树结果R中。 第2步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第3步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第4步：将边加入R中。 ​ 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳过边。将边加入到最小生成树结果R中。 第5步：将边加入R中。 ​ 上一步操作之后，边的权值最小，因此将它加入到最小生成树结果R中。 第6步：将边加入R中。 ​ 上一步操作之后，边的权值最小，但会和已有的边构成回路；因此，跳过边。同理，跳过边。将边加入到最小生成树结果R中。 此时，最小生成树构造完成！它包括的边依次是： 。 四、克鲁斯卡尔算法分析根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题： 问题一 对图的所有边按照权值大小进行排序。 问题二 将边添加到最小生成树中时，怎么样判断是否形成了回路。 问题一很好解决，采用排序算法进行排序即可。 问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”(关于这一点，后面会通过图片给出说明)。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。 以下图来进行说明： 在将 加入到最小生成树R中之后，这几条边的顶点就都有了终点： (01) C的终点是F。 (02) D的终点是F。 (03) E的终点是F。 (04) F的终点是F。 关于终点，就是将所有顶点按照从小到大的顺序排列好之后；某个顶点的终点就是”与它连通的最大顶点”。 因此，接下来，虽然是权值最小的边。但是C和E的重点都是F，即它们的终点相同，因此，将加入最小生成树的话，会形成回路。这就是判断回路的方式。 五、克鲁斯卡尔算法的代码说明有了前面的算法分析之后，下面我们来查看具体代码。这里选取”邻接矩阵”进行说明，对于”邻接表”实现的图在后面的源码中会给出相应的源码。 1. 基本定义 123456789101112// 边的结构体private static class EData &#123; char start; // 边的起点 char end; // 边的终点 int weight; // 边的权重 public EData(char start, char end, int weight) &#123; this.start = start; this.end = end; this.weight = weight; &#125;&#125;; EData是邻接矩阵边对应的结构体。 123456789public class MatrixUDG &#123; private int mEdgNum; // 边的数量 private char[] mVexs; // 顶点集合 private int[][] mMatrix; // 邻接矩阵 private static final int INF = Integer.MAX_VALUE; // 最大值 ...&#125; MatrixUDG是邻接矩阵对应的结构体。mVexs用于保存顶点，mEdgNum用于保存边数，mMatrix则是用于保存矩阵信息的二维数组。例如，mMatrix[i][j]=1，则表示”顶点i(即mVexs[i])”和”顶点j(即mVexs[j])”是邻接点；mMatrix[i][j]=0，则表示它们不是邻接点。 2. 克鲁斯卡尔算法 123456789101112131415161718192021222324252627282930313233343536/* * 克鲁斯卡尔（Kruskal)最小生成树 */public void kruskal() &#123; int index = 0; // rets数组的索引 int[] vends = new int[mEdgNum]; // 用于保存"已有最小生成树"中每个顶点在该最小树中的终点。 EData[] rets = new EData[mEdgNum]; // 结果数组，保存kruskal最小生成树的边 EData[] edges; // 图对应的所有边 // 获取"图中所有的边" edges = getEdges(); // 将边按照"权"的大小进行排序(从小到大) sortEdges(edges, mEdgNum); for (int i=0; i&lt;mEdgNum; i++) &#123; int p1 = getPosition(edges[i].start); // 获取第i条边的"起点"的序号 int p2 = getPosition(edges[i].end); // 获取第i条边的"终点"的序号 int m = getEnd(vends, p1); // 获取p1在"已有的最小生成树"中的终点 int n = getEnd(vends, p2); // 获取p2在"已有的最小生成树"中的终点 // 如果m!=n，意味着"边i"与"已经添加到最小生成树中的顶点"没有形成环路 if (m != n) &#123; vends[m] = n; // 设置m在"已有的最小生成树"中的终点为n rets[index++] = edges[i]; // 保存结果 &#125; &#125; // 统计并打印"kruskal最小生成树"的信息 int length = 0; for (int i = 0; i &lt; index; i++) length += rets[i].weight; System.out.printf("Kruskal=%d: ", length); for (int i = 0; i &lt; index; i++) System.out.printf("(%c,%c) ", rets[i].start, rets[i].end); System.out.printf("\n");&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拓扑排序]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[一、拓扑排序介绍拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。 这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！ 例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。 在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。 二、拓扑排序的算法图解拓扑排序算法的基本步骤： 1. 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)； 2. 把所有没有依赖顶点的节点放入Q； 3. 当Q还有顶点的时候，执行下面步骤： 3.1 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)； 3.2 对n每一个邻接点m(n是起点，m是终点)； 3.2.1 去掉边; 3.2.2 如果m没有依赖顶点，则把m放入Q; 注：顶点A没有依赖顶点，是指不存在以A为终点的边。 以上图为例，来对拓扑排序进行演示。 第1步：将B和C加入到排序结果中。 ​ 顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边和，并将A和D加入到队列Q中。同样的，去掉边和，并将F和G加入到Q中。 ​ (01) 将B加入到排序结果中，然后去掉边和；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。 ​ (02) 将C加入到排序结果中，然后去掉边和；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。 第2步：将A,D依次加入到排序结果中。 ​ 第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。 第3步：将E,F,G依次加入到排序结果中。 因此访问顺序是：B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; F -&gt; G 三、拓扑排序的代码说明拓扑排序是对有向无向图的排序。下面以邻接表实现的有向图来对拓扑排序进行说明。 1. 基本定义 1234567891011121314151617public class ListDG &#123; // 邻接表中表对应的链表的顶点 private class ENode &#123; int ivex; // 该边所指向的顶点的位置 ENode nextEdge; // 指向下一条弧的指针 &#125; // 邻接表中表的顶点 private class VNode &#123; char data; // 顶点信息 ENode firstEdge; // 指向第一条依附该顶点的弧 &#125;; private VNode[] mVexs; // 顶点数组 ...&#125; (01) ListDG是邻接表对应的结构体。 mVexs则是保存顶点信息的一维数组。 (02) VNode是邻接表顶点对应的结构体。 data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。 (03) ENode是邻接表顶点所包含的链表的节点对应的结构体。 ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。 2. 拓扑排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* * 拓扑排序 * * 返回值： * -1 -- 失败(由于内存不足等原因导致) * 0 -- 成功排序，并输入结果 * 1 -- 失败(该有向图是有环的) */public int topologicalSort() &#123; int index = 0; int num = mVexs.size(); int[] ins; // 入度数组 char[] tops; // 拓扑排序结果数组，记录每个节点的排序后的序号。 Queue&lt;Integer&gt; queue; // 辅组队列 ins = new int[num]; tops = new char[num]; queue = new LinkedList&lt;Integer&gt;(); // 统计每个顶点的入度数 for(int i = 0; i &lt; num; i++) &#123; ENode node = mVexs.get(i).firstEdge; while (node != null) &#123; ins[node.ivex]++; node = node.nextEdge; &#125; &#125; // 将所有入度为0的顶点入队列 for(int i = 0; i &lt; num; i ++) if(ins[i] == 0) queue.offer(i); // 入队列 while (!queue.isEmpty()) &#123; // 队列非空 int j = queue.poll().intValue(); // 出队列。j是顶点的序号 tops[index++] = mVexs.get(j).data; // 将该顶点添加到tops中，tops是排序结果 ENode node = mVexs.get(j).firstEdge;// 获取以该顶点为起点的出边队列 // 将与"node"关联的节点的入度减1； // 若减1之后，该节点的入度为0；则将该节点添加到队列中。 while(node != null) &#123; // 将节点(序号为node.ivex)的入度减1。 ins[node.ivex]--; // 若节点的入度为0，则将其"入队列" if( ins[node.ivex] == 0) queue.offer(node.ivex); // 入队列 node = node.nextEdge; &#125; &#125; if(index != num) &#123; System.out.printf("Graph has a cycle\n"); return 1; &#125; // 打印拓扑排序结果 System.out.printf("== TopSort: "); for(int i = 0; i &lt; num; i ++) System.out.printf("%c ", tops[i]); System.out.printf("\n"); return 0;&#125; 说明： (01) queue的作用就是用来存储没有依赖顶点的顶点。它与前面所说的Q相对应。 (02) tops的作用就是用来存储排序结果。它与前面所说的T相对应。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图的基础]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%9B%BE%E7%9A%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、图的基本概念1. 图的定义定义：图(graph)是由一些点(vertex)和这些点之间的连线(edge)所组成的；其中，点通常被成为”顶点(vertex)”，而点与点之间的连线则被成为”边或弧”(edege)。通常记为，G=(V,E)。 2. 图的种类根据边是否有方向，将图可以划分为：无向图和有向图。 2.1 无向图 上面的图G0是无向图，无向图的所有的边都是不区分方向的。G0=(V1,{E1})。其中， (01) V1={A,B,C,D,E,F}。 V1表示由”A,B,C,D,E,F”几个顶点组成的集合。 (02) E1={(A,B),(A,C),(B,C),(B,E),(B,F),(C,F), (C,D),(E,F),(C,E)}。 E1是由边(A,B),边(A,C)…等等组成的集合。其中，(A,C)表示由顶点A和顶点C连接成的边。 2.2 有向图 上面的图G2是有向图。和无向图不同，有向图的所有的边都是有方向的！ G2=(V2,{A2})。其中， (01) V2={A,C,B,F,D,E,G}。 V2表示由”A,B,C,D,E,F,G”几个顶点组成的集合。 (02) A2={,,,,,,,,}。 E1是由矢量,矢量…等等组成的集合。其中，矢量&lt;A,B)表示由”顶点A”指向”顶点B”的有向边。 3. 邻接点和度3.1 邻接点 一条边上的两个顶点叫做邻接点。 例如，上面无向图G0中的顶点A和顶点C就是邻接点。 在有向图中，除了邻接点之外；还有”入边”和”出边”的概念。 顶点的入边，是指以该顶点为终点的边。而顶点的出边，则是指以该顶点为起点的边。 例如，上面有向图G2中的B和E是邻接点；是B的出边，还是E的入边。 3.2 度 在无向图中，某个顶点的度是邻接到该顶点的边(或弧)的数目。 例如，上面无向图G0中顶点A的度是2。 在有向图中，度还有”入度”和”出度”之分。 某个顶点的入度，是指以该顶点为终点的边的数目。而顶点的出度，则是指以该顶点为起点的边的数目。顶点的度=入度+出度。 例如，上面有向图G2中，顶点B的入度是2，出度是3；顶点B的度=2+3=5。 4. 路径和回路路径：如果顶点(Vm)到顶点(Vn)之间存在一个顶点序列。则表示Vm到Vn是一条路径。 路径长度：路径中”边的数量”。 简单路径：若一条路径上顶点不重复出现，则是简单路径。 回路：若路径的第一个顶点和最后一个顶点相同，则是回路。 简单回路：第一个顶点和最后一个顶点相同，其它各顶点都不重复的回路则是简单回路。 5. 连通图和连通分量连通图：对无向图而言，任意两个顶点之间都存在一条无向路径，则称该无向图为连通图。 对有向图而言，若图中任意两个顶点之间都存在一条有向路径，则称该有向图为强连通图。 连通分量：非连通图中的各个连通子图称为该图的连通分量。 6. 权在学习”哈夫曼树”的时候，了解过”权”的概念。图中权的概念与此类似。 上面就是一个带权的图。 二、图的存储结构上面了解了”图的基本概念”，下面开始介绍图的存储结构。图的存储结构，常用的是”邻接矩阵“和”邻接表“。 1. 邻接矩阵邻接矩阵是指用矩阵来表示图。它是采用矩阵来描述图中顶点之间的关系(及弧或边的权)。假设图中顶点数为n，则邻接矩阵定义为： 下面通过示意图来进行解释。 图中的G1是无向图和它对应的邻接矩阵。 图中的G2是无向图和它对应的邻接矩阵。 通常采用两个数组来实现邻接矩阵：一个一维数组用来保存顶点信息，一个二维数组来用保存边的信息。邻接矩阵的缺点就是比较耗费空间。 2. 邻接表邻接表是图的一种链式存储表示方法。它是改进后的”邻接矩阵”，它的缺点是不方便判断两个顶点之间是否有边，但是相对邻接矩阵来说更省空间。 图中的G1是无向图和它对应的邻接矩阵。 图中的G2是有向图和它对应的邻接矩阵。 三、图的深度/广度优先遍历1. 深度优先搜索介绍图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。 它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。 显然，深度优先搜索是一个递归的过程。 2. 深度优先搜索图解2.1 无向图的深度优先搜索 下面以”无向图”为例，来对深度优先搜索进行演示。 对上面的图G1进行深度优先遍历，从顶点A开始。 第1步：访问A。 第2步：访问(A的邻接点)C。 ​ 在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。 第3步：访问(C的邻接点)B。 ​ 在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 第4步：访问(C的邻接点)D。 ​ 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 第5步：访问(A的邻接点)F。 ​ 前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 第6步：访问(F的邻接点)G。 第7步：访问(G的邻接点)E。 因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E 2.2 有向图的深度优先搜索 下面以”有向图”为例，来对深度优先搜索进行演示。 对上面的图G2进行深度优先遍历，从顶点A开始。 第1步：访问A。 第2步：访问B。 ​ 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 第3步：访问C。 ​ 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 第4步：访问E。 ​ 接下来访问C的出边的另一个顶点，即顶点E。 第5步：访问D。 ​ 接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 第6步：访问F。 ​ 接下应该回溯”访问A的出边的另一个顶点F”。 第7步：访问G。 因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G 3. 广度优先搜索介绍广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。 它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。 换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。 4. 广度优先搜索图解4.1 无向图的广度优先搜索 下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。 第1步：访问A。 第2步：依次访问C,D,F。 ​ 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 第3步：依次访问B,G。 ​ 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 第4步：访问E。​ 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。 因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E 4.2 有向图的广度优先搜索 下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。 第1步：访问A。 第2步：访问B。 第3步：依次访问C,E,F。 ​ 在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 第4步：依次访问D,G。​ 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。 因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B-树，B+树，B*树]]></title>
    <url>%2F2018%2F06%2F09%2FB-%E6%A0%91%EF%BC%8CB-%E6%A0%91%EF%BC%8CB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一、概念 Binary Tree（二叉树）：二叉树的每个节点最多有两个子节点 Binary Search Tree（二叉搜索树）：二叉搜索树每个节点只存储一个键值，并且左子树（如果有）所有节点的值都要小于根节点的值，右子树（如果有）所有节点的值都要大于根节点的值。 B-Tree（Balanced Tree）：也就是今天要说的B-树，这里的-不是minus的意思，而是作为连接符的横杠，而我们也经常把B-树直接翻译为B树，所以B树与B-树通常是指一个概念，B代表的是Balance，而不是Binary。而B+树和B*树则是B-树的基础上正对不同场景的优化版本，将会在后文中有所介绍。 在大规模数据存储中，二叉查找树的深度会过大，当内存无法存储所有节点数据时，需要读取磁盘，进行IO操作，从而树的高度越高，I/O操作次数越多，效率也就越低。所以诸如之前所讲的红黑树，AVL树 因为树的高度太高而不适合这种需要大量IO操作的查询。所以，B树通过多叉的实现来降低树的高度，从而减少IO操作的次数。 二、B树（B-树）为方便描述，下面一律用B数这个名称。B树是一种多路平衡搜索树（非二叉），若其是M路，则： 任意非叶子节点最多可以有M个子女，且M&gt;2； 根节点的子女数为[2,M]； 除了根节点以外的非叶子节点的子女数目为M/2（取上整）个到M个； 每个节点存放至少M/2-1（取上整）和至多M-1个键值（至少两个）； 非叶子节点的关键字个数=指向子女的指针个数-1； 非叶子节点的关键字K[1],K[2],…,K[M-1]且有K[i]&lt;K[i+1]； 非叶子节点的指针P[1],P[2],…,P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其他P[i]指向关键字属于(K[i-1],K[i])的子树； 所有叶子节点都位于同一层。 B树与二叉搜索树的最大区别在于其每个节点可以存不止一个键值，并且其子女不止两个，不过还是需要满足键值数=子女数-1。因此，对于相同数量的键值，B树比二叉搜索树要更加矮一些，特别是当M较大时，树高会更低。 上图中是一个简单的B树，在实际应用中，M可以取到很大，比如大于1000。一般情况下M的取值会使得每个磁盘盘块可以正好存放一个B数节点。上图中的35节点，35是一个key（或者说是索引，比如磁盘文件的文件名），而小黑块则代表的是该key所指向的内容在磁盘中实际的存储位置，是一个指针（比如35这个文件在硬盘中的位置）。 B树的搜索B树的搜索与二叉搜索树类似，只不过需要在节点内部进行一次搜索查找。从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点； B树的插入B树的插入首先查找插入所在的节点，若该节点未满，插入即可，若该节点以及满了，则需要将该节点分裂，并将该节点的中间的元素移动到父节点上，若父节点未满，则结束，若父节点也满了，则需要继续分裂父节点，如此不断向上，直到根节点，如果根节点也满了，则分裂根节点，从而树的高度+1。 下面是B树插入的一个演示动画，往B树中一次插入的元素为6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4。 B树的删除B树的删除首先要找到删除的节点，并删除节点中的元素，如果删除的元素有左右孩子，则上移左孩子最右节点或右孩子最左节点到父节点，若没有左右孩子，则直接删除。删除后，若某节点中元素数目不符合B树要求（小于M/2-1取上整），则需要看起相邻的兄弟节点是否有多余的元素，若有，则可以向父节点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中（有点类似于左旋）。若其相邻兄弟节点没有多余的元素，则与其兄弟节点合并成一个节点，此时也需要将父节点中的一个元素一起合并。 三、B+树B+树是B树的一个变种，其也是一种多路平衡搜索树，其与B树的主要区别是： 非叶子节点的指针数量与关键字数量相等； 非叶子节点的子树指针P[i]，指向关键字值属于[K[i],K[i+1]）的子树（B树是开区间，B+树是左闭右开，也就是说B树不允许关键字重复，而B+树允许）； 所有关键字都在叶子节点出现，所有的叶子节点增加了一个链指针（稠密索引，且链表中的关键字切好是有序的）； 非叶子节点相当于是叶子节点的索引（稀疏索引），叶子节点相当于是存储数据的数据层。 B+树主要是应文件系统所需而产生的。文件系统中，文件的目录是一级一级索引，只有最底层的叶子节点（文件）保存数据。非叶子节点只保存索引，不保存实际的数据，数据都保存在叶子节点中，所有的非叶子节点都可以看成是索引部分。 非叶子节点（比如[5，28，65]）只是一个key（索引，实际的数据在叶子节点上，对应于叶子节点[5,8,9]中的5，[28,30,33]中的28，[65,73,79]中的65才是真正的数据或指向真实数据的指针）。 B+树的搜索B+的搜索与B树也是基本相同的。唯一的区别是B+树只有达到叶子结点才命中，因为只有叶节点中存放着真实数据或真实数据的指正，而B树可以在非叶子结点命中，其性能也等价于在元素全集做一次二分查找。 B+树的插入B+树的插入与B树类似，如果节点中有多余的空间放入元素，则直接插入即可。如果节点本来就已经满了，则将其分裂为两个节点，并将其中间元素的索引放入到父节点中，在这里如果是叶子节点的话，是拷贝中间元素的索引到父节点中（因为叶子节点需要包含所有的元素），而如果是非叶子节点，则是上移节点的中间元素到父节点中。 下面是B+树插入的一个演示动画： B+树的删除在叶节点中删除元素，如果节点还满足B+树的要求，则okay。如果元素个数过少，并且其邻近兄弟节点有多余的元素，则从邻近兄弟节点中借一个元素，并修改父节点中的索引使其满足新的划分。如果其邻近兄弟节点也没有多余的元素，则将其和邻近兄弟节点合并，并且我们需要修改其父节点的索引以满足新的划分。并且如果父节点的索引元素太少不满足要求，则需要继续看起兄弟节点是否多余，如果没有多余则还需要与兄弟节点合并，如此不断向上，直到根节点。如果根节点中元素也被删除，则把根节点删除，并由合并来的节点作为新的根节点，树的高度减1。 四、B+树与B树的比较B+树的非叶子节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，盘块所能容纳的关键字数量也越多，具有更好的空间局部性，一次性读入内存的需要查找的关键字也越多，相对的IO读写次数也就降低了。 另外对于B+树来说，因为非叶子节点只是叶子节点中关键字的索引，所以任何关键字的查找都必须走一条从根节点到叶子节点的路，所有关键字查询的路径长度相同。而若经常访问的元素离根节点很近，则B树访问更迅速，因为其不一定要到叶子节点。 数据库索引采用B+树的主要原因是B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，而也正是为了解决该问题，B+树应运而生。因为叶子节点中增加了一个链指针，B+树只需要取遍历叶子节点可以实现整棵树的遍历。而且数据库中基于范围的查询是非常频繁的，B树对基于范围的查询效率太低。 五、B*树B*树又是B+树的变种，其与B+树的区别有： B*树在B+树的非根和非叶子节点再增加指向兄弟节点的指针 B树规定非叶子节点的键值个数至少为(2/3)M，这样每个节点的使用率就从B+树的1/2上升到2/3，所以空间使用率更高。 B树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；B树分配新结点的概率比B+树要低，空间使用率更高；]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[一、并查集的介绍 并查集（Union/Find）从名字可以看出，主要涉及两种基本操作:合并和查找。这说明，初始时并查集中的元素是不相交的，经过一系列的基本操作(Union)，最终合并成一个大的集合。 而在某次合并之后，有一种合理的需求：某两个元素是否已经处在同一个集合中了？因此就需要Find操作。 并查集是一种 不相交集合 的数据结构，设有一个动态集合S={s1，s2，s3，…..sn}，每个集合通过一个代表来标识，该代表中集合中的某个元素。 比如，若某个元素 x 是否在集合 s1 中(Find操作)，返回集合 s1 的代表元素即可。这样，判断两个元素是否在同一个集合中也是很方便的，只要看find(x) 和 find(y) 是否返回同一个代表即可。 为什么是动态集合S呢？因为随着Union操作，动态集合S中的子集合个数越来越少。 数据结构的基本操作决定了它的应用范围，对并查集而言，一个简单的应用就是判断无向图的连通分量个数，或者判断无向图中任何两个顶点是否连通。 二、并查集的存储结构及实现分析①存储结构 并查集(大S)由若干子集合si构成，并查集的逻辑结构就是一个森林。si表示森林中的一棵子树。一般以子树的根作为该子树的代表。 而对于并查集的存储结构，可用一维数组和链表来实现。这里主要介绍一维数组的实现。 根据前面介绍的基本操作再加上存储结构，并查集类的实现架构如下： 12345678910111213141516public class DisjSets &#123; private int[] s; private int count;//记录并查集中子集合的个数(子树的个数) public DisjSets(int numElements) &#123; //构造函数，负责初始化并查集 &#125; public void unionByHeight(int root1, int root2)&#123; //union操作 &#125; public int find(int x)&#123; //find 操作 &#125;&#125; 由于Find操作需要找到该子集合的代表元素，而代表元素是树根，因此需要保存树中结点的父亲，对于每一个结点，如果知道了父亲，沿着父结点链就可以最终找到树根。 为了简单起见，假设一维数组s中的每个元素 s[i] 表示该元素 i 的父亲。这里有两个需要注意的地方：①我们用一维数组来存储并查集，数组的元素s[i]表示的是结点的父亲的位置。②数组元素的下标 i 则是结点的标识。如：s[5]=4，节点5 在数组的第4号位置处。 假设有并查集中6个元素，初始时，所有的元素都相互独立，处在不同的集合中： 对应的一维数组初始化如下： 因为，初始时每个元素代表一个集合，该元素本身就是树根。树根的父结点用 -1 来表示。代码实现如下： 1234567public DisjSets(int numElements) &#123; s = new int[numElements]; count = numElements; //初始化并查集,相当于新建了s.length 个互不相交的集合 for(int i = 0; i &lt; s.length; i++) s[i] = -1;//s[i]存储的是高度(秩)信息 &#125; ②基本操作实现 Union操作就是将两个不相交的子集合合并成一个大集合。简单的Union操作是非常容易实现的，因为只需要把一棵子树的根结点指向另一棵子树即可完成合并。 比如合并 节点3 和节点4： 这里的合并很随意，把任意一棵子树的结点指向另一棵子树结点就完成了合并。 123public void union(int root1, int root2)&#123; s[root2] = root1;//将root1作为root2的新树根&#125; 但是，这只是一个简单的情况，如果待合并的两棵子树很大，而且高度不一样时，如何使得合并操作生成的新的子树的高度最小？因为高度越小的子树Find操作越快。 后面会介绍一种更好的合并策略，以支持Quick Union/Find。 Find操作就是查找某个元素所在的集合，返回该集合的代表元素。在union(3,4) 和 union(1,2)后，并查集如下： 此时的一维数组如下： 此时一共有4个子集合。第一个集合的代表元素为0，第二个集合的代表元素为1，第三个集合的代表元素为3，第四个集合的代表元素为5，故： find(2)返回1，find(0)返回0。因为 结点3 和 结点4 在同一个集合内，find(4)返回3，find(3)返回3。 123456public int find(int x)&#123; if(s[x] &lt; 0) return x; else return find(s[x]);&#125; 这里find(int x)返回的是最里层递归执行后，得到的值。由于只有树根的父结点位置小于0，故返回的是树根结点的标识。 （数组中索引 i 处的元素 s[i] 小于0，表示 结点i 是根结点…..） 三、Union/Find的改进—-Quick Union/Find 上面介绍的Union操作很随意：任选一棵子树，将另一棵子树的根指向它即完成了合并。如果一直按照上述方式合并，很可能产生一棵非常不平衡的子树。 比如在上面的基础上union(2,3)后 树越来越高了，此时会影响到Find操作的效率。比如，find(4)时，会一直沿着父结点遍历直到根，4–&gt;3–&gt;2–&gt;1 这里引入一种新的合并策略，这是一种启发式策略，称之为按秩合并：将秩小的子树的根指向秩大的子树的根。 秩的定义：对每个结点，用秩表示结点高度的一个上界。为什么是上界？ 因为路径压缩不完全与按高度求并兼容。路径压缩会改变树的高度，这样在Union操作之前，我们就无法获得子树的高度的精确值，因此就不计算高度的精确值，而是存储每棵树的高度的估计值，这个值称之为秩。 说了这么多，按秩求并就是在合并之前，先判断下哪棵子树更高，让矮的子树的根指向高的子树的根。 除了按高度求并之外，还可以按大小求并，即先判断下哪棵子树含有的结点数目多，让较小的子树的根指向较大的子树的根。 对于按高度求并，需要解释下数组中存储的元素：是高度的负值再减去1。这样，初始时，所有元素都是-1，而树根节点的高度为0，s[i]=-1。 按高度求并的代码如下： 1234567891011121314151617181920/** * * @param root1 并查集中以root1为代表的某个子集 * @param roo2 并查集中以root2为代表的某个子集 * 按高度(秩)合并以root1 和 root2为代表的两个集合 */ public void unionByHeight(int root1, int root2)&#123; if(find(root1) == find(root2)) return;//root1 与 root2已经连通了 if(s[root2] &lt; s[root1])//root2 is deeper s[root1] = root2; else&#123; if(s[root1] == s[root2])//root1 and root2 is the same deeper s[root1]--;//将root1的高度加1 s[root2] = root1;//将root2的根(指向)更新为root1 &#125; count--;//每union一次,子树数目减1 &#125; 使用了路径压缩的Find的操作上面程序代码find方法只是简单地把待查找的元素所在的根返回。路径压缩是指，在find操作进行时，使find查找路径中的顶点(的父亲)都直接指向为树根（这很明显地改变了子树的高度） 如何使find查找路径中经过的每个顶点都直接指向树根呢？只需要小小改动一下就可以了，这里用到了非常神奇的递归。修改后的find代码如下： 1234567public int find(int x)&#123; if(s[x] &lt; 0)//s[x]为负数时,说明 x 为该子集合的代表(也即树根), 且s[x]的值表示树的高度 return x; else return s[x] = find(s[x]);//使用了路径压缩,让查找路径上的所有顶点都指向了树根(代表节点) //return find(s[x]); 没有使用 路径压缩 &#125; 因为递归最终得到的返回值是根元素。第5行将根元素直接赋值给s[x]，s[x]在每次递归过程中相当于结点x的父结点指针。 关于路径压缩对按”秩“求并的兼容性问题上面的unionByHeight(int , int)是按照两棵树的高度来进行合并的。但是find操作中的路径压缩会对树的高度产生影响。使用了路径压缩后，树的高度变化了，但是数组并没有更新这个变化。因为无法更新！！（我们没有在Find操作中去计算原来的树的高度，然后再计算新的树的高度，这样不现实，复杂度太大了） 举个例子： 依次高度unionByHeight(3, 4)、unionByHeight(1, 3)、unionByHeight(1, 0)后，并查集如下： 此时，数组中的元素如下： 可以看出，此时只有两棵子树，一棵根结点为1，另一棵只有一个结点5。结点1的s[1]=-3，它所表示是该子树的高度为2，如果此时执行find(4)，会改变这棵树的高度！但是，数组s中存储的根的高度却没有更新，只会更新查找路径上的顶点的高度。执行完find(4)后，变成： 查找路径为 4–&gt;3–&gt;1，find(4)使得查找路径上的所有顶点的父结点指向了根。如，将结点4 指向了根。但是没有根结点的高度（没有影响树根的秩），因为s[1]的值仍为-3 -3表示的高度为2，但是树的高度实际上已经变成了1 执行find(4)之后，树实际上是这样的： （关于路径压缩对按秩合并有影响，我一直有个疑问，希望有大神指点啊）。。。。 路径压缩改变了子树的高度，而这个高度是按秩求的依据。，而且当高度改变之后，我们是无法更新这个变化了的高度的。那这会不会影响按秩求并的正确性？或者说使按秩求并达不到减小新生成的子树的高度的效果？ 四、并查集的应用 并查集数据结构非常简单，基本操作也很简单。但是用途感觉很大。比如，求解无向图中连通分量的个数，生成迷宫…… 这些应用本质上就是：初始时都是一个个不连通的对象，经过一步步处理，变成连通的了。。。。。 如迷宫，初始时，起点和终点不连通，随机地打开起点到终点路径上的一个方向，直至起点和终点连通了，就生成了一个迷宫。 如，无向图的连通分量个数，初始时，将无向图中各个顶点视为不连通的子集合，对图中每一条边，相当于union这条边对应的两个顶点分别所在的集合，直至所有的边都处理完后，还剩下的集合的个数即为连通分量的个数。 五、完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class DisjSets &#123; private int[] s; private int count;//记录并查集中子集合的个数(子树的个数) public DisjSets(int numElements) &#123; s = new int[numElements]; count = numElements; //初始化并查集,相当于新建了s.length 个互不相交的集合 for(int i = 0; i &lt; s.length; i++) s[i] = -1;//s[i]存储的是高度(秩)信息 &#125; /** * * @param root1 并查集中以root1为代表的某个子集 * @param roo2 并查集中以root2为代表的某个子集 * 按高度(秩)合并以root1 和 root2为代表的两个集合 */ public void unionByHeight(int root1, int root2)&#123; if(find(root1) == find(root2)) return;//root1 与 root2已经连通了 if(s[root2] &lt; s[root1])//root2 is deeper s[root1] = root2; else&#123; if(s[root1] == s[root2])//root1 and root2 is the same deeper s[root1]--;//将root1的高度加1 s[root2] = root1;//将root2的根(指向)更新为root1 &#125; count--;//每union一次,子树数目减1 &#125; public void union(int root1, int root2)&#123; s[root2] = root1;//将root1作为root2的新树根 &#125; public void unionBySize(int root1, int root2)&#123; if(find(root1) == find(root2)) return;//root1 与 root2已经连通了 if(s[root2] &lt; s[root1])//root2 is deeper s[root1] = root2; else&#123; if(s[root1] == s[root2])//root1 and root2 is the same deeper s[root1]--;//将root1的高度加1 s[root2] = root1;//将root2的根(指向)更新为root1 &#125; count--;//每union一次,子树数目减1 &#125; public int find(int x)&#123; if(s[x] &lt; 0)//s[x]为负数时,说明 x 为该子集合的代表(也即树根), 且s[x]的值表示树的高度 return x; else return s[x] = find(s[x]);//使用了路径压缩,让查找路径上的所有顶点都指向了树根(代表节点) //return find(s[x]); 没有使用 路径压缩 &#125; public int find0(int x)&#123; if(s[x] &lt; 0) return x; else return find0(s[x]); &#125; public int size()&#123; return count; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见树]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%B8%B8%E8%A7%81%E6%A0%91%2F</url>
    <content type="text"><![CDATA[一、AVL树AVL树是高度平衡的而二叉树。它的特点是：AVL树中任何节点的两个子树的高度最大差别为1。 上面的两张图片，左边的是AVL树，它的任何节点的两个子树的高度差别都&lt;=1；而右边的不是AVL树，因为7的两颗子树的高度相差为2(以2为根节点的树的高度是3，而以8为根节点的树的高度是1)。 二、红黑树R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。 红黑树的特性: （1）每个节点或者是黑色，或者是红色。 （2）根节点是黑色。 （3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！] （4）如果一个节点是红色的，则它的子节点必须是黑色的。 （5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。 注意： (01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。 (02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。 红黑树示意图如下： 红黑树的应用红黑树的应用比较广泛，主要是用它来存储有序的数据，它的时间复杂度是O(lgn)，效率非常之高。例如，Java集合中的TreeMap和HashMap，都是通过红黑树去实现的。 三、哈夫曼树Huffman Tree，中文名是哈夫曼树或霍夫曼树，它是最优二叉树。 定义：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。 这个定义里面涉及到了几个陌生的概念，下面就是一颗哈夫曼树，我们来看图解答。 (01) 路径和路径长度 定义：在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。例子：100和80的路径长度是1，50和30的路径长度是2，20和10的路径长度是3。 (02) 结点的权及带权路径长度 定义：若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。例子：节点20的路径长度是3，它的带权路径长度= 路径长度x权 = 3 x 20 = 60。 (03) 树的带权路径长度 定义：树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。例子：示例中，树的WPL= 1x100 + 2x50 + 3x20 + 3x10 = 100 + 100 + 60 + 30 = 290。 比较下面两棵树 上面的两棵树都是以{10, 20, 50, 100}为叶子节点的树。 左边的树WPL=2x10 + 2x20 + 2x50 + 2x100 = 360 右边的树WPL=290 左边的树WPL &gt; 右边的树的WPL。你也可以计算除上面两种示例之外的情况，但实际上右边的树就是{10,20,50,100}对应的哈夫曼树。至此，应该堆哈夫曼树的概念有了一定的了解了，下面看看如何去构造一棵哈夫曼树。 哈夫曼树的图文解析假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为： 1. 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)； 2. 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和； 3. 从森林中删除选取的两棵树，并将新树加入森林； 4. 重复(02)、(03)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。 以{5,6,7,8,15}为例，来构造一棵哈夫曼树。 第1步：创建森林，森林包括5棵树，这5棵树的权值分别是5,6,7,8,15。 第2步：在森林中，选择根节点权值最小的两棵树(5和6)来进行合并，将它们作为一颗新树的左右孩子(谁左谁右无关紧要，这里，我们选择较小的作为左孩子)，并且新树的权值是左右孩子的权值之和。即，新树的权值是11。 然后，将”树5”和”树6”从森林中删除，并将新的树(树11)添加到森林中。 第3步：在森林中，选择根节点权值最小的两棵树(7和8)来进行合并。得到的新树的权值是15。 然后，将”树7”和”树8”从森林中删除，并将新的树(树15)添加到森林中。 第4步：在森林中，选择根节点权值最小的两棵树(11和15)来进行合并。得到的新树的权值是26。 然后，将”树11”和”树15”从森林中删除，并将新的树(树26)添加到森林中。 第5步：在森林中，选择根节点权值最小的两棵树(15和26)来进行合并。得到的新树的权值是41。 然后，将”树15”和”树26”从森林中删除，并将新的树(树41)添加到森林中。 此时，森林中只有一棵树(树41)。这棵树就是我们需要的哈夫曼树！]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的基础]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、树的介绍1.树的定义树是一种数据结构，它是由n（n&gt;=1）个有限节点组成一个具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点： (01) 每个节点有零个或多个子节点； (02) 没有父节点的节点称为根节点； (03) 每一个非根节点有且只有一个父节点； (04) 除了根节点外，每个子节点可以分为多个不相交的子树。 2.树的基本术语若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。有相同双亲的结点互为”兄弟”。一个结点的所有子树上的任何结点都是该结点的后裔。从根结点到某个结点的路径上的所有结点都是该结点的祖先。 结点的度：结点拥有的子树的数目。 叶子：度为零的结点。 分支结点：度不为零的结点。 树的度：树中结点的最大的度。 层次：根结点的层次为1，其余结点的层次等于该结点的双亲结点的层次加1。 树的高度：树中结点的最大层次。 无序树：如果树中结点的各子树之间的次序是不重要的，可以交换位置。 有序树：如果树中结点的各子树之间的次序是重要的, 不可以交换位置。 森林：0个或多个不相交的树组成。对森林加上一个根，森林即成为树；删去根，树即成为森林。 二、二叉树的介绍1.二叉树的定义二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。 2. 二叉树的性质二叉树有以下几个性质： 性质1：二叉树第i层上的结点数目最多为$2^{i-1}$ (i≥1)。 性质2：深度为k的二叉树至多有$2^k - 1$个结点(k≥1)。 性质3：包含n个结点的二叉树的高度至少为$log_2(n+1)$。 性质4：在任意一棵二叉树中，若叶子结点的个数为n0，度为2的结点数为n2，则n0=n2+1。 2.1 性质1：二叉树第i层上的结点数目最多为$2^{i-1}$(i≥1) 证明：下面用”数学归纳法”进行证明。 ​ (01) 当i=1时，第i层的节点数目为1。因为第1层上只有一个根结点，所以命题成立。 ​ (02) 假设当i&gt;1，第i层的节点数目为$2^{i-1}$。这个是根据(01)推断出来的！ 下面根据这个假设，推断出”第(i+1)层的节点数目为$2^{i}$”即可。 由于二叉树的每个结点至多有两个孩子，故”第(i+1)层上的结点数目” 最多是 “第i层的结点数目的2倍”。即，第(i+1)层上的结点数目最大值=2×$2^{i-1}$=$2^{i}$。 故假设成立，原命题得证！ 2.2 性质2：深度为k的二叉树至多有$2^{k}-1$个结点(k≥1) 证明：在具有相同深度的二叉树中，当每一层都含有最大结点数时，其树中结点数最多。利用”性质1”可知，深度为k的二叉树的结点数至多为： ​ $ 2^0+2^1+…+2^{k-1}=2^k-1$ 故原命题得证！ 2.3 性质3：包含n个结点的二叉树的高度至少为$log_2(n+1)$ 证明：根据”性质2”可知，高度为h的二叉树最多有$2^{h}-1$个结点。反之，对于包含n个节点的二叉树的高度至少为$log_2(n+1)$。 2.4 性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1 证明：因为二叉树中所有结点的度数均不大于2，所以结点总数(记为n)=”0度结点数(n0)” + “1度结点数(n1)” + “2度结点数(n2)”。由此，得到等式一。 (等式一) n=n0+n1+n2 另一方面，0度结点没有孩子，1度结点有一个孩子，2度结点有两个孩子，故二叉树中孩子结点总数是：n1+2n2。此外，只有根不是任何结点的孩子。故二叉树中的结点总数又可表示为等式二。 (等式二) n=n1+2n2+1 由(等式一)和(等式二)计算得到：n0=n2+1。原命题得证！ 3. 满二叉树，完全二叉树和二叉查找树3.1 满二叉树 定义：高度为h，并且由$2^{h}-1$个结点的二叉树，被称为满二叉树。 3.2 完全二叉树 定义：一棵二叉树中，只有最下面两层结点的度可以小于2，并且最下一层的叶结点集中在靠左的若干位置上。这样的二叉树称为完全二叉树。 特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。显然，一棵满二叉树必定是一棵完全二叉树，而完全二叉树未必是满二叉树。 3.3 二叉查找树 定义：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。 在二叉查找树中： (01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； (02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； (03) 任意节点的左、右子树也分别为二叉查找树。 (04) 没有键值相等的节点（no duplicate nodes）。 三、二叉查找树的Java实现1.二叉查找树节点的定义1234567891011121314151617181920public class BSTree&lt;T extends Comparable&lt;T&gt;&gt; &#123; private BSTNode&lt;T&gt; mRoot; // 根结点 public class BSTNode&lt;T extends Comparable&lt;T&gt;&gt; &#123; T key; // 关键字(键值) BSTNode&lt;T&gt; left; // 左孩子 BSTNode&lt;T&gt; right; // 右孩子 BSTNode&lt;T&gt; parent; // 父结点 public BSTNode(T key, BSTNode&lt;T&gt; parent, BSTNode&lt;T&gt; left, BSTNode&lt;T&gt; right) &#123; this.key = key; this.parent = parent; this.left = left; this.right = right; &#125; &#125; ......&#125; BSTree是二叉树，它保含了二叉树的根节点mRoot；mRoot是BSTNode类型，而BSTNode是二叉查找树的节点，它是BSTree的内部类。BSTNode包含二叉查找树的几个基本信息： (01) key – 它是关键字，是用来对二叉查找树的节点进行排序的。 (02) left – 它指向当前节点的左孩子。 (03) right – 它指向当前节点的右孩子。 (04) parent – 它指向当前节点的父结点。 2.遍历这里讲解前序遍历、中序遍历、后序遍历3种方式。 2.1 前序遍历 若二叉树非空，则执行以下操作： (01) 访问根结点； (02) 先序遍历左子树； (03) 先序遍历右子树。 前序遍历代码 1234567891011private void preOrder(BSTNode&lt;T&gt; tree) &#123; if(tree != null) &#123; System.out.print(tree.key+" "); preOrder(tree.left); preOrder(tree.right); &#125;&#125;public void preOrder() &#123; preOrder(mRoot);&#125; 2.2 中序遍历 若二叉树非空，则执行以下操作： (01) 中序遍历左子树； (02) 访问根结点； (03) 中序遍历右子树。 中序遍历代码 1234567891011private void inOrder(BSTNode&lt;T&gt; tree) &#123; if(tree != null) &#123; inOrder(tree.left); System.out.print(tree.key+" "); inOrder(tree.right); &#125;&#125;public void inOrder() &#123; inOrder(mRoot);&#125; 2.3 后序遍历 若二叉树非空，则执行以下操作： (01) 后序遍历左子树； (02) 后序遍历右子树； (03) 访问根结点。 后序遍历代码 123456789101112private void postOrder(BSTNode&lt;T&gt; tree) &#123; if(tree != null) &#123; postOrder(tree.left); postOrder(tree.right); System.out.print(tree.key+" "); &#125;&#125;public void postOrder() &#123; postOrder(mRoot);&#125; 看看下面这颗树的各种遍历方式： 对于上面的二叉树而言， (01) 前序遍历结果： 3 1 2 5 4 6 (02) 中序遍历结果： 1 2 3 4 5 6 (03) 后序遍历结果： 2 1 4 6 5 3 3. 查找递归版本的代码 12345678910111213141516171819/* * (递归实现)查找"二叉树x"中键值为key的节点 */private BSTNode&lt;T&gt; search(BSTNode&lt;T&gt; x, T key) &#123; if (x==null) return x; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return search(x.left, key); else if (cmp &gt; 0) return search(x.right, key); else return x;&#125;public BSTNode&lt;T&gt; search(T key) &#123; return search(mRoot, key);&#125; 非递归版本的代码 123456789101112131415161718192021/* * (非递归实现)查找"二叉树x"中键值为key的节点 */private BSTNode&lt;T&gt; iterativeSearch(BSTNode&lt;T&gt; x, T key) &#123; while (x!=null) &#123; int cmp = key.compareTo(x.key); if (cmp &lt; 0) x = x.left; else if (cmp &gt; 0) x = x.right; else return x; &#125; return x;&#125;public BSTNode&lt;T&gt; iterativeSearch(T key) &#123; return iterativeSearch(mRoot, key);&#125; 4. 最大值和最小值查找最大值的代码 12345678910111213141516171819/* * 查找最大结点：返回tree为根结点的二叉树的最大结点。 */private BSTNode&lt;T&gt; maximum(BSTNode&lt;T&gt; tree) &#123; if (tree == null) return null; while(tree.right != null) tree = tree.right; return tree;&#125;public T maximum() &#123; BSTNode&lt;T&gt; p = maximum(mRoot); if (p != null) return p.key; return null;&#125; 查找最小值的代码 12345678910111213141516171819/* * 查找最小结点：返回tree为根结点的二叉树的最小结点。 */private BSTNode&lt;T&gt; minimum(BSTNode&lt;T&gt; tree) &#123; if (tree == null) return null; while(tree.left != null) tree = tree.left; return tree;&#125;public T minimum() &#123; BSTNode&lt;T&gt; p = minimum(mRoot); if (p != null) return p.key; return null;&#125; 5. 前驱和后继节点的前驱：是该节点的左子树中的最大节点。 节点的后继：是该节点的右子树中的最小节点。 查找前驱节点的代码 12345678910111213141516171819/* * 找结点(x)的前驱结点。即，查找"二叉树中数据值小于该结点"的"最大结点"。 */public BSTNode&lt;T&gt; predecessor(BSTNode&lt;T&gt; x) &#123; // 如果x存在左孩子，则"x的前驱结点"为 "以其左孩子为根的子树的最大结点"。 if (x.left != null) return maximum(x.left); // 如果x没有左孩子。则x有以下两种可能： // (01) x是"一个右孩子"，则"x的前驱结点"为 "它的父结点"。 // (02) x是"一个左孩子"，则查找"x的最低的父结点，并且该父结点要具有右孩子"，找到的这个"最低的父结点"就是"x的前驱结点"。 BSTNode&lt;T&gt; y = x.parent; while ((y!=null) &amp;&amp; (x==y.left)) &#123;//满足条件，不断往上追溯，直到找到右祖先结点 x = y; y = y.parent; &#125; return y;&#125; 查找后继节点的代码 12345678910111213141516171819/* * 找结点(x)的后继结点。即，查找"二叉树中数据值大于该结点"的"最小结点"。 */public BSTNode&lt;T&gt; successor(BSTNode&lt;T&gt; x) &#123; // 如果x存在右孩子，则"x的后继结点"为 "以其右孩子为根的子树的最小结点"。 if (x.right != null) return minimum(x.right); // 如果x没有右孩子。则x有以下两种可能： // (01) x是"一个左孩子"，则"x的后继结点"为 "它的父结点"。 // (02) x是"一个右孩子"，则查找"x的最低的父结点，并且该父结点要具有左孩子"，找到的这个"最低的父结点"就是"x的后继结点"。 BSTNode&lt;T&gt; y = x.parent; while ((y!=null) &amp;&amp; (x==y.right)) &#123;//满足条件，不断往上追溯，直到找到右祖先结点 x = y; y = y.parent; &#125; return y;&#125; 6. 插入插入节点的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * 将结点插入到二叉树中 * * 参数说明： * tree 二叉树的 * z 插入的结点 */private void insert(BSTree&lt;T&gt; bst, BSTNode&lt;T&gt; z) &#123; int cmp; BSTNode&lt;T&gt; y = null; BSTNode&lt;T&gt; x = bst.mRoot; // 查找z的插入位置 while (x != null) &#123; y = x; cmp = z.key.compareTo(x.key); if (cmp &lt; 0) x = x.left; else x = x.right; &#125; z.parent = y; if (y==null) bst.mRoot = z; else &#123; cmp = z.key.compareTo(y.key); if (cmp &lt; 0) y.left = z; else y.right = z; &#125;&#125;/* * 新建结点(key)，并将其插入到二叉树中 * * 参数说明： * tree 二叉树的根结点 * key 插入结点的键值 */public void insert(T key) &#123; BSTNode&lt;T&gt; z=new BSTNode&lt;T&gt;(key,null,null,null); // 如果新建结点失败，则返回。 if (z != null) insert(this, z);&#125; 注：本文实现的二叉查找树是允许插入相同键值的节点的。 7. 删除删除节点的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * 删除结点(z)，并返回被删除的结点 * * 参数说明： * bst 二叉树 * z 删除的结点 */private BSTNode&lt;T&gt; remove(BSTree&lt;T&gt; bst, BSTNode&lt;T&gt; z) &#123; BSTNode&lt;T&gt; x=null; BSTNode&lt;T&gt; y=null; if ((z.left == null) || (z.right == null) ) y = z; else y = successor(z); if (y.left != null) x = y.left; else x = y.right; if (x != null) x.parent = y.parent; if (y.parent == null) bst.mRoot = x; else if (y == y.parent.left) y.parent.left = x; else y.parent.right = x; if (y != z) z.key = y.key; return y;&#125;/* * 删除结点(z)，并返回被删除的结点 * * 参数说明： * tree 二叉树的根结点 * z 删除的结点 */public void remove(T key) &#123; BSTNode&lt;T&gt; z, node; if ((z = search(mRoot, key)) != null) if ( (node = remove(this, z)) != null) node = null;&#125; 8. 打印打印二叉查找树的代码 1234567891011121314151617181920212223242526/* * 打印"二叉查找树" * * key -- 节点的键值 * direction -- 0，表示该节点是根节点; * -1，表示该节点是它的父结点的左孩子; * 1，表示该节点是它的父结点的右孩子。 */private void print(BSTNode&lt;T&gt; tree, T key, int direction) &#123; if(tree != null) &#123; if(direction==0) // tree是根节点 System.out.printf("%2d is root\n", tree.key); else // tree是分支节点 System.out.printf("%2d is %2d's %6s child\n", tree.key, key, direction==1?"right" : "left"); print(tree.left, tree.key, -1); print(tree.right,tree.key, 1); &#125;&#125;public void print() &#123; if (mRoot != null) print(mRoot, mRoot.key, 0);&#125; 9. 销毁销毁二叉查找树的代码 12345678910111213141516171819/* * 销毁二叉树 */private void destroy(BSTNode&lt;T&gt; tree) &#123; if (tree==null) return ; if (tree.left != null) destroy(tree.left); if (tree.right != null) destroy(tree.right); tree=null;&#125;public void clear() &#123; destroy(mRoot); mRoot = null;&#125; 四、树的深度/广度优先遍历树的深度优先遍历需要用到额外的数据结构—&gt;栈；而广度优先遍历需要队列来辅助；这里以二叉树为例来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104import java.util.ArrayDeque;public class BinaryTree &#123; static class TreeNode&#123; int value; TreeNode left; TreeNode right; public TreeNode(int value)&#123; this.value=value; &#125; &#125; TreeNode root; public BinaryTree(int[] array)&#123; root=makeBinaryTreeByArray(array,1); &#125; /** * 采用递归的方式创建一颗二叉树 * 传入的是二叉树的数组表示法 * 构造后是二叉树的二叉链表表示法 */ public static TreeNode makeBinaryTreeByArray(int[] array,int index)&#123; if(index&lt;array.length)&#123; int value=array[index]; if(value!=0)&#123; TreeNode t=new TreeNode(value); array[index]=0; t.left=makeBinaryTreeByArray(array,index*2); t.right=makeBinaryTreeByArray(array,index*2+1); return t; &#125; &#125; return null; &#125; /** * 深度优先遍历，相当于先根遍历 * 采用非递归实现 * 需要辅助数据结构：栈 */ public void depthOrderTraversal()&#123; if(root==null)&#123; System.out.println("empty tree"); return; &#125; ArrayDeque&lt;TreeNode&gt; stack=new ArrayDeque&lt;TreeNode&gt;(); stack.push(root); while(stack.isEmpty()==false)&#123; TreeNode node=stack.pop(); System.out.print(node.value+" "); if(node.right!=null)&#123; stack.push(node.right); &#125; if(node.left!=null)&#123; stack.push(node.left); &#125; &#125; System.out.print("\n"); &#125; /** * 广度优先遍历 * 采用非递归实现 * 需要辅助数据结构：队列 */ public void levelOrderTraversal()&#123; if(root==null)&#123; System.out.println("empty tree"); return; &#125; ArrayDeque&lt;TreeNode&gt; queue=new ArrayDeque&lt;TreeNode&gt;(); queue.add(root); while(queue.isEmpty()==false)&#123; TreeNode node=queue.remove(); System.out.print(node.value+" "); if(node.left!=null)&#123; queue.add(node.left); &#125; if(node.right!=null)&#123; queue.add(node.right); &#125; &#125; System.out.print("\n"); &#125; /** * 13 * / \ * 65 5 * / \ \ * 97 25 37 * / /\ / * 22 4 28 32 */ public static void main(String[] args) &#123; int[] arr=&#123;0,13,65,5,97,25,0,37,22,0,4,28,0,0,32,0&#125;; BinaryTree tree=new BinaryTree(arr); tree.depthOrderTraversal(); tree.levelOrderTraversal(); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于栈和队列的了解]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8E%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、栈栈（stack），是一种线性存储结构，它有以下几个特点： (01) 栈中数据是按照”后进先出（LIFO, Last In First Out）”方式进出栈的。 (02) 向栈中添加/删除数据时，只能从栈顶进行操作。 栈通常包括的三种操作：push、peek、pop。 push – 向栈中添加元素。 peek – 返回栈顶元素。 pop – 返回并删除栈顶元素的操作。 1.栈的示意图 栈中的数据依次是 30 –&gt; 20 –&gt; 10 2.出栈 出栈前：栈顶元素是30。此时，栈中的元素依次是 30 –&gt; 20 –&gt; 10 出栈后：30出栈之后，栈顶元素变成20。此时，栈中的元素依次是 20 –&gt; 10 3. 入栈 入栈前：栈顶元素是20。此时，栈中的元素依次是 20 –&gt; 10 入栈后：40入栈之后，栈顶元素变成40。此时，栈中的元素依次是 40 –&gt; 20 –&gt; 10 4.栈的Java实现JDK包中也提供了”栈”的实现，它就是集合框架中的Stack类。 本部分使用数组实现栈，能存储任意类型的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * Java : 数组实现的栈，能存储任意类型的数据 * * @author skywang * @date 2013/11/07 */import java.lang.reflect.Array;public class GeneralArrayStack&lt;T&gt; &#123; private static final int DEFAULT_SIZE = 12; private T[] mArray; private int count; public GeneralArrayStack(Class&lt;T&gt; type) &#123; this(type, DEFAULT_SIZE); &#125; public GeneralArrayStack(Class&lt;T&gt; type, int size) &#123; // 不能直接使用mArray = new T[DEFAULT_SIZE]; mArray = (T[]) Array.newInstance(type, size); count = 0; &#125; // 将val添加到栈中 public void push(T val) &#123; mArray[count++] = val; &#125; // 返回“栈顶元素值” public T peek() &#123; return mArray[count-1]; &#125; // 返回“栈顶元素值”，并删除“栈顶元素” public T pop() &#123; T ret = mArray[count-1]; count--; return ret; &#125; // 返回“栈”的大小 public int size() &#123; return count; &#125; // 返回“栈”是否为空 public boolean isEmpty() &#123; return size()==0; &#125; // 打印“栈” public void PrintArrayStack() &#123; if (isEmpty()) &#123; System.out.printf("stack is Empty\n"); &#125; System.out.printf("stack size()=%d\n", size()); int i=size()-1; while (i&gt;=0) &#123; System.out.println(mArray[i]); i--; &#125; &#125;&#125; 二、队列队列（Queue），是一种线性存储结构。它有以下几个特点：(1) 队列中数据是按照”先进先出（FIFO, First-In-First-Out）”方式进出队列的。(2) 队列只允许在”队首”进行删除操作，而在”队尾”进行插入操作。队列通常包括的两种操作：入队列 和 出队列。 1.队列的示意图 队列中有10，20，30共3个数据。 2.出队列 出队列前：队首是10，队尾是30。 出队列后：出队列(队首)之后。队首是20，队尾是30。 3.入队列 入队列前：队首是20，队尾是30。 入队列后：40入队列(队尾)之后。队首是20，队尾是40。 4.队列的Java实现JDK中的Queue接口就是”队列”，它的实现类也都是队列，用的最多的是LinkedList。本部分使用数组实现队列，能存储任意类型的数据。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Java : 数组实现“队列”，只能存储int数据。 * * @author skywang * @date 2013/11/07 */public class ArrayQueue &#123; private int[] mArray; private int mCount; public ArrayQueue(int sz) &#123; mArray = new int[sz]; mCount = 0; &#125; // 将val添加到队列的末尾 public void add(int val) &#123; mArray[mCount++] = val; &#125; // 返回“队列开头元素” public int front() &#123; return mArray[0]; &#125; // 返回“队首元素值”，并删除“队首元素” public int pop() &#123; int ret = mArray[0]; mCount--; for (int i=1; i&lt;=mCount; i++) mArray[i-1] = mArray[i]; return ret; &#125; // 返回“栈”的大小 public int size() &#123; return mCount; &#125; // 返回“栈”是否为空 public boolean isEmpty() &#123; return size()==0; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于线性表的了解]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%85%B3%E4%BA%8E%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[概要线性表是一种线性结构，它是具有相同类型的n(n≥0)个数据元素组成的有限序列。本章先介绍线性表的几个基本组成部分：数组、单向链表、双向链表。 数组数组有上界和下界，数组的元素在上下界内是连续的。 存储10,20,30,40,50的数组的示意图如下： 数组的特点是：数据是连续的；随机访问速度快。数组中稍微复杂一点的是多维数组和动态数组。对于C语言而言，多维数组本质上也是通过一维数组实现的。至于动态数组，是指数组的容量能动态增长的数组；对于C语言而言，若要提供动态数组，需要手动实现；而对于C++而言，STL提供了Vector；对于Java而言，Collection集合中提供了ArrayList和Vector。 单向链表单向链表(单链表)是链表的一种，它由节点组成，每个节点都包含下一个节点的指针。 单链表的示意图如下： 表头为空，表头的后继节点是”节点10”(数据为10的节点)，”节点10”的后继节点是”节点20”(数据为10的节点)，… 单链表删除节点 删除”节点30” 删除之前：”节点20” 的后继节点为”节点30”，而”节点30” 的后继节点为”节点40”。 删除之后：”节点20” 的后继节点为”节点40”。 单链表添加节点 在”节点10”与”节点20”之间添加”节点15” 添加之前：”节点10” 的后继节点为”节点20”。 添加之后：”节点10” 的后继节点为”节点15”，而”节点15” 的后继节点为”节点20”。 单链表的特点是：节点的链接方向是单向的；相对于数组来说，单链表的的随机访问速度较慢，但是单链表删除/添加数据的效率很高。 双向链表双向链表(双链表)是链表的一种。和单链表一样，双链表也是由节点组成，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。 双链表的示意图如下： 表头为空，表头的后继节点为”节点10”(数据为10的节点)；”节点10”的后继节点是”节点20”(数据为10的节点)，”节点20”的前继节点是”节点10”；”节点20”的后继节点是”节点30”，”节点30”的前继节点是”节点20”；…；末尾节点的后继节点是表头。 双链表删除节点 删除”节点30” 删除之前：”节点20”的后继节点为”节点30”，”节点30” 的前继节点为”节点20”。”节点30”的后继节点为”节点40”，”节点40” 的前继节点为”节点30”。 删除之后：”节点20”的后继节点为”节点40”，”节点40” 的前继节点为”节点20”。 双链表添加节点 在”节点10”与”节点20”之间添加”节点15” 添加之前：”节点10”的后继节点为”节点20”，”节点20” 的前继节点为”节点10”。 添加之后：”节点10”的后继节点为”节点15”，”节点15” 的前继节点为”节点10”。”节点15”的后继节点为”节点20”，”节点20” 的前继节点为”节点15”。 双链表的Java实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134/** * Java 实现的双向链表。 * 注：java自带的集合包中有实现双向链表，路径是:java.util.LinkedList * * @author skywang * @date 2013/11/07 */public class DoubleLink&lt;T&gt; &#123; // 表头 private DNode&lt;T&gt; mHead; // 节点个数 private int mCount; // 双向链表“节点”对应的结构体 private class DNode&lt;T&gt; &#123; public DNode prev; public DNode next; public T value; public DNode(T value, DNode prev, DNode next) &#123; this.value = value; this.prev = prev; this.next = next; &#125; &#125; // 构造函数 public DoubleLink() &#123; // 创建“表头”。注意：表头没有存储数据！ mHead = new DNode&lt;T&gt;(null, null, null); mHead.prev = mHead.next = mHead; // 初始化“节点个数”为0 mCount = 0; &#125; // 返回节点数目 public int size() &#123; return mCount; &#125; // 返回链表是否为空 public boolean isEmpty() &#123; return mCount==0; &#125; // 获取第index位置的节点 private DNode&lt;T&gt; getNode(int index) &#123; if (index&lt;0 || index&gt;=mCount) throw new IndexOutOfBoundsException(); // 正向查找 if (index &lt;= mCount/2) &#123; DNode&lt;T&gt; node = mHead.next; for (int i=0; i&lt;index; i++) node = node.next; return node; &#125; // 反向查找 DNode&lt;T&gt; rnode = mHead.prev; int rindex = mCount - index -1; for (int j=0; j&lt;rindex; j++) rnode = rnode.prev; return rnode; &#125; // 获取第index位置的节点的值 public T get(int index) &#123; return getNode(index).value; &#125; // 获取第1个节点的值 public T getFirst() &#123; return getNode(0).value; &#125; // 获取最后一个节点的值 public T getLast() &#123; return getNode(mCount-1).value; &#125; // 将节点插入到第index位置之前 public void insert(int index, T t) &#123; if (index==0) &#123; DNode&lt;T&gt; node = new DNode&lt;T&gt;(t, mHead, mHead.next); mHead.next.prev = node; mHead.next = node; mCount++; return ; &#125; DNode&lt;T&gt; inode = getNode(index); DNode&lt;T&gt; tnode = new DNode&lt;T&gt;(t, inode.prev, inode); inode.prev.next = tnode; inode.prev = tnode; mCount++; return ; &#125; // 将节点插入第一个节点处。 public void insertFirst(T t) &#123; insert(0, t); &#125; // 将节点追加到链表的末尾 public void appendLast(T t) &#123; DNode&lt;T&gt; node = new DNode&lt;T&gt;(t, mHead.prev, mHead); mHead.prev.next = node; mHead.prev = node; mCount++; &#125; // 删除index位置的节点 public void del(int index) &#123; DNode&lt;T&gt; inode = getNode(index); inode.prev.next = inode.next; inode.next.prev = inode.prev; inode = null; mCount--; &#125; // 删除第一个节点 public void deleteFirst() &#123; del(0); &#125; // 删除最后一个节点 public void deleteLast() &#123; del(mCount-1); &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线性表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内存管理]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、内存连续分配主要是指动态分区分配时所采用的几种算法。动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。 首次适应(First Fit)算法： 空闲分区以地址递增的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。 最佳适应(Best Fit)算法： 空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区。 最坏适应(Worst Fit)算法： 又称最大适应(Largest Fit)算法，空闲分区以容量递减的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。 二、基本分页储存管理方式把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。 因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，因此需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。 由于页表也是存储在内存中的，因此和不适用分页管理的存储方式相比，访问分页系统中内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。 为了减少两次访问内存导致的效率影响，分页管理中引入了快表机制，包含快表机制的内存管理中，当要访问内存数据的时候，首先将页号在快表中查询，如果查找到说明要访问的页表项在快表中，那么直接从快表中读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中(可能存在快表换出算法)。 在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用两级页表或者多级页表的方法，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。 三、基本分段储存管理方式分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。 分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。 访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。由于也是两次内存访问，所以分段管理中同样引入了联想寄存器。 分段分页方式的比较页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制 页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定 四、虚拟内存如果存在一个程序，所需内存空间超过了计算机可以提供的实际内存，那么由于该程序无法装入内存所以也就无法运行。单纯的增加物理内存只能解决一部分问题，但是仍然会出现无法装入单个或者无法同时装入多个程序的问题。但是可以从逻辑的角度扩充内存容量，即可解决上述两种问题。 基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存,然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。 虚拟存储器的特征： 多次性：一个作业可以分多次被调入内存。多次性是虚拟存储特有的属性 对换性：作业运行过程中存在换进换出的过程(换出暂时不用的数据换入需要的数据) 虚拟性：虚拟性体现在其从逻辑上扩充了内存的容量(可以运行实际内存需求比物理内存大的应用程序)。虚拟性是虚拟存储器的最重要特征也是其最终目标。虚拟性建立在多次性和对换性的基础上行，多次性和对换性又建立在离散分配的基础上。 五、页面置换算法最佳置换算法： 只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。 先进先出置换算法： 简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。 最近最久未使用算法LRU： 算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。 时钟算法clock(也被称为是最近未使用算法NRU)： 页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。 改进型Clock算法： 在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。 最少使用算法LFU： 设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。]]></content>
      <categories>
        <category>操作系统</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程与线程]]></title>
    <url>%2F2018%2F06%2F09%2F%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、进程的状态与转换 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。 注意区别就绪状态和等待状态： 就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。 就绪状态 -&gt; 运行状态： 处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。 运行状态 -&gt; 就绪状态： 处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。 运行状态 -&gt; 阻塞状态： 当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。 阻塞状态 -&gt; 就绪状态： 当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。 二、进程与线程的区别进程： 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位（具有动态、并发、独立、异步的特性，以及就绪、执行、阻塞3种状态）；引入进程是为了使多个程序可以并发的执行，以提高系统的资源利用率和吞吐量。 线程： 是比进程更小的可独立运行的基本单位，可以看做是轻量级的进程（具有轻型实体，独立调度分派单位，可并发执行，共享进程资源等属性）；引入目的是为了减少程序在并发执行过程中的开销，使OS的并发效率更高。 两者的对比： 调度方面：在引入线程的OS中，线程是独立的调度和分派单位，而进程作为资源的拥有单位(相当于把未引入线程的传统OS中的进程的两个属性分开了)。由于线程不拥有资源，因此可以显著的提高并发度以及减少切换开销。 并发性：引入了线程的OS中，进程间可以并发，而且一个进程内部的多个线程之间也是可以并发的，这就使OS具有更好的并发性，有效的提高了系统资源利用率和吞吐量。 拥有资源：无论OS是否支持线程，进程都是基本的资源拥有单位，线程只拥有很少的基本的资源，但是线程可以访问所隶属的进程的资源（进程的代码段，数据段和所拥有的系统资源如fd） 系统开销：创建或者撤销进程的时候，系统要为之创建或回收PCB，系统资源等，切换时也需要保存和恢复CPU环境。而线程的切换只需要保存和恢复少量的寄存器，不涉及存储器管理方面的工作，所以开销较小。此外，统一进程中的多个线程由于共享地址空间，所以通信同步等都比较方便。 三、进程通信进程通信是指进程之间的信息交换。PV操作是低级通信方式，髙级通信方式是指以较高的效率传输大量数据的通信方式。高级通信方法主要有以下三个类。 共享存储 在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（如 P操作、V操作），对共享空间的写/读进行控制。共享存储又分为两种：低级方式的共享是基于数据结构的共享；高级方式则是基于存储区的共享。操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。 需要注意的是，用户进程空间一般都是独立的，要想让两个用户进程共享空间必须通过特殊的系统调用实现，而进程内的线程是自然共享进程空间的。 消息传递 在消息传递系统中，进程间的数据交换是以格式化的消息(Message)为单位的。若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程通过系统提供的发送消息和接收消息两个原语进行数据交换。 1) 直接通信方式：发送进程直接把消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。 2) 间接通信方式：发送进程把消息发送到某个中间实体中，接收进程从中间实体中取得消息。这种中间实体一般称为信箱，这种通信方式又称为信箱通信方式。该通信方式广泛应用于计算机网络中，相应的通信系统称为电子邮件系统。 管道通信 管道通信是消息传递的一种特殊方式。所谓“管道”，是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。向管道（共享文件）提供输入的发送进程（即写进程），以字符流形式将大量的数据送入（写）管道；而接收管道输出的接收进程（即读进程），则从管道中接收（读）数据。为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。 四、进程同步多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性 同步机制需要遵循的原则： 空闲让进：当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请 忙则等待：当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问 有限等待：对要求访问临界资源的进程，需要在有限时间内进入临界区，防止出现死等 让权等待：当进程无法进入临界区的时候，需要释放处理机，边陷入忙等 经典的进程同步问题：生产者-消费者问题；哲学家进餐问题；读者-写者问题 同步的解决方案：管程，信号量。 五、用户态和核心态 当程序运行在3级特权级上时，就可以称之为运行在用户态，因为这是最低特权级，是普通的用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态； 反之，当程序运行在级特权级上时，就可以称之为运行在内核态。 虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。 运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。 当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。 用户态切换到内核态的3种方式 1) 系统调用：这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。 2) 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 3) 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 六、死锁死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。 死锁原因： 竞争资源：请求同一有限资源的进程数多于可用资源数 进程推进顺序非法：进程执行中，请求和释放资源顺序不合理，如资源等待链 死锁产生的必要条件： 互斥条件:进程对所分配的资源进行排他性的使用 请求和保持条件：进程被阻塞的时候并不释放锁申请到的资源 不可剥夺条件：进程对于已经申请到的资源在使用完成之前不可以被剥夺 环路等待条件：发生死锁的时候存在的一个 进程-资源 环形等待链 死锁处理： 预防死锁：破坏产生死锁的4个必要条件中的一个或者多个；实现起来比较简单，但是如果限制过于严格会降低系统资源利用率以及吞吐量 避免死锁：在资源的动态分配中，防止系统进入不安全状态(可能产生死锁的状态)-如银行家算法 检测死锁：允许系统运行过程中产生死锁，在死锁发生之后，采用一定的算法进行检测，并确定与死锁相关的资源和进程，采取相关方法清除检测到的死锁。实现难度大 解除死锁：与死锁检测配合，将系统从死锁中解脱出来（撤销进程或者剥夺资源）。对检测到的和死锁相关的进程以及资源，通过撤销或者挂起的方式，释放一些资源并将其分配给处于阻塞状态的进程，使其转变为就绪态。实现难度大 七、进程调度算法先来先服务调度算法FCFS： 既可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度；因此对于长作业比较有利； 短作业优先调度算法SJF： 作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ； 高响应比算法HRN： 响应比=(等待时间+要求服务时间)/要求服务时间； 时间片轮转调度RR： 按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ; 多级反馈队列调度算法： 目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部……只有当前一个队列为空的时候才会去调度下一个队列的进程。]]></content>
      <categories>
        <category>操作系统</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[操作系统这一块内容比较晦涩枯燥，如果系统学起来需要耗费很长时间。针对于面试，本章内容整理了一些面试重难点问题，大致分为3块内容，18个问题。 一、操作系统知识点图谱二、面试问题总结 操作系统的四个特性。 操作系统的主要功能。 进程的有哪几种状态，状态转换图，及导致转换的事件。 进程与线程的区别。 进程通信的几种方式。 进程同步的几种方式 用户态和核心态的区别。 死锁的概念，导致死锁的原因. 导致死锁的四个必要条件。 处理死锁的四个方式。 预防死锁的方法、避免死锁的方法。 进程调度算法。 内存连续分配方式采用的几种算法及各自优劣。 基本分页储存管理方式。 基本分段储存管理方式。 分段分页方式的比较各自优缺点。 几种页面置换算法，会算所需换页数 虚拟内存的定义及实现方式。 三、 概述1.操作系统的四个特性并发： 同一段时间内多个程序执行(注意区别并行和并发，前者是同一时刻的多个事件，后者是同一时间段内的多个事件)共享： 系统中的资源可以被内存中多个并发执行的进线程共同使用虚拟： 通过时分复用（如分时系统）以及空分复用（如虚拟内存）技术实现把一个物理实体虚拟为多个异步： 系统中的进程是以走走停停的方式执行的，且以一种不可预知的速度推进 2.操作系统的主要功能处理机管理： 处理机分配都是以进程为单位，所以处理机管理也被看做是进程管理。包括进程控制，进程同步，进程通信和进程调度存储器管理（或者内存管理）： 内存分配，内存保护，地址映射，内存扩充设备管理： 管理所有外围设备，包括完成用户的IO请求；为用户进程分配IO设备；提高IO设备利用率；提高IO速度；方便IO的使用文件管理： 管理用户文件和系统文件，方便使用同时保证安全性。包括：磁盘存储空间管理，目录管理，文件读写管理以及文件共享和保护提供用户接口： 程序接口（如API）和用户接口（如GUI）]]></content>
      <categories>
        <category>操作系统</category>
        <category>面经</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android系统架构]]></title>
    <url>%2F2018%2F06%2F09%2FAndroid%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Android源码目录结构摘自：刘望舒博客 一.Android系统架构Android系统架构分为五层，从上到下依次是应用层、应用框架层、系统运行库层、硬件抽象层和Linux内核层。 应用层系统内置的应用程序以及非系统级的应用程序都是属于应用层。负责与用户进行直接交互，通常都是用Java进行开发的。 应用框架层（Java Framework)应用框架层为开发人员提供了可以开发应用程序所需要的API，我们平常开发应用程序都是调用的这一层所提供的API，当然也包括系统的应用。这一层的是由Java代码编写的，可以称为Java Framework。下面来看这一层所提供的主要的组件。 名称 功能描述 Activity Manager(活动管理器) 管理各个应用程序生命周期以及通常的导航回退功能 Location Manager(位置管理器) 提供地理位置以及定位功能服务 Package Manager(包管理器) 管理所有安装在Android系统中的应用程序 Notification Manager(通知管理器) 使得应用程序可以在状态栏中显示自定义的提示信息 Resource Manager（资源管理器） 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephony Manager(电话管理器) 管理所有的移动设备功能 Window Manager（窗口管理器） 管理所有开启的窗口程序 Content Providers（内容提供器） 使得不同应用程序之间可以共享数据 View System（视图系统） 构建应用程序的基本组件 表1 系统运行库层（Native)系统运行库层分为两部分，分别是C/C++程序库和Android运行时库。下面分别来介绍它们。 1.C/C++程序库C/C++程序库能被Android系统中的不同组件所使用，并通过应用程序框架为开发者提供服务，主要的C/C++程序库如下表2所示。 名称 功能描述 OpenGL ES 3D绘图函数库 Libc 从BSD继承来的标准C系统函数库，专门为基于嵌入式Linux的设备定制 Media Framework 多媒体库，支持多种常用的音频、视频格式录制和回放。 SQLite 轻型的关系型数据库引擎 SGL 底层的2D图形渲染引擎 SSL 安全套接层，是为网络通信提供安全及数据完整性的一种安全协议 FreeType 可移植的字体引擎，它提供统一的接口来访问多种字体格式文件 表2 2.Android运行时库运行时库又分为核心库和ART(5.0系统之后，Dalvik虚拟机被ART取代)。核心库提供了Java语言核心库的大多数功能，这样开发者可以使用Java语言来编写Android应用。相较于JVM，Dalvik虚拟机是专门为移动设备定制的，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik 应用作为一个独立的Linux 进程执行。独立的进程可以防止在虚拟机崩溃的时候所有程序都被关闭。而替代Dalvik虚拟机的ART 的机制与Dalvik 不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这会拖慢应用的运行效率，而在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。 硬件抽象层（HAL)硬件抽象层是位于操作系统内核与硬件电路之间的接口层，其目的在于将硬件抽象化，为了保护硬件厂商的知识产权，它隐藏了特定平台的硬件接口细节，为操作系统提供虚拟硬件平台，使其具有硬件无关性，可在多种平台上进行移植。 从软硬件测试的角度来看，软硬件的测试工作都可分别基于硬件抽象层来完成，使得软硬件测试工作的并行进行成为可能。通俗来讲，就是将控制硬件的动作放在硬件抽象层中。 Linux内核层Android 的核心系统服务基于Linux 内核，在此基础上添加了部分Android专用的驱动。系统的安全性、内存管理、进程管理、网络协议栈和驱动模型等都依赖于该内核。Android系统的五层架构就讲到这，了解以上的知识对以后分析系统源码有很大的帮助。 二.Android系统源码目录我们要先了解Android系统源码目录，为后期源码学习打下基础。关于源码的阅读，你可以访问http://androidxref.com/来阅读系统源码。当然，最好是将源码下载下来。下载源码可以使用清华大学开源软件镜像站提供的Android 镜像：https://mirrors.tuna.tsinghua.edu.cn/help/AOSP/ 。如果觉得麻烦也可以查找国内的网盘进行下载，推荐使用该百度网盘地址下载：http://pan.baidu.com/s/1ngsZs，它提供了多个Android版本的的源码下载。 整体结构各个版本的源码目录基本是类似，如果是编译后的源码目录会多增加一个out文件夹，用来存储编译产生的文件。Android7.0的根目录结构说明如下表所示。 Android源码根目录 描述 abi 应用程序二进制接口 art 全新的ART运行环境 bionic 系统C库 bootable 启动引导相关代码 build 存放系统编译规则及generic等基础开发包配置 cts Android兼容性测试套件标准 dalvik dalvik虚拟机 developers 开发者目录 development 应用程序开发相关 device 设备相关配置 docs 参考文档目录 external 开源模组相关文件 frameworks 应用程序框架，Android系统核心部分，由Java和C++编写 hardware 主要是硬件抽象层的代码 libcore 核心库相关文件 libnativehelper 动态库，实现JNI库的基础 ndk NDK相关代码，帮助开发人员在应用程序中嵌入C/C++代码 out 编译完成后代码输出在此目录 packages 应用程序包 pdk Plug Development Kit 的缩写，本地开发套件 platform_testing 平台测试 prebuilts x86和arm架构下预编译的一些资源 sdk sdk和模拟器 system 底层文件系统库、应用和组件 toolchain 工具链文件 tools 工具文件 Makefile 全局Makefile文件，用来定义编译规则 表3 从表3可以看出，系统源码分类清晰，并且内容庞大且复杂。接下来分析packages中的内容，也就是应用层部分。 应用层部分应用层位于整个Android系统的最上层，开发者开发的应用程序以及系统内置的应用程序都是在应用层。源码根目录中的packages目录对应着系统应用层。它的目录结构如表4所示。 packages目录 描述 apps 核心应用程序 experimental 第三方应用程序 inputmethods 输入法目录 providers 内容提供者目录 screensavers 屏幕保护 services 通信服务 wallpapers 墙纸 表4从目录结构可以发现，packages目录存放着系统核心应用程序、第三方的应用程序和输入法等等，这些应用都是运行在系统应用层的，因此packages目录对应着系统的应用层。### 应用框架层部分应用框架层是系统的核心部分，一方面向上提供接口给应用层调用，另一方面向下与C/C++程序库以及硬件抽象层等进行衔接。 应用框架层的主要实现代码在/frameworks/base和/frameworks/av目录下，其中/frameworks/base目录结构如表5所示。/frameworks/base目录 |描述| /frameworks/base目录 |描述|–|–|–|–||api| 定义API| cmds| 重要命令：am、app_proce等|core| 核心库 |data |字体和声音等数据文件|docs| 文档 |graphics| 图形图像相关|include| 头文件| keystore| 和数据签名证书相关|libs |库| location| 地理位置相关库||media |多媒体相关库| native| 本地库||nfc-extras| NFC相关| obex| 蓝牙传输||opengl 2D/3D| 图形API| packages| 设置、TTS、VPN程序||sax| XML解析器| services |系统服务||telephony| 电话通讯管理 |test-runner| 测试工具相关||tests| 测试相关| tools| 工具||wifi| wifi无线网络|表5### C/C++程序库部分系统运行库层（Native)中的 C/C++程序库的类型繁多，功能强大，C/C++程序库并不完全在一个目录中，这里给出几个常用且比较重要的C/C++程序库所在的目录位置。|目录位置| 描述||–|–||bionic/ |Google开发的系统C库，以BSD许可形式开源。||/frameworks/av/media| 系统媒体库||/frameworks/native/opengl| 第三方图形渲染库||/frameworks/native/services/surfaceflinger| 图形显示库，主要负责图形的渲染、叠加和绘制等功能||external/sqlite |轻量型关系数据库SQLite的C++实现|表6 讲完 C/C++程序库部分，剩下的部分我们在表3已经给出：Android运行时库的代码放在art/目录中。硬件抽象层的代码在hardware/目录中，这一部分是手机厂商改动最大的一部分，根据手机终端所采用的硬件平台会有不同的实现。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM怎么判断对象是否已死？]]></title>
    <url>%2F2018%2F06%2F09%2FJVM%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%B7%B2%E6%AD%BB%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[一、引用计数法给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能被再使用的。 主流的JVM里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象间的互循环引用的问题。 二、可达性分析算法通过一些列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时（就是从GC Roots 到这个对象是不可达），则证明此对象是不可用的。所以它们会被判定为可回收对象（例如图B中的对象既是不可达的）。 在Java语言中，可以作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中JNI（即一般说的Native方法）引用的对象； 总结就是，方法运行时，方法中引用的对象；类的静态变量引用的对象；类中常量引用的对象；Native方法中引用的对象 在可达性分析算法中，要真正宣告一个对象死亡，至少要经历两次标记过程： 1.如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有 覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 2.如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。finalize()方法是对象逃脱死亡命运的最后一次机会，稍候GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalie()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将会被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。 三、判断对象是否存活与“引用”有关在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）四种，这四种引用强度依次逐渐减弱。 强引用：就是指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述一些还有用但并非必须的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。 弱引用：用户描述非必须对象的。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 虚引用：一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时刻得到一个系统通知。]]></content>
      <categories>
        <category>Java</category>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM中垃圾收集算法及垃圾收集器详解]]></title>
    <url>%2F2018%2F06%2F09%2FJVM%E4%B8%AD%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E5%8F%8A%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、垃圾收集算法1.标记-清除算法最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段。 ①首先标记出所有需要回收的对象 ②在标记完成后统一回收所有被标记的对象。 不足： 效率问题：标记和清除两个过程的效率都不高 空间问题：标记清除之后产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 2.复制算法目的：为了解决效率问题。 将可用内存按容量大小划分为大小相等的两块，每次只使用其中的一块。当一块内存使用完了，就将还存活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况。 缺点：将内存缩小为了原来的一半。 现代的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中对象98%对象是“朝生夕死”的，所以不需要按照1：1的比例来划分内存空间，而是将内存分为较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。HotSpot虚拟机中默认Eden和Survivor的大小比例是8：1。 3.标记-整理算法复制收集算法在对象存活率较高时，就要进行较多的复制操作，效率就会变低。根据老年代的特点，提出了”标记-整理“算法。标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。 4.分代收集算法一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法。 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清除”或“标记-整理”算法来进行回收。 二、垃圾回收机制的一些知识1.JVM中的年代JVM中分为年轻代（Young generation）和老年代(Tenured generation)。 HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。 一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。 2.Minor GC和Full GC的区别Minor GC:指发生在新生代的垃圾收集动作，该动作非常频繁。 Full GC/Major GC:指发生在老年代的垃圾收集动作，出现了Major GC，经常会伴随至少一次的Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。 3. 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间，如果这个条件成立，那么Minor GC可以 确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，则将尝试进行一次Minor GC，尽管这个Minor GC是有风险的。如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 以上便是在垃圾回收过程中，需要了解的一些必要的知识。下面我们就来介绍具体的垃圾收集器。 三、垃圾收集器上图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，说明它们可以搭配使用。 1.Serial收集器 是最基本、发展历史最悠久的收集器。这是一个单线程收集器。但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 是虚拟机运行在Client模式下的默认新生代收集器。 优势：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程效率。 2.ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。 是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。 ParNew收集器默认开启的收集线程数与CPU的数量相同。下图是ParNew/Serial Old收集器运行示意图 3.Parallel Scavenge收集器Parallel Scavenge收集器是一个新生代收集器，使用复制算法，又是并行的多线程收集器。 最大的特点是：Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）。 高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。 4.Serial Old收集器Serial Old是Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下虚拟机使用。 如果在Server模式下，它主要还有两大用途： 1.与Parallel Scavenge收集器搭配使用 2.作为CMS收集器的后备预案，在并发收集发生Conurrent Mode Failure使用。 5.Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。 在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge+Parallel Old收集器 6.CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。 关注点：尽可能地缩短垃圾收集时用户线程的停顿时间。 CMS收集器是基于“标记-清除”算法实现的，整个过程分为4个步骤： ①初始标记 ②并发标记 ③重新标记 ④并发清除 其中，初始标记，重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只标记一下GC Roots能直接关联到的对象，速度很快。并发标记阶段就是 进行GC Roots Tracing的过程。 重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记几率，这个阶段的停顿时间一般会比初始标记阶段稍长，但远比并发标记时间短。 整个过程耗时最长的阶段是并发标记，并发清除过程，但这两个过程可以和用户线程一起工作。 缺点： ①CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。 ②CMS收集器无法处理浮动垃圾，可能出现“Conurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会产生新的垃圾，这一部分垃圾出现在标记过程之后，CMS无法在档次收集中处理掉它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时程序运作使用。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活。如果预留空间无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案Serial Old。 ③CMS是一款基于“标记-清除”算法实现的收集器，所以会有大量空间碎片问题。 7.G1收集器是当今收集器技术发展的最前沿成果之一。是一款面向服务端应用的垃圾收集器。特点： ①并行与并发 能充分利用多CPU，多核环境下的硬件优势，缩短Stop-The-World停顿的时间，同时可以通过并发的方式让Java程序继续执行 ②分代收集 可以不需要其他收集器的配合管理整个堆，但是仍采用不同的方式去处理分代的对象。 ③空间整合 G1从整体上来看，采用基于“标记-整理”算法实现收集器 G1从局部上来看，采用基于“复制”算法实现。 ④可预测停顿 使用G1收集器时，Java堆内存布局与其他收集器有很大差别，它将整个Java堆划分成为多个大小相等的独立区域。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。]]></content>
      <categories>
        <category>Java</category>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java类加载机制及类加载器详解]]></title>
    <url>%2F2018%2F06%2F09%2FJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E5%8F%8A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、类加载机制###1.定义：把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。在Java语言里，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的。 ###2.类的生命周期：加载，验证，准备，解析，初始化，使用和卸载。其中验证，准备，解析3个部分统称为连接。 这7个阶段发生顺序如下图： 加载，验证，准备，初始化，卸载这5个阶段的顺序是确定的，而解析阶段则不一定：它在某些情况下可以在初始化完成后在开始，这是为了支持Java语言的运行时绑定。 其中加载，验证，准备，解析及初始化是属于类加载机制中的步骤。注意此处的加载不等同于类加载。 3.触发类加载的条件：①.遇到new,getstatic,putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段的时候（被final修饰，已在编译期把结果放入常量池的静态字段除外），以及调用一个类的静态方法的时候。 ②.使用java.lang.reflect包的方法对类进行反射调用的时候。 ③.当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。 ④.当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 ⑤.当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出发初始化。 4.类加载的具体过程：加载: ①.通过一个类的全限定名来获取定义此类的二进制字节流 ②.将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构 ③.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 验证： 是连接阶段的第一步，目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 包含四个阶段的校验动作 a.文件格式验证 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。 b.元数据验证 对类的元数据信息进行语义校验，是否不存在不符合Java语言规范的元数据信息 c.字节码验证 最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 d.符号引用验证 最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生。 符号验证的目的是确保解析动作能正常进行。 准备： 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值“通常情况”下是数据类型的零值。 “特殊情况”下，如果类字段的字段属性表中存在ConstantValue属性，那么在准备阶段变量的值就会被初始化为ConstantValue属性所指定的值。 解析： 虚拟机将常量池内的符号引用替换为直接引用的过程。 “动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。 初始化： 类加载过程中的最后一步。 初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。 &lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。 ()与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。 简单地说，初始化就是对类变量进行赋值及执行静态代码块。 二、类加载器通过上述的了解，我们已经知道了类加载机制的大概流程及各个部分的功能。其中加载部分的功能是将类的class文件读入内存，并为之创建一个java.lang.Class对象。这部分功能就是由类加载器来实现的。 1.类加载器分类：不同的类加载器负责加载不同的类。主要分为两类。 启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中，即负责加载Java的核心类。 其他类加载器：由Java语言实现，继承自抽象类ClassLoader。如： 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库，即负责加载Java扩展的核心类之外的类。 应用程序类加载器（Application ClassLoader）：负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器，通过ClassLoader.getSystemClassLoader()方法直接获取。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。 以上2大类，3小类类加载器基本上负责了所有Java类的加载。下面我们来具体了解上述几个类加载器实现类加载过程时相互配合协作的流程。 2.双亲委派模型 双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 这样的好处是不同层次的类加载器具有不同优先级，比如所有Java对象的超级父类java.lang.Object，位于rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个java.lang.Object类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。 3.双亲委派模型的代码实现ClassLoader中loadClass方法实现了双亲委派模型123456789101112131415161718192021222324252627282930313233343536373839protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; //检查该类是否已经加载过 Class c = findLoadedClass(name); if (c == null) &#123; //如果该类没有加载，则进入该分支 long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; //当父类的加载器不为空，则通过父类的loadClass来加载该类 c = parent.loadClass(name, false); &#125; else &#123; //当父类的加载器为空，则调用启动类加载器来加载该类 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; //非空父类的类加载器无法找到相应的类，则抛出异常 &#125; if (c == null) &#123; //当父类加载器无法加载时，则调用findClass方法来加载该类 long t1 = System.nanoTime(); c = findClass(name); //用户可通过覆写该方法，来自定义类加载器 //用于统计类加载器相关的信息 sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; //对类进行link操作 resolveClass(c); &#125; return c; &#125;&#125; 整个流程大致如下： a.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。 b.如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。 c.如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。 关于自定义类加载器，本篇文章就不介绍了，主要是重写findClass方法，有兴趣的可以参考这篇文章。]]></content>
      <categories>
        <category>Java</category>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存区域与内存模型]]></title>
    <url>%2F2018%2F06%2F09%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、Java内存区域方法区（公有）：用户存储已被虚拟机加载的类信息，常量，静态常量，即时编译器编译后的代码等数据。异常状态 OutOfMemoryError 其中包含常量池：用户存放编译器生成的各种字面量和符号引用。 堆（公有）：是JVM所管理的内存中最大的一块。唯一目的就是存放实例对象，几乎所有的对象实例都在这里分配。Java堆是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。异常状态 OutOfMemoryError 虚拟机栈（线程私有）：描述的是java方法执行的内存模型：每个方法在执行时都会创建一个栈帧，用户存储局部变量表，操作数栈，动态连接，方法出口等信息。每一个方法从调用直至完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 对这个区域定义了两种异常状态 OutOfMemoryError StackOverflowError 本地方法栈（线程私有）:与虚拟机栈所发挥的作用相似。它们之间的区别不过是虚拟机栈为虚拟机执行java方法，而本地方法栈为虚拟机使用到的Native方法服务。 程序计数器（线程私有）：一块较小的内存，当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。 二、Java内存模型Java内存模型的目的：屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的内存访问效果。 主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java变成中所说的变量是有所区别，它包括了实例字段，静态字段和构成数组对象的元素，但不包括局部变量和方法参数。 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8种操作来完成，并且每种操作都是原子的、不可再分的。 八种操作：lock：作用于主内存的变量，把一个变量标识为一条线程独占的状态 unlock：作用于主内存的变量，把一个处于锁定状态的变量释放出来。 read：把一个变量的值从主内存传输到工作内存中，以便随后的load使用。 load：把read操作从主内存中得到的变量值放入到工作内存的变量副本中。 use：把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign：把一个从执行引擎中接收到的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store：把工作内存中的一个变量的值传递到主内存，以便随后的write使用。 write:把store操作从工作内存中得到的变量值放入到主内存的变量中。]]></content>
      <categories>
        <category>Java</category>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象的创建、内存布局和访问定位]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E8%AE%BF%E9%97%AE%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[一、对象的创建1.虚拟机遇到一个new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用 2.检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行响应的类加载过程 3.在类加载检查功通过后，为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定。 二、对象的内存布局分为3个区域：对象头，实例数据，对齐填充。 对象头：包括两部分信息，第一部分：对象自身的运行时数据，如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32 bit和64 bit，官方称它为“Mark Word”。 第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那在对象头中还必须有一块用于记录数组长度的数据。 实例数据：是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。 对齐填充：对齐填充不是必然存在的。HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的整数倍。因此，当对象实例数据部分没有对齐时，就需要通过对其补充来补全了。 三、对象的访问定位Java程序需要通过栈上了reference数据来操作堆上的具体对象。 目前主流的访问方式有使用句柄和直接指针两种。 句柄访问：Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对实例数据与类型数据的各自具体的地址信息。 直接指针访问：reference中存储的直接就是对象地址。]]></content>
      <categories>
        <category>Java</category>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发集合—/ConcurrentHashMap]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E2%80%94ConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[前言 HashMap是我们平时开发过程中用的比较多的集合，但它是非线程安全的，在涉及到多线程并发的情况，进行put操作有可能会引起死循环，导致CPU利用率接近100%。 123456789final HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(2);for (int i = 0; i &lt; 10000; i++) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; map.put(UUID.randomUUID().toString(), ""); &#125; &#125;).start();&#125; 解决方案有Hashtable和Collections.synchronizedMap(hashMap)，不过这两个方案基本上是对读写进行加锁操作，一个线程在读写元素，其余线程必须等待，性能可想而知。 所以，Doug Lea给我们带来了并发安全的ConcurrentHashMap，它的实现是依赖于 Java 内存模型，所以我们在了解 ConcurrentHashMap 的之前必须了解一些底层的知识： java内存模型 java中的CAS AbstractQueuedSynchronizer ReentrantLock 本文源码是JDK8的版本，与之前的版本有较大差异。 JDK1.6分析ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层采用数组+链表+红黑树的存储结构。其包含两个核心静态内部类 Segment和HashEntry。 Segment继承ReentrantLock用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶。 HashEntry 用来封装映射表的键 / 值对； 每个桶是由若干个 HashEntry 对象链接起来的链表。 一个 ConcurrentHashMap 实例中包含由若干个 Segment 对象组成的数组，下面我们通过一个图来演示一下 ConcurrentHashMap 的结构： JDK1.8分析1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。 重要概念在开始之前，有些重要的概念需要介绍一下： table：默认为null，初始化发生在第一次插入操作，默认大小为16的数组，用来存储Node节点数据，扩容时大小总是2的幂次方。 nextTable：默认为null，扩容时新生成的数组，其大小为原数组的两倍。 sizeCtl ：默认为0，用来控制table的初始化和扩容操作，具体应用在后续会体现出来。 -1 代表table正在初始化 -N 表示有N-1个线程正在进行扩容操作 其余情况：1、如果table未初始化，表示table需要初始化的大小。2、如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n &gt;&gt;&gt; 2)）。 Node ：保存key，value及key的hash值的数据结构。 1234567class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; ... 省略部分代码&#125; 其中value和next都用volatile修饰，保证并发的可见性。 ForwardingNode ：一个特殊的Node节点，hash值为-1，其中存储nextTable的引用。 1234567final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; final Node&lt;K,V&gt;[] nextTable; ForwardingNode(Node&lt;K,V&gt;[] tab) &#123; super(MOVED, null, null, null); this.nextTable = tab; &#125;&#125; 只有table发生扩容的时候，ForwardingNode才会发挥作用，作为一个占位符放在table中表示当前节点为null或则已经被移动。 实例初始化实例化ConcurrentHashMap时带参数时，会根据参数调整table的大小，假设参数为100，最终会调整成256，确保table的大小总是2的幂次方，算法如下： 12345678910ConcurrentHashMap&lt;String, String&gt; hashMap = new ConcurrentHashMap&lt;&gt;(100);private static final int tableSizeFor(int c) &#123; int n = c - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 注意，ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。 table初始化前面已经提到过，table初始化操作会延缓到第一次put行为。但是put是可以并发执行的，Doug Lea是如何实现table只初始化一次的？让我们来看看源码的实现。 1234567891011121314151617181920212223private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123;//如果一个线程发现sizeCtl&lt;0，意味着另外的线程执行CAS操作成功，当前线程只需要让出cpu时间片 if ((sc = sizeCtl) &lt; 0) Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125; sizeCtl默认为0，如果ConcurrentHashMap实例化时有传参数，sizeCtl会是一个2的幂次方的值。所以执行第一次put操作的线程会执行Unsafe.compareAndSwapInt方法修改sizeCtl为-1，有且只有一个线程能够修改成功，其它线程通过Thread.yield()让出CPU时间片等待table初始化完成。 put操作假设table已经初始化完成，put操作采用CAS+synchronized实现并发插入或更新操作，具体实现如下。 12345678910111213141516171819final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); ...省略部分代码 &#125; addCount(1L, binCount); return null;&#125; hash算法 1static final int spread(int h) &#123;return (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS;&#125; table中定位索引位置，n是table的大小 1int index = (n - 1) &amp; hash 获取table中对应索引的元素f。Doug Lea采用Unsafe.getObjectVolatile来获取，也许有人质疑，直接table[index]不可以么，为什么要这么复杂？在java内存模型中，我们已经知道每个线程都有一个工作内存，里面存储着table的副本，虽然table是volatile修饰的，但不能保证线程每次都拿到table中的最新元素，Unsafe.getObjectVolatile可以直接获取指定内存的数据，保证了每次拿到数据都是最新的。 如果f为null，说明table中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject方法插入Node节点。 如果CAS成功，说明Node节点已经插入，随后addCount(1L, binCount)方法会检查当前容量是否需要进行扩容。 如果CAS失败，说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点。 如果f的hash值为-1，说明当前f是ForwardingNode节点，意味有其它线程正在扩容，则一起进行扩容操作。 其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发，代码如下: 12345678910111213141516171819202122232425262728293031323334synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125;&#125; 在节点f上进行同步，节点插入之前，再次利用tabAt(tab, i) == f判断，防止被其它线程修改。 如果f.hash &gt;= 0，说明f是链表结构的头结点，遍历链表，如果找到对应的node节点，则修改value，否则在链表尾部加入节点。 如果f是TreeBin类型节点，说明f是红黑树根节点，则在树结构上遍历元素，更新或增加节点。 如果链表中节点数binCount &gt;= TREEIFY_THRESHOLD(默认是8)，则把链表转化为红黑树结构。 table扩容当table容量不足的时候，即table的元素数量达到容量阈值sizeCtl，需要对table进行扩容。整个扩容分为两部分： 构建一个nextTable，大小为table的两倍。 把table的数据复制到nextTable中。 这两个过程在单线程下实现很简单，但是ConcurrentHashMap是支持并发插入的，扩容操作自然也会有并发的出现，这种情况下，第二步可以支持节点的并发复制，这样性能自然提升不少，但实现的复杂度也上升了一个台阶。 先看第一步，构建nextTable，毫无疑问，这个过程只能只有单个线程进行nextTable的初始化，具体实现如下： 12345678910111213141516171819202122private final void addCount(long x, int check) &#123; ... 省略部分代码 if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125;&#125; 通过Unsafe.compareAndSwapInt修改sizeCtl值，保证只有一个线程能够初始化nextTable，扩容后的数组长度为原来的两倍，但是容量是原来的1.5。 节点从table移动到nextTable，大体思想是遍历、复制的过程。 首先根据运算得到需要遍历的次数i，然后利用tabAt方法获得i位置的元素f，初始化一个forwardNode实例fwd。 如果f == null，则在table中的i位置放入fwd，这个过程是采用Unsafe.compareAndSwapObjectf方法实现的，很巧妙的实现了节点的并发移动。 如果f是链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上，移动完成，采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。 如果f是TreeBin节点，也做一个反序处理，并判断是否需要untreeify，把处理的结果分别放在nextTable的i和i+n的位置上，移动完成，同样采用Unsafe.putObjectVolatile方法给table原位置赋值fwd。 遍历过所有的节点以后就完成了复制工作，把table指向nextTable，并更新sizeCtl为新数组大小的0.75倍 ，扩容完成。 红黑树构造注意：如果链表结构中元素超过TREEIFY_THRESHOLD阈值，默认为8个，则把链表转化为红黑树，提高遍历查询效率。 1234567if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break;&#125; 接下来我们看看如何构造树结构，代码如下： 12345678910111213141516171819202122232425private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) &#123; Node&lt;K,V&gt; b; int n, sc; if (tab != null) &#123; if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY) tryPresize(n &lt;&lt; 1); else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) &#123; synchronized (b) &#123; if (tabAt(tab, index) == b) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; for (Node&lt;K,V&gt; e = b; e != null; e = e.next) &#123; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val, null, null); if ((p.prev = tl) == null) hd = p; else tl.next = p; tl = p; &#125; setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd)); &#125; &#125; &#125; &#125;&#125; 可以看出，生成树节点的代码块是同步的，进入同步代码块之后，再次验证table中index位置元素是否被修改过。1、根据table中index位置Node链表，重新生成一个hd为头结点的TreeNode链表。2、根据hd头结点，生成TreeBin树结构，并把树结构的root节点写到table的index位置的内存中，具体实现如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243TreeBin(TreeNode&lt;K,V&gt; b) &#123; super(TREEBIN, null, null, null); this.first = b; TreeNode&lt;K,V&gt; r = null; for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (r == null) &#123; x.parent = null; x.red = false; r = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = r;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; r = balanceInsertion(r, x); break; &#125; &#125; &#125; &#125; this.root = r; assert checkInvariants(root);&#125; 主要根据Node节点的hash值大小构建二叉树。这个红黑树的构造过程实在有点复杂，感兴趣的同学可以看看源码。 get操作get操作和put操作相比，显得简单了许多。 12345678910111213141516171819public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; 判断table是否为空，如果为空，直接返回null。 计算key的hash值，并获取指定table中指定位置的Node节点，通过遍历链表或则树结构找到对应的节点，返回value值。 总结ConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发集合—/LinkedBlockingQueue]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E2%80%94LinkedBlockingQueue%2F</url>
    <content type="text"><![CDATA[前言在前面的文章ArrayBlockingQueue中，已经对JDK中的BlockingQueue中的做了一个回顾，同时对ArrayBlockingQueue中的核心方法作了说明，而LinkedBlockingQueue作为JDK中BlockingQueue家族系列中一员，由于其作为固定大小线程池(Executors.newFixedThreadPool())底层所使用的阻塞队列，分析它的目的主要在于2点： 与ArrayBlockingQueue进行类比学习，加深各种数据结构的理解 了解底层实现，能够更好地理解每一种阻塞队列对线程池性能的影响，做到真正的知其然，且知其所以然 源码分析LinkedBlockingQueue的实现 与ArrayBlockingQueue进行比较 说明为什么选择LinkedBlockingQueue作为固定大小的线程池的阻塞队列 LinkedBlockingQueue深入分析LinkedBlockingQueue，见名之意，它是由一个基于链表的阻塞队列，首先看一下的核心组成： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 所有的元素都通过Node这个静态内部类来进行存储，这与LinkedList的处理方式完全一样static class Node&lt;E&gt; &#123; //使用item来保存元素本身 E item; //保存当前节点的后继节点 Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125;&#125;/** 阻塞队列所能存储的最大容量 用户可以在创建时手动指定最大容量,如果用户没有指定最大容量 那么最默认的最大容量为Integer.MAX_VALUE.*/private final int capacity;/** 当前阻塞队列中的元素数量 PS:如果你看过ArrayBlockingQueue的源码,你会发现 ArrayBlockingQueue底层保存元素数量使用的是一个 普通的int类型变量。其原因是在ArrayBlockingQueue底层 对于元素的入队列和出队列使用的是同一个lock对象。而数 量的修改都是在处于线程获取锁的情况下进行操作，因此不 会有线程安全问题。 而LinkedBlockingQueue却不是，它的入队列和出队列使用的是两个 不同的lock对象,因此无论是在入队列还是出队列，都会涉及对元素数 量的并发修改，(之后通过源码可以更加清楚地看到)因此这里使用了一个原子操作类 来解决对同一个变量进行并发修改的线程安全问题。*/private final AtomicInteger count = new AtomicInteger(0);/** * 链表的头部 * LinkedBlockingQueue的头部具有一个不变性: * 头部的元素总是为null，head.item==null */private transient Node&lt;E&gt; head;/** * 链表的尾部 * LinkedBlockingQueue的尾部也具有一个不变性: * 即last.next==null */private transient Node&lt;E&gt; last;/** 元素出队列时线程所获取的锁 当执行take、poll等操作时线程需要获取的锁*/private final ReentrantLock takeLock = new ReentrantLock();/**当队列为空时，通过该Condition让从队列中获取元素的线程处于等待状态*/private final Condition notEmpty = takeLock.newCondition();/** 元素入队列时线程所获取的锁 当执行add、put、offer等操作时线程需要获取锁*/private final ReentrantLock putLock = new ReentrantLock();/** 当队列的元素已经达到capactiy，通过该Condition让元素入队列的线程处于等待状态*/private final Condition notFull = putLock.newCondition(); 通过上面的分析，我们可以发现LinkedBlockingQueue在入队列和出队列时使用的不是同一个Lock，这也意味着它们之间的操作不会存在互斥操作。在多个CPU的情况下，它们可以做到真正的在同一时刻既消费、又生产，能够做到并行处理。 下面让我们看下LinkedBlockingQueue的构造方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 如果用户没有显示指定capacity的值，默认使用int的最大值 */public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE);&#125;/** 可以看到,当队列中没有任何元素的时候,此时队列的头部就等于队列的尾部, 指向的是同一个节点,并且元素的内容为null*/public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null);&#125;/*在初始化LinkedBlockingQueue的时候，还可以直接将一个集合中的元素全部入队列，此时队列最大容量依然是int的最大值。*/public LinkedBlockingQueue(Collection&lt;? extends E&gt; c) &#123; this(Integer.MAX_VALUE); final ReentrantLock putLock = this.putLock; //获取锁 putLock.lock(); // Never contended, but necessary for visibility try &#123; //迭代集合中的每一个元素,让其入队列,并且更新一下当前队列中的元素数量 int n = 0; for (E e : c) &#123; if (e == null) throw new NullPointerException(); if (n == capacity) throw new IllegalStateException("Queue full"); //参考下面的enqueue分析 enqueue(new Node&lt;E&gt;(e)); ++n; &#125; count.set(n); &#125; finally &#123; //释放锁 putLock.unlock(); &#125;&#125;/** * 我去，这代码其实可读性不怎么样啊。 * 其实下面的代码等价于如下内容: * last.next=node; * last = node; * 其实也没有什么花样: 就是让新入队列的元素成为原来的last的next，让进入的元素称为last * */private void enqueue(Node&lt;E&gt; node) &#123; // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node;&#125; 在分析完LinkedBlockingQueue的核心组成之后,下面让我们再看下核心的几个操作方法,首先分析一下元素入队列的过程: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var /*注意上面这句话,约定所有的put/take操作都会预先设置本地变量, 可以看到下面有一个将putLock赋值给了一个局部变量的操作 */ int c = -1; Node&lt;E&gt; node = new Node(e); /* 在这里首先获取到putLock,以及当前队列的元素数量 即上面所描述的预设置本地变量操作 */ final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; /* 执行可中断的锁获取操作,即意味着如果线程由于获取 锁而处于Blocked状态时，线程是可以被中断而不再继 续等待，这也是一种避免死锁的一种方式，不会因为 发现到死锁之后而由于无法中断线程最终只能重启应用。 */ putLock.lockInterruptibly(); try &#123; /* 当队列的容量到底最大容量时,此时线程将处于等待状 态，直到队列有空闲的位置才继续执行。使用while判 断依旧是为了放置线程被"伪唤醒”而出现的情况,即当 线程被唤醒时而队列的大小依旧等于capacity时，线 程应该继续等待。 */ while (count.get() == capacity) &#123; notFull.await(); &#125; //让元素进行队列的末尾,enqueue代码在上面分析过了 enqueue(node); //首先获取原先队列中的元素个数,然后再对队列中的元素个数+1. c = count.getAndIncrement(); /*注:c+1得到的结果是新元素入队列之后队列元素的总和。 当前队列中的总元素个数小于最大容量时,此时唤醒其他执行入队列的线程 让它们可以放入元素,如果新加入元素之后,队列的大小等于capacity， 那么就意味着此时队列已经满了,也就没有必须要唤醒其他正在等待入队列的线程,因为唤醒它们之后，它们也还是继续等待。 */ if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; //完成对锁的释放 putLock.unlock(); &#125; /*当c=0时，即意味着之前的队列是空队列,出队列的线程都处于等待状态， 现在新添加了一个新的元素,即队列不再为空,因此它会唤醒正在等待获取元素的线程。 */ if (c == 0) signalNotEmpty();&#125;/*唤醒正在等待获取元素的线程,告诉它们现在队列中有元素了*/private void signalNotEmpty() &#123; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; //通过notEmpty唤醒获取元素的线程 notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125;&#125; 看完put方法，下面再看看下offer是如何处理的方法： 12345678910111213141516171819202122232425262728293031323334353637383940/**在BlockingQueue接口中除了定义put方法外(当队列元素满了之后就会阻塞，直到队列有新的空间可以方法线程才会继续执行)，还定义一个offer方法，该方法会返回一个boolean值，当入队列成功返回true,入队列失败返回false。该方法与put方法基本操作基本一致，只是有细微的差异。*/ public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; /* 当队列已经满了，它不会继续等待,而是直接返回。 因此该方法是非阻塞的。 */ if (count.get() == capacity) return false; int c = -1; Node&lt;E&gt; node = new Node(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; /* 当获取到锁时，需要进行二次的检查,因为可能当队列的大小为capacity-1时， 两个线程同时去抢占锁，而只有一个线程抢占成功，那么此时 当线程将元素入队列后，释放锁，后面的线程抢占锁之后，此时队列 大小已经达到capacity，所以将它无法让元素入队列。 下面的其余操作和put都一样，此处不再详述 */ if (count.get() &lt; capacity) &#123; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); return c &gt;= 0;&#125; BlockingQueue还定义了一个限时等待插入操作，即在等待一定的时间内，如果队列有空间可以插入，那么就将元素入队列，然后返回true,如果在过完指定的时间后依旧没有空间可以插入，那么就返回false，下面是限时等待操作的分析: 12345678910111213141516171819202122232425262728293031323334353637383940 /** 通过timeout和TimeUnit来指定等待的时长 timeout为时间的长度,TimeUnit为时间的单位 */ public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); //将指定的时间长度转换为毫秒来进行处理 long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; while (count.get() == capacity) &#123; //如果等待的剩余时间小于等于0，那么直接返回 if (nanos &lt;= 0) return false; /* 通过condition来完成等待，此时当前线程会完成锁的，并且处于等待状态 直到被其他线程唤醒该线程、或者当前线程被中断、 等待的时间截至才会返回，该返回值为从方法调用到返回所经历的时长。 注意：上面的代码是condition的awitNanos()方法的通用写法， 可以参看Condition.awaitNaos的API文档。 下面的其余操作和put都一样，此处不再详述 */ nanos = notFull.awaitNanos(nanos); &#125; enqueue(new Node&lt;E&gt;(e)); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty(); return true;&#125; 通过上面的分析，我们应该比较清楚地知道了LinkedBlockingQueue的入队列的操作，其主要是通过获取到putLock锁来完成，当队列的数量达到最大值，此时会导致线程处于阻塞状态或者返回false(根据具体的方法来看)；如果队列还有剩余的空间，那么此时会新创建出一个Node对象，将其设置到队列的尾部，作为LinkedBlockingQueue的last元素。 在分析完入队列的过程之后，我们接下来看看LinkedBlockingQueue出队列的过程；由于BlockingQueue的方法都具有对称性，此处就只分析take方法的实现，其余方法的实现都如出一辙： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; //通过takeLock获取锁，并且支持线程中断 takeLock.lockInterruptibly(); try &#123; //当队列为空时，则让当前线程处于等待 while (count.get() == 0) &#123; notEmpty.await(); &#125; //完成元素的出队列 x = dequeue(); /* 队列元素个数完成原子化操作-1,可以看到count元素会 在插入元素的线程和获取元素的线程进行并发修改操作。 */ c = count.getAndDecrement(); /* 当一个元素出队列之后，队列的大小依旧大于1时 当前线程会唤醒其他执行元素出队列的线程,让它们也 可以执行元素的获取 */ if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; //完成锁的释放 takeLock.unlock(); &#125; /* 当c==capaitcy时，即在获取当前元素之前， 队列已经满了，而此时获取元素之后，队列就会 空出一个位置，故当前线程会唤醒执行插入操作的线 程通知其他中的一个可以进行插入操作。 */ if (c == capacity) signalNotFull(); return x; &#125; /** * 让头部元素出队列的过程 * 其最终的目的是让原来的head被GC回收，让其的next成为head * 并且新的head的item为null. * 因为LinkedBlockingQueue的头部具有一致性:即元素为null。 */ private E dequeue() &#123; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x; &#125; 对于LinkedBlockingQueue的源码分析就到这里，下面让我们将LinkedBlockingQueue与ArrayBlockingQueue进行一个比较。 LinkedBlockingQueue与ArrayBlockingQueue的比较ArrayBlockingQueue由于其底层基于数组，并且在创建时指定存储的大小，在完成后就会立即在内存分配固定大小容量的数组元素，因此其存储通常有限，故其是一个“有界“的阻塞队列； 而LinkedBlockingQueue可以由用户指定最大存储容量，也可以无需指定，如果不指定则最大存储容量将是Integer.MAX_VALUE，即可以看作是一个“无界”的阻塞队列，由于其节点的创建都是动态创建，并且在节点出队列后可以被GC所回收，因此其具有灵活的伸缩性。但是由于ArrayBlockingQueue的有界性，因此其能够更好的对于性能进行预测，而LinkedBlockingQueue由于没有限制大小，当任务非常多的时候，不停地向队列中存储，就有可能导致内存溢出的情况发生。 其次，ArrayBlockingQueue中在入队列和出队列操作过程中，使用的是同一个lock，所以即使在多核CPU的情况下，其读取和操作的都无法做到并行，而LinkedBlockingQueue的读取和插入操作所使用的锁是两个不同的lock，它们之间的操作互相不受干扰，因此两种操作可以并行完成，故LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue。 选择LinkedBlockingQueue的理由123456789/** 下面的代码是Executors创建固定大小线程池的代码，其使用了 LinkedBlockingQueue来作为任务队列。*/public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125; JDK中选用LinkedBlockingQueue作为阻塞队列的原因就在于其无界性。因为线程大小固定的线程池，其线程的数量是不具备伸缩性的，当任务非常繁忙的时候，就势必会导致所有的线程都处于工作状态，如果使用一个有界的阻塞队列来进行处理，那么就非常有可能很快导致队列满的情况发生，从而导致任务无法提交而抛出RejectedExecutionException，而使用无界队列由于其良好的存储容量的伸缩性，可以很好的去缓冲任务繁忙情况下场景，即使任务非常多，也可以进行动态扩容，当任务被处理完成之后，队列中的节点也会被随之被GC回收，非常灵活。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发集合—/ArrayBlockingQueue]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88%E2%80%94ArrayBlockingQueue%2F</url>
    <content type="text"><![CDATA[前言 本文的主要详细分析ArrayBlockingQueue的实现原理，由于该并发集合其底层是使用了java.util.ReentrantLock和java.util.Condition来完成并发控制的，我们可以通过JDK的源代码更好的学习这些并发控制类的使用，同时该类也是所有并发集合中最简单的一个，分析该类的源码也是为之后分析其他并发集合做好基础。 一、Queue接口和BlockingQueue接口回顾1.1 Queue接口回顾 在Queue接口中，除了继承Collection接口中定义的方法外，它还分别额外地定义插入、删除、查询这3个操作，其中每一个操作都以两种不同的形式存在，每一种形式都对应着一个方法。 方法说明： Throws exception Returns special value Insert add(e) offer(e) Remove remove() poll() Examine element() peek() add方法在将一个元素插入到队列的尾部时，如果出现队列已经满了，那么就会抛出IllegalStateException,而使用offer方法时，如果队列满了，则添加失败,返回false,但并不会引发异常。 remove方法是获取队列的头部元素并且删除，如果当队列为空时，那么就会抛出NoSuchElementException。而poll在队列为空时，则返回一个null。 element方法是从队列中获取到队列的第一个元素，但不会删除，但是如果队列为空时，那么它就会抛出NoSuchElementException。peek方法与之类似，只是不会抛出异常，而是返回false。 后面我们在分析ArrayBlockingQueue的方法时，主要也是围绕着这几个方法来进行分析。 1.2 BlockingQueue接口回顾 BlockingQueue是JDK1.5出现的接口，它在原来的Queue接口基础上提供了更多的额外功能：当获取队列中的头部元素时，如果队列为空，那么它将会使执行线程处于等待状态；当添加一个元素到队列的尾部时，如果队列已经满了，那么它同样会使执行的线程处于等待状态。 前面我们在说Queue接口时提到过，它针对于相同的操作提供了2种不同的形式，而BlockingQueue更夸张，针对于相同的操作提供了4种不同的形式。 该四种形式分别为： 抛出异常 返回一个特殊值(可能是null或者是false，取决于具体的操作) 阻塞当前执行直到其可以继续 当线程被挂起后，等待最大的时间，如果一旦超时，即使该操作依旧无法继续执行，线程也不会再继续等待下去。 对应的方法说明: Throws exception Returns special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() 无 无 BlockingQueue虽然比起Queue在操作上提供了更多的支持，但是它在使用有如下的几点: BlockingQueue中是不允许添加null的，该接受在声明的时候就要求所有的实现类在接收到一个null的时候，都应该抛出NullPointerException。 BlockingQueue是线程安全的，因此它的所有和队列相关的方法都具有原子性。但是对于那么从Collection接口中继承而来的批量操作方法，比如addAll(Collection e)等方法，BlockingQueue的实现通常没有保证其具有原子性，因此我们在使用的BlockingQueue，应该尽可能地不去使用这些方法。 BlockingQueue主要应用于生产者与消费者的模型中，其元素的添加和获取都是极具规律性的。但是对于remove(Object o)这样的方法，虽然BlockingQueue可以保证元素正确的删除，但是这样的操作会非常响应性能，因此我们在没有特殊的情况下，也应该避免使用这类方法。 二、ArrayBlockingQueue深入分析有了上面的铺垫，下面我们就可以真正开始分析ArrayBlockingQueue了。在分析之前，首先让我们看看API对其的描述。注意:这里使用的JDK版本为1.7，不同的JDK版本在实现上存在不同 首先让我们看下ArrayBlockingQueue的核心组成： 1234567891011121314151617181920/** 底层维护队列元素的数组 */ final Object[] items; /** 当读取元素时数组的下标(这里称为读下标) */ int takeIndex; /** 添加元素时数组的下标 (这里称为写小标)*/ int putIndex; /** 队列中的元素个数 */ int count; /**用于并发控制的工具类**/ final ReentrantLock lock; /** 控制take操作时是否让线程等待 */ private final Condition notEmpty; /** 控制put操作时是否让线程等待 */ private final Condition notFull; take方法分析(369-379行): 1234567891011121314151617181920212223public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; /* 尝试获取锁，如果此时锁被其他线程锁占用，那么当前线程就处于Waiting的状态。 注意:当方法是支持线程中断响应的如果其他线程此时中断当前线程， 那么当前线程就会抛出InterruptedException */ lock.lockInterruptibly(); try &#123; /* 如果此时队列中的元素个数为0,那么就让当前线程wait,并且释放锁。 注意:这里使用了while进行重复检查，是为了防止当前线程可能由于其他未知的原因被唤醒。 (通常这种情况被称为"spurious wakeup") */ while (count == 0) notEmpty.await(); //如果队列不为空，则从队列的头部取元素 return extract(); &#125; finally &#123; //完成锁的释放 lock.unlock(); &#125;&#125; extract方法分析(163-171): 12345678910111213141516171819202122/* 根据takeIndex来获取当前的元素,然后通知其他等待的线程。 Call only when holding lock.(只有当前线程已经持有了锁之后，它才能调用该方法) */private E extract() &#123; final Object[] items = this.items; //根据takeIndex获取元素,因为元素是一个Object类型的数组,因此它通过cast方法将其转换成泛型。 E x = this.&lt;E&gt;cast(items[takeIndex]); //将当前位置的元素设置为null items[takeIndex] = null; //并且将takeIndex++,注意：这里因为已经使用了锁，因此inc方法中没有使用到原子操作 takeIndex = inc(takeIndex); //将队列中的总的元素减1 --count; //唤醒其他等待的线程 notFull.signal(); return x;&#125; put方法分析(318-239) 12345678910111213141516171819202122232425262728293031323334353637public void put(E e) throws InterruptedException &#123; //首先检查元素是否为空，否则抛出NullPointerException checkNotNull(e); final ReentrantLock lock = this.lock; //进行锁的抢占 lock.lockInterruptibly(); try &#123; /*当队列的长度等于数组的长度,此时说明队列已经满了,这里同样 使用了while来方式当前线程被"伪唤醒"。*/ while (count == items.length) //则让当前线程处于等待状态 notFull.await(); //一旦获取到锁并且队列还未满时，则执行insert操作。 insert(e); &#125; finally &#123; //完成锁的释放 lock.unlock(); &#125;&#125; //检查元素是否为空 private static void checkNotNull(Object v) &#123; if (v == null) throw new NullPointerException(); &#125; //该方法的逻辑非常简单private void insert(E x) &#123; //将当前元素设置到putIndex位置 items[putIndex] = x; //让putIndex++ putIndex = inc(putIndex); //将队列的大小加1 ++count; //唤醒其他正在处于等待状态的线程 notEmpty.signal();&#125; 注:ArrayBlockingQueue其实是一个循环队列我们使用一个图来简单说明一下: 黄色表示数组中有元素 当再一次执行put的时候,其结果为： 此时放入的元素会从头开始置，我们通过其incr方法更加清晰的看出其底层的操作： 1234567/** * Circularly increment i. */final int inc(int i) &#123; //当takeIndex的值等于数组的长度时,就会重新置为0，这个一个循环递增的过程 return (++i == items.length) ? 0 : i;&#125; 至此，ArrayBlockingQueue的核心部分就分析完了，其余的队列操作基本上都是换汤不换药的，此处不再一一列举。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ReentrantLock]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ReentrantLock%2F</url>
    <content type="text"><![CDATA[前言java5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁的功能，它提供了与synchronized关键字类似的同步功能。既然有了synchronized这种内置的锁功能，为何要新增Lock接口？先来想象一个场景：手把手的进行锁获取和释放，先获得锁A，然后再获取锁B，当获取锁B后释放锁A同时获取锁C，当锁C获取后，再释放锁B同时获取锁D，以此类推，这种场景下，synchronized关键字就不那么容易实现了，而使用Lock却显得容易许多。 定义12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ReentrantLock implements Lock, java.io.Serializable &#123; private final Sync sync; abstract static class Sync extends AbstractQueuedSynchronizer &#123; /** * Performs &#123;@link Lock#lock&#125;. The main reason for subclassing * is to allow fast path for nonfair version. */ abstract void lock(); /** * Performs non-fair tryLock. tryAcquire is implemented in * subclasses, but both need nonfair try for trylock method. */ final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125; protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; &#125; //默认非公平锁 public ReentrantLock() &#123; sync = new NonfairSync(); &#125; //fair为false时，采用公平锁策略 public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; public void lock() &#123; sync.lock(); &#125; public void unlock() &#123; sync.release(1);&#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; ...&#125; 从源代码可以Doug lea巧妙的采用组合模式把lock和unlock方法委托给同步器完成。 使用方式1234567891011Lock lock = new ReentrantLock();Condition condition = lock.newCondition();lock.lock();try &#123; while(条件判断表达式) &#123; condition.wait(); &#125; // 处理逻辑&#125; finally &#123; lock.unlock();&#125; 需要显示的获取锁，并在finally块中显示的释放锁，目的是保证在获取到锁之后，最终能够被释放。 非公平锁实现在非公平锁中，每当线程执行lock方法时，都尝试利用CAS把state从0设置为1。 那么Doug lea是如何实现锁的非公平性呢？我们假设这样一个场景： 持有锁的线程A正在running，队列中有线程BCDEF被挂起并等待被唤醒； 在某一个时间点，线程A执行unlock，唤醒线程B； 同时线程G执行lock，这个时候会发生什么？线程B和G拥有相同的优先级，这里讲的优先级是指获取锁的优先级，同时执行CAS指令竞争锁。如果恰好线程G成功了，线程B就得重新挂起等待被唤醒。 通过上述场景描述，我们可以看书，即使线程B等了很长时间也得和新来的线程G同时竞争锁，如此的不公平。 12345678910111213141516171819202122static final class NonfairSync extends Sync &#123; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; 下面我们用线程A和线程B来描述非公平锁的竞争过程。 线程A和B同时执行CAS指令，假设线程A成功，线程B失败，则表明线程A成功获取锁，并把同步器中的exclusiveOwnerThread设置为线程A。 竞争失败的线程B，在nonfairTryAcquire方法中，会再次尝试获取锁， Doug lea会在多处尝试重新获取锁，应该是在这段时间如果线程A释放锁，线程B就可以直接获取锁而不用挂起 。完整的执行流程如下： 公平锁实现在公平锁中，每当线程执行lock方法时，如果同步器的队列中有线程在等待，则直接加入到队列中。场景分析： 持有锁的线程A正在running，对列中有线程BCDEF被挂起并等待被唤醒； 线程G执行lock，队列中有线程BCDEF在等待，线程G直接加入到队列的对尾。 所以每个线程获取锁的过程是公平的，等待时间最长的会最先被唤醒获取锁。 12345678910111213141516171819202122232425262728293031static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125; 重入锁实现重入锁，即线程可以重复获取已经持有的锁。在非公平和公平锁中，都对重入锁进行了实现。 1234567if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true;&#125; 条件变量Condition条件变量很大一个程度上是为了解决Object.wait/notify/notifyAll难以使用的问题。 12345678910public class ConditionObject implements Condition, java.io.Serializable &#123; /** First node of condition queue. */ private transient Node firstWaiter; /** Last node of condition queue. */ private transient Node lastWaiter; public final void signal() &#123;&#125; public final void signalAll() &#123;&#125; public final void awaitUninterruptibly() &#123;&#125; public final void await() throws InterruptedException &#123;&#125;&#125; Synchronized中，所有的线程都在同一个object的条件队列上等待。而ReentrantLock中，每个condition都维护了一个条件队列。 每一个Lock可以有任意数据的Condition对象，Condition是与Lock绑定的，所以就有Lock的公平性特性：如果是公平锁，线程为按照FIFO的顺序从Condition.await中释放，如果是非公平锁，那么后续的锁竞争就不保证FIFO顺序了。 Condition接口定义的方法，await对应于Object.wait，signal对应于Object.notify，signalAll对应于Object.notifyAll。特别说明的是Condition的接口改变名称就是为了避免与Object中的wait/notify/notifyAll的语义和使用上混淆。 先看一个condition在生产者消费者的应用场景： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.Lock;import java.util.concurrent.locks.ReentrantLock;/** * Created by j_zhan on 2016/7/13. */public class Queue&lt;T&gt; &#123; private final T[] items; private final Lock lock = new ReentrantLock(); private Condition notFull = lock.newCondition(); private Condition notEmpty = lock.newCondition(); private int head, tail, count; public Queue(int maxSize) &#123; items = (T[]) new Object[maxSize]; &#125; public Queue() &#123; this(10); &#125; public void put(T t) throws InterruptedException &#123; lock.lock(); try &#123; while (count == items.length) &#123; //数组满时，线程进入等待队列挂起。线程被唤醒时，从这里返回。 notFull.await(); &#125; items[tail] = t; if (++tail == items.length) &#123; tail = 0; &#125; ++count; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; &#125; public T take() throws InterruptedException &#123; lock.lock(); try &#123; while (count == 0) &#123; notEmpty.await(); &#125; T o = items[head]; items[head] = null;//GC if (++head == items.length) &#123; head = 0; &#125; --count; notFull.signal(); return o; &#125; finally &#123; lock.unlock(); &#125; &#125;&#125; 假设线程AB在并发的往items中插入数据，当items中元素存满时。如果线程A获取到锁，继续添加数据，满足count == items.length条件，导致线程A执行await方法。ReentrantLock是独占锁，同一时刻只有一个线程能获取到锁，所以在lock.lock()和lock.unlock()之间可能有一次释放锁的操作（同样也必然还有一次获取锁的操作）。在Queue类中，不管take还是put，在线程持有锁之后只有await()方法有可能释放锁，然后挂起线程，一旦条件满足就被唤醒，再次获取锁。具体实现如下： 12345678910111213141516171819202122232425262728293031323334public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); Node node = addConditionWaiter(); int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125;private Node addConditionWaiter() &#123; Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125; await实现逻辑： 将线程A加入到条件等待队列中，如果最后一个节点是取消状态，则从对列中删除。 线程A释放锁，实质上是线程A修改AQS的状态state为0，并唤醒AQS等待队列中的线程B，线程B被唤醒后，尝试获取锁，接下去的过程就不重复说明了。 线程A释放锁并唤醒线程B之后，如果线程A不在AQS的同步队列中，线程A将通过LockSupport.park进行挂起操作。 随后，线程A等待被唤醒，当线程A被唤醒时，会通过acquireQueued方法竞争锁，如果失败，继续挂起。如果成功，线程A从await位置恢复。 假设线程B获取锁之后，执行了take操作和条件变量的signal，signal通过某种实现唤醒了线程A，具体实现如下： 1234567891011121314151617181920212223242526 public final void signal() &#123; if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); &#125; private void doSignal(Node first) &#123; do &#123; if ((firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null); &#125; final boolean transferForSignal(Node node) &#123; if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; Node p = enq(node); //线程A插入到AQS的等待队列中 int ws = p.waitStatus; if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; signal实现逻辑： 接着上述场景，线程B执行了signal方法，取出条件队列中的第一个非CANCELLED节点线程，即线程A。另外，signalAll就是唤醒条件队列中所有非CANCELLED节点线程。遇到CANCELLED线程就需要将其从队列中删除。 通过CAS修改线程A的waitStatus，表示该节点已经不是等待条件状态，并将线程A插入到AQS的等待队列中。 唤醒线程A，线程A和别的线程进行锁的竞争。 总结 ReentrantLock提供了内置锁类似的功能和内存语义。 此外，ReetrantLock还提供了其它功能，包括定时的锁等待、可中断的锁等待、公平性、以及实现非块结构的加锁、Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性，不过ReetrantLock需要显示的获取锁，并在finally中释放锁，否则后果很严重。 ReentrantLock在性能上似乎优于Synchronized，其中在jdk1.6中略有胜出，在1.5中是远远胜出。那么为什么不放弃内置锁，并在新代码中都使用ReetrantLock？ 在java1.5中， 内置锁与ReentrantLock相比有例外一个优点：在线程转储中能给出在哪些调用帧中获得了哪些锁，并能够检测和识别发生死锁的线程。Reentrant的非块状特性任然意味着，获取锁的操作不能与特定的栈帧关联起来，而内置锁却可以。 因为内置锁时JVM的内置属性，所以未来更可能提升synchronized而不是ReentrantLock的性能。例如对线程封闭的锁对象消除优化，通过增加锁粒度来消除内置锁的同步。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AbstractQueuedSynchronizer详解]]></title>
    <url>%2F2018%2F06%2F08%2FAbstractQueuedSynchronizer%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、AQS简介1.1 AQS介绍AbstractQueuedSynchronizer提供了一个基于FIFO队列，可以用于构建锁或者其他相关同步装置的基础框架。该同步器（以下简称同步器）利用了一个int来表示状态，期望它能够成为实现大部分同步需求的基础。使用的方法是继承，子类通过继承同步器并需要实现它的方法来管理其状态，管理的方式就是通过类似acquire和release的方式来操纵状态。然而多线程环境中对状态的操纵必须确保原子性，因此子类对于状态的把握，需要使用这个同步器提供的以下三个方法对状态进行操作： 123java.util.concurrent.locks.AbstractQueuedSynchronizer.getState()java.util.concurrent.locks.AbstractQueuedSynchronizer.setState(int)java.util.concurrent.locks.AbstractQueuedSynchronizer.compareAndSetState(int, int) 子类推荐被定义为自定义同步装置的内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干acquire之类的方法来供使用。该同步器即可以作为排他模式也可以作为共享模式，当它被定义为一个排他模式时，其他线程对其的获取就被阻止，而共享模式对于多个线程获取都可以成功。 1.2 AQS用处 1.3 同步器与锁同步器是实现锁的关键，利用同步器将锁的语义实现，然后在锁的实现中聚合同步器。 可以这样理解：锁的API是面向使用者的，它定义了与锁交互的公共行为，而每个锁需要完成特定的操作也是透过这些行为来完成的（比如：可以允许两个线程进行加锁，排除两个以上的线程），但是实现是依托给同步器来完成；同步器面向的是线程访问和资源控制，它定义了线程对资源是否能够获取以及线程的排队等操作。锁和同步器很好的隔离了二者所需要关注的领域，严格意义上讲，同步器可以适用于除了锁以外的其他同步设施上（包括锁）。同步器的开始提到了其实现依赖于一个FIFO队列，那么队列中的元素Node就是保存着线程引用和线程状态的容器，每个线程对同步器的访问，都可以看做是队列中的一个节点。Node的主要包含以下成员变量： 1234567Node &#123; int waitStatus; Node prev; Node next; Node nextWaiter; Thread thread;&#125; 以上五个成员变量主要负责保存该节点的线程引用，同步等待队列（以下简称sync队列）的前驱和后继节点，同时也包括了同步状态。 属性名称 描述 int waitStatus 表示节点的状态。其中包含的状态有： CANCELLED，值为1，表示当前的线程被取消；SIGNAL，值为-1，表示当前节点的后继节点包含的线程需要运行，也就是unpark；CONDITION，值为-2，表示当前节点在等待condition，也就是在condition队列中；PROPAGATE，值为-3，表示当前场景下后续的acquireShared能够得以执行；值为0，表示当前节点在sync队列中，等待着获取锁。 Node prev 前驱节点，比如当前节点被取消，那就需要前驱节点和后继节点来完成连接。 Node next 后继节点。 Node nextWaiter 存储condition队列中的后继节点。 Thread thread 入队列时的当前线程。 节点成为sync队列和condition队列构建的基础，在同步器中就包含了sync队列。同步器拥有三个成员变量：sync队列的头结点head、sync队列的尾节点tail和状态state。对于锁的获取，请求形成节点，将其挂载在尾部，而锁资源的转移（释放再获取）是从头部开始向后进行。对于同步器维护的状态state，多个线程对其的获取将会产生一个链式的结构。 1.4 API说明实现自定义同步器时，需要使用同步器提供的getState()、setState()和compareAndSetState()方法来操纵状态的变迁。 方法名称 描述 protected boolean tryAcquire(int arg) 排它的获取这个状态。这个方法的实现需要查询当前状态是否允许获取，然后再进行获取（使用compareAndSetState来做）状态。 protected boolean tryRelease(int arg) 释放状态。 protected int tryAcquireShared(int arg) 共享的模式下获取状态。 protected boolean tryReleaseShared(int arg) 共享的模式下释放状态。 protected boolean isHeldExclusively() 在排它模式下，状态是否被占用。 实现这些方法必须是非阻塞而且是线程安全的，推荐使用该同步器的父类java.util.concurrent.locks.AbstractOwnableSynchronizer来设置当前的线程。开始提到同步器内部基于一个FIFO队列，对于一个独占锁的获取和释放有以下伪码可以表示。获取一个排他锁。 1234567891011while(获取锁) &#123; if (获取到) &#123; 退出while循环 &#125; else &#123; if(当前线程没有入队列) &#123; 那么入队列 &#125; 阻塞当前线程 &#125;&#125;释放一个排他锁。 1234if (释放成功) &#123; 删除头结点 激活原头结点的后继节点&#125; 1.5 Mutex 示例下面通过一个排它锁的例子来深入理解一下同步器的工作原理，而只有掌握同步器的工作原理才能够更加深入了解其他的并发组件。排他锁的实现，一次只能一个线程获取到锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243class Mutex implements Lock, java.io.Serializable &#123; // 内部类，自定义同步器 private static class Sync extends AbstractQueuedSynchronizer &#123; // 是否处于占用状态 protected boolean isHeldExclusively() &#123; return getState() == 1; &#125; // 当状态为0的时候获取锁 public boolean tryAcquire(int acquires) &#123; assert acquires == 1; // Otherwise unused if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; // 释放锁，将状态设置为0 protected boolean tryRelease(int releases) &#123; assert releases == 1; // Otherwise unused if (getState() == 0) throw new IllegalMonitorStateException(); setExclusiveOwnerThread(null); setState(0); return true; &#125; // 返回一个Condition，每个condition都包含了一个condition队列 Condition newCondition() &#123; return new ConditionObject(); &#125; &#125; // 仅需要将操作代理到Sync上即可 private final Sync sync = new Sync(); public void lock() &#123; sync.acquire(1); &#125; public boolean tryLock() &#123; return sync.tryAcquire(1); &#125; public void unlock() &#123; sync.release(1); &#125; public Condition newCondition() &#123; return sync.newCondition(); &#125; public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125; public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireNanos(1, unit.toNanos(timeout)); &#125; &#125; 可以看到Mutex将Lock接口均代理给了同步器的实现。使用方将Mutex构造出来之后，调用lock获取锁，调用unlock进行解锁。下面以Mutex为例子，详细分析以下同步器的实现逻辑。 二、独占模式2.1 acquire实现分析public final void acquire(int arg)该方法以排他的方式获取锁，对中断不敏感，完成synchronized语义。 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 上述逻辑主要包括： 尝试获取（调用tryAcquire更改状态，需要保证原子性）；在tryAcquire方法中使用了同步器提供的对state操作的方法，利用compareAndSet保证只有一个线程能够对状态进行成功修改，而没有成功修改的线程将进入sync队列排队。 如果获取不到，将当前线程构造成节点Node并加入sync队列；进入队列的每个线程都是一个节点Node，从而形成了一个双向队列，类似CLH队列，这样做的目的是线程间的通信会被限制在较小规模（也就是两个节点左右）。 再次尝试获取，如果没有获取到那么将当前线程从线程调度器上摘下，进入等待状态。使用LockSupport将当前线程unpark，关于LockSupport后续会详细介绍。 1234567891011121314151617181920212223242526272829private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // 快速尝试在尾部添加 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125;private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125;&#125; 上述逻辑主要包括： 使用当前线程构造Node；对于一个节点需要做的是将当节点前驱节点指向尾节点（current.prev = tail），尾节点指向它（tail = current），原有的尾节点的后继节点指向它（t.next = current）而这些操作要求是原子的。上面的操作是利用尾节点的设置来保证的，也就是compareAndSetTail来完成的。 先行尝试在队尾添加； ​ 如果尾节点已经有了，然后做如下操作： 分配引用T指向尾节点； 将节点的前驱节点更新为尾节点（current.prev = tail）； 如果尾节点是T，那么将当尾节点设置为该节点（tail = current，原子更新）； T的后继节点指向当前节点（T.next = current）。注意第3点是要求原子的。这样可以以最短路径O(1)的效果来完成线程入队，是最大化减少开销的一种方式。 如果队尾添加失败或者是第一个入队的节点。 ​ 如果是第1个节点，也就是sync队列没有初始化，那么会进入到enq这个方法，进入的线程可能有多个，或者说在addWaiter中没有成功入队的线程都将进入enq这个方法。 ​ 可以看到enq的逻辑是确保进入的Node都会有机会顺序的添加到sync队列中，而加入的步骤如下： 如果尾节点为空，那么原子化的分配一个头节点，并将尾节点指向头节点，这一步是初始化； 然后是重复在addWaiter中做的工作，但是在一个for(;;)的循环中，直到当前节点入队为止。 进入sync队列之后，接下来就是要进行锁的获取，或者说是访问控制了，只有一个线程能够在同一时刻继续的运行，而其他的进入等待状态。而每个线程都是一个独立的个体，它们自省的观察，当条件满足的时候（自己的前驱是头结点并且原子性的获取了状态），那么这个线程能够继续运行。 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp;tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 上述逻辑主要包括： 获取当前节点的前驱节点；需要获取当前节点的前驱节点，而头结点所对应的含义是当前占有锁且正在运行。 当前驱节点是头结点并且能够获取状态，代表该当前节点占有锁；如果满足上述条件，那么代表能够占有锁，根据节点对锁占有的含义，设置头结点为当前节点。 否则进入等待状态。如果没有轮到当前节点运行，那么将当前线程从线程调度器上摘下，也就是进入等待状态。这里针对acquire做一下总结： 状态的维护；需要在锁定时，需要维护一个状态(int类型)，而对状态的操作是原子和非阻塞的，通过同步器提供的对状态访问的方法对状态进行操纵，并且利用compareAndSet来确保原子性的修改。 状态的获取；一旦成功的修改了状态，当前线程或者说节点，就被设置为头节点。 sync队列的维护。在获取资源未果的过程中条件不符合的情况下(不该自己，前驱节点不是头节点或者没有获取到资源)进入睡眠状态，停止线程调度器对当前节点线程的调度。这时引入的一个释放的问题，也就是说使睡眠中的Node或者说线程获得通知的关键，就是前驱节点的通知，而这一个过程就是释放，释放会通知它的后继节点从睡眠中返回准备运行。下面的流程图基本描述了一次acquire所需要经历的过程： 如上图所示，其中的判定退出队列的条件，判定条件是否满足和休眠当前线程就是完成了自旋spin的过程。 2.2 releasepublic final boolean release(int arg)在unlock方法的实现中，使用了同步器的release方法。相对于在之前的acquire方法中可以得出调用acquire，保证能够获取到锁（成功获取状态），而release则表示将状态设置回去，也就是将资源释放，或者说将锁释放。 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 上述逻辑主要包括： 尝试释放状态；tryRelease能够保证原子化的将状态设置回去，当然需要使用compareAndSet来保证。如果释放状态成功过之后，将会进入后继节点的唤醒过程。 唤醒当前节点的后继节点所包含的线程。通过LockSupport的unpark方法将休眠中的线程唤醒，让其继续acquire状态。 123456789101112131415161718192021private void unparkSuccessor(Node node) &#123; // 将状态设置为同步状态 int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * 获取当前节点的后继节点，如果满足状态，那么进行唤醒操作 * 如果没有满足状态，从尾部开始找寻符合要求的节点并将其唤醒 */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 上述逻辑主要包括，该方法取出了当前节点的next引用，然后对其线程(Node)进行了唤醒，这时就只有一个或合理个数的线程被唤醒，被唤醒的线程继续进行对资源的获取与争夺。回顾整个资源的获取和释放过程：在获取时，维护了一个sync队列，每个节点都是一个线程在进行自旋，而依据就是自己是否是首节点的后继并且能够获取资源；在释放时，仅仅需要将资源还回去，然后通知一下后继节点并将其唤醒。这里需要注意，队列的维护（首节点的更换）是依靠消费者（获取时）来完成的，也就是说在满足了自旋退出的条件时的一刻，这个节点就会被设置成为首节点。 2.3 tryAcquireprotected boolean tryAcquire(int arg)tryAcquire是自定义同步器需要实现的方法，也就是自定义同步器非阻塞原子化的获取状态，如果锁该方法一般用于Lock的tryLock实现中，这个特性是synchronized无法提供的。 public final void acquireInterruptibly(int arg)该方法提供获取状态能力，当然在无法获取状态的情况下会进入sync队列进行排队，这类似acquire，但是和acquire不同的地方在于它能够在外界对当前线程进行中断的时候提前结束获取状态的操作，换句话说，就是在类似synchronized获取锁时，外界能够对当前线程进行中断，并且获取锁的这个操作能够响应中断并提前返回。一个线程处于synchronized块中或者进行同步I/O操作时，对该线程进行中断操作，这时该线程的中断标识位被设置为true，但是线程依旧继续运行。如果在获取一个通过网络交互实现的锁时，这个锁资源突然进行了销毁，那么使用acquireInterruptibly的获取方式就能够让该时刻尝试获取锁的线程提前返回。而同步器的这个特性被实现Lock接口中的lockInterruptibly方法。根据Lock的语义，在被中断时，lockInterruptibly将会抛出InterruptedException来告知使用者。 12345678910111213141516171819202122232425262728293031public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125;private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; // 检测中断标志位 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 上述逻辑主要包括： 检测当前线程是否被中断；判断当前线程的中断标志位，如果已经被中断了，那么直接抛出异常并将中断标志位设置为false。 尝试获取状态；调用tryAcquire获取状态，如果顺利会获取成功并返回。 构造节点并加入sync队列；获取状态失败后，将当前线程引用构造为节点并加入到sync队列中。退出队列的方式在没有中断的场景下和acquireQueued类似，当头结点是自己的前驱节点并且能够获取到状态时，即可以运行，当然要将本节点设置为头结点，表示正在运行。 中断检测。在每次被唤醒时，进行中断检测，如果发现当前线程被中断，那么抛出InterruptedException并退出循环。 2.4 doAcquireNanosprivate boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException该方法提供了具备有超时功能的获取状态的调用，如果在指定的nanosTimeout内没有获取到状态，那么返回false，反之返回true。可以将该方法看做acquireInterruptibly的升级版，也就是在判断是否被中断的基础上增加了超时控制。针对超时控制这部分的实现，主要需要计算出睡眠的delta，也就是间隔值。间隔可以表示为nanosTimeout = 原有nanosTimeout – now（当前时间）+ lastTime（睡眠之前记录的时间）。如果nanosTimeout大于0，那么还需要使当前线程睡眠，反之则返回false。 1234567891011121314151617181920212223242526272829private boolean doAcquireNanos(int arg, long nanosTimeout)throws InterruptedException &#123; long lastTime = System.nanoTime(); final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp;tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; if (nanosTimeout &lt;= 0) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); long now = System.nanoTime(); //计算时间，当前时间减去睡眠之前的时间得到睡眠的时间，然后被 //原有超时时间减去，得到了还应该睡眠的时间 nanosTimeout -= now - lastTime; lastTime = now; if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 上述逻辑主要包括： 加入sync队列；将当前线程构造成为节点Node加入到sync队列中。 条件满足直接返回；退出条件判断，如果前驱节点是头结点并且成功获取到状态，那么设置自己为头结点并退出，返回true，也就是在指定的nanosTimeout之前获取了锁。 获取状态失败休眠一段时间；通过LockSupport.unpark来指定当前线程休眠一段时间。 计算再次休眠的时间；唤醒后的线程，计算仍需要休眠的时间，该时间表示为nanosTimeout = 原有nanosTimeout – now（当前时间）+ lastTime（睡眠之前记录的时间）。其中now – lastTime表示这次睡眠所持续的时间。 休眠时间的判定。唤醒后的线程，计算仍需要休眠的时间，并无阻塞的尝试再获取状态，如果失败后查看其nanosTimeout是否大于0，如果小于0，那么返回完全超时，没有获取到锁。 如果nanosTimeout小于等于1000L纳秒，则进入快速的自旋过程。那么快速自旋会造成处理器资源紧张吗？结果是不会，经过测算，开销看起来很小，几乎微乎其微。Doug Lea应该测算了在线程调度器上的切换造成的额外开销，因此在短时1000纳秒内就让当前线程进入快速自旋状态，如果这时再休眠相反会让nanosTimeout的获取时间变得更加不精确。上述过程可以如下图所示： 上述这个图中可以理解为在类似获取状态需要排队的基础上增加了一个超时控制的逻辑。每次超时的时间就是当前超时剩余的时间减去睡眠的时间，而在这个超时时间的基础上进行了判断，如果大于0那么继续睡眠（等待），可以看出这个超时版本的获取状态只是一个近似超时的获取状态，因此任何含有超时的调用基本结果就是近似于给定超时。 三、共享模式3.1 acquireSharedpublic final void acquireShared(int arg)调用该方法能够以共享模式获取状态，共享模式和之前的独占模式有所区别。以文件的查看为例，如果一个程序在对其进行读取操作，那么这一时刻，对这个文件的写操作就被阻塞，相反，这一时刻另一个程序对其进行同样的读操作是可以进行的。如果一个程序在对其进行写操作，那么所有的读与写操作在这一时刻就被阻塞，直到这个程序完成写操作。以读写场景为例，描述共享和独占的访问模式，如下图所示： 上图中，红色代表被阻塞，绿色代表可以通过。 12345678910111213141516171819202122232425262728293031public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 上述逻辑主要包括： 尝试获取共享状态；调用tryAcquireShared来获取共享状态，该方法是非阻塞的，如果获取成功则立刻返回，也就表示获取共享锁成功。 获取失败进入sync队列；在获取共享状态失败后，当前时刻有可能是独占锁被其他线程所把持，那么将当前线程构造成为节点（共享模式）加入到sync队列中。 循环内判断退出队列条件；如果当前节点的前驱节点是头结点并且获取共享状态成功，这里和独占锁acquire的退出队列条件类似。 获取共享状态成功；在退出队列的条件上，和独占锁之间的主要区别在于获取共享状态成功之后的行为，而如果共享状态获取成功之后会判断后继节点是否是共享模式，如果是共享模式，那么就直接对其进行唤醒操作，也就是同时激发多个线程并发的运行。 获取共享状态失败。通过使用LockSupport将当前线程从线程调度器上摘下，进入休眠状态。对于上述逻辑中，节点之间的通知过程如下图所示： 上图中，绿色表示共享节点，它们之间的通知和唤醒操作是在前驱节点获取状态时就进行的，红色表示独占节点，它的被唤醒必须取决于前驱节点的释放，也就是release操作，可以看出来图中的独占节点如果要运行，必须等待前面的共享节点均释放了状态才可以。而独占节点如果获取了状态，那么后续的独占式获取和共享式获取均被阻塞。 3.2 releaseSharedpublic final boolean releaseShared(int arg)调用该方法释放共享状态，每次获取共享状态acquireShared都会操作状态，同样在共享锁释放的时候，也需要将状态释放。比如说，一个限定一定数量访问的同步工具，每次获取都是共享的，但是如果超过了一定的数量，将会阻塞后续的获取操作，只有当之前获取的消费者将状态释放才可以使阻塞的获取操作得以运行。 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 上述逻辑主要就是调用同步器的tryReleaseShared方法来释放状态，并同时在doReleaseShared方法中唤醒其后继节点。 3.3 一个例子 TwinsLock在上述对同步器AbstractQueuedSynchronizer进行了实现层面的分析之后，我们通过一个例子来加深对同步器的理解：设计一个同步工具，该工具在同一时刻，只能有两个线程能够并行访问，超过限制的其他线程进入阻塞状态。对于这个需求，可以利用同步器完成一个这样的设定，定义一个初始状态，为2，一个线程进行获取那么减1，一个线程释放那么加1，状态正确的范围在[0，1，2]三个之间，当在0时，代表再有新的线程对资源进行获取时只能进入阻塞状态（注意在任何时候进行状态变更的时候均需要以CAS作为原子性保障）。由于资源的数量多于1个，同时可以有两个线程占有资源，因此需要实现tryAcquireShared和tryReleaseShared方法，这里谢谢luoyuyou和同事小明指正，已经修改了实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class TwinsLock implements Lock &#123; private final Sync sync = new Sync(2); private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = -7889272986162341211L; Sync(int count) &#123; if (count &lt;= 0) &#123; throw new IllegalArgumentException("count must large than zero."); &#125; setState(count); &#125; public int tryAcquireShared(int reduceCount) &#123; for (;;) &#123; int current = getState(); int newCount = current - reduceCount; if (newCount &lt; 0 || compareAndSetState(current, newCount)) &#123; return newCount; &#125; &#125; &#125; public boolean tryReleaseShared(int returnCount) &#123; for (;;) &#123; int current = getState(); int newCount = current + returnCount; if (compareAndSetState(current, newCount)) &#123; return true; &#125; &#125; &#125; &#125; public void lock() &#123; sync.acquireShared(1); &#125; public void lockInterruptibly() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1); &#125; public boolean tryLock() &#123; return sync.tryAcquireShared(1) &gt;= 0; &#125; public boolean tryLock(long time, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(time)); &#125; public void unlock() &#123; sync.releaseShared(1); &#125; @Override public Condition newCondition() &#123; return null; &#125;&#125; 上述测试用例的逻辑主要包括： 打印线程Worker在两次睡眠之间打印自身线程，如果一个时刻只能有两个线程同时访问，那么打印出来的内容将是成对出现。 分隔线程不停的打印换行，能让Worker的输出看起来更加直观。该测试的结果是在一个时刻，仅有两个线程能够获得到锁，并完成打印，而表象就是打印的内容成对出现。 四、总结AQS简核心是通过一个共享变量来同步状态，变量的状态由子类去维护，而AQS框架做的是： 线程阻塞队列的维护 线程阻塞和唤醒 共享变量的修改都是通过Unsafe类提供的CAS操作完成的。AbstractQueuedSynchronizer类的主要方法是acquire和release，典型的模板方法， 下面这4个方法由子类去实现： 1234protected boolean tryAcquire(int arg)protected boolean tryRelease(int arg)protected int tryAcquireShared(int arg)protected boolean tryReleaseShared(int arg) acquire方法用来获取锁，返回true说明线程获取成功继续执行，一旦返回false则线程加入到等待队列中，等待被唤醒，release方法用来释放锁。 一般来说实现的时候这两个方法被封装为lock和unlock方法。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAS原子操作]]></title>
    <url>%2F2018%2F06%2F08%2FCAS%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[乐观锁与悲观锁我们都知道，cpu是时分复用的，也就是把cpu的时间片，分配给不同的thread/process轮流执行，时间片与时间片之间，需要进行cpu切换，也就是会发生进程的切换。切换涉及到清空寄存器，缓存数据。然后重新加载新的thread所需数据。当一个线程被挂起时，加入到阻塞队列，在一定的时间或条件下，在通过notify()，notifyAll()唤醒回来。在某个资源不可用的时候，就将cpu让出，把当前等待线程切换为阻塞状态。等到资源(比如一个共享数据）可用了，那么就将线程唤醒，让他进入runnable状态等待cpu调度。这就是典型的悲观锁的实现。独占锁是一种悲观锁，synchronized就是一种独占锁，它假设最坏的情况，认为一个线程修改共享数据的时候其他线程也会修改该数据，因此只在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。 但是，由于在进程挂起和恢复执行过程中存在着很大的开销。当一个线程正在等待锁时，它不能做任何事，所以悲观锁有很大的缺点。举个例子，如果一个线程需要某个资源，但是这个资源的占用时间很短，当线程第一次抢占这个资源时，可能这个资源被占用，如果此时挂起这个线程，可能立刻就发现资源可用，然后又需要花费很长的时间重新抢占锁，时间代价就会非常的高。 所以就有了乐观锁的概念，他的核心思路就是，每次不加锁而是假设修改数据之前其他线程一定不会修改，如果因为修改过产生冲突就失败就重试，直到成功为止。在上面的例子中，某个线程可以不让出cpu,而是一直while循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。比如CAS就是一种乐观锁思想的应用。 CASCAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。执行CAS操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。 举个CAS操作的应用场景的一个例子，当一个线程需要修改共享变量的值。完成这个操作，先取出共享变量的值赋给A，然后基于A的基础进行计算，得到新值B，完了需要更新共享变量的值了，这个时候就可以调用CAS方法更新变量值了。 在java中可以通过锁和循环CAS的方式来实现原子操作。Java中 java.util.concurrent.atomic包相关类就是 CAS的实现，atomic包里包括以下类： 类名 说明 AtomicBoolean 可以用原子方式更新的 boolean 值。 AtomicInteger 可以用原子方式更新的 int 值。 AtomicIntegerArray 可以用原子方式更新其元素的 int 数组。 AtomicIntegerFieldUpdater 基于反射的实用工具，可以对指定类的指定 volatile int 字段进行原子更新。 AtomicLong 可以用原子方式更新的 long 值。 AtomicLongArray 可以用原子方式更新其元素的 long 数组。 AtomicLongFieldUpdater 基于反射的实用工具，可以对指定类的指定 volatile long 字段进行原子更新。 AtomicMarkableReference AtomicMarkableReference 维护带有标记位的对象引用，可以原子方式对其进行更新。 AtomicReference 可以用原子方式更新的对象引用。 AtomicReferenceArray 可以用原子方式更新其元素的对象引用数组。 AtomicReferenceFieldUpdater 基于反射的实用工具，可以对指定类的指定 volatile 字段进行原子更新。 AtomicStampedReference AtomicStampedReference 维护带有整数“标志”的对象引用，可以用原子方式对其进行更新。 下面我们来已AtomicIneger的源码为例来看看CAS操作： 12345678public final int getAndAdd(int delta) &#123; for (;;) &#123; int current = get(); int next = current + delta; if (compareAndSet(current, next)) return current; &#125; &#125; 这里很显然使用CAS操作（for(;;)里面），他每次都从内存中读取数据，+1操作，然后两个值进行CAS操作。如果成功则返回，否则失败重试，直到修改成功为止。上面源码最关键的地方有两个，一个for循环，它代表着一种宁死不屈的精神，不成功誓不罢休。还有就是compareAndSet： 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update); &#125; compareAndSet方法内部是调用Java本地方法compareAndSwapInt来实现的，而compareAndSwapInt方法内部又是借助C来调用CPU的底层指令来保证在硬件层面上实现原子操作的。在intel处理器中，CAS是通过调用cmpxchg指令完成的。这就是我们常说的CAS操作（compare and swap）。 CAS的问题CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。 ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。 循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字]]></title>
    <url>%2F2018%2F06%2F08%2Fvolatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一、Java内存模型想要理解volatile为什么能确保可见性，就要先理解Java中的内存模型是什么样的。 Java内存模型规定了所有的变量都存储在主内存中。每条线程中还有自己的工作内存，线程的工作内存中保存了被该线程所使用到的变量（这些变量是从主内存中拷贝而来）。线程对变量的所有操作（读取，赋值）都必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 基于此种内存模型，便产生了多线程编程中的数据“脏读”等问题。 举个简单的例子：在java中，执行下面这个语句：1i = 10; 执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。 比如同时有2个线程执行这段代码，假如初始时i的值为10，那么我们希望两个线程执行完之后i的值变为12。但是事实会是这样吗？ 可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的工作内存当中，然后线程1进行加1操作，然后把i的最新值11写入到内存。此时线程2的工作内存当中i的值还是10，进行加1操作之后，i的值为11，然后线程2把i的值写入内存。 最终结果i的值是11，而不是12。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。 那么如何确保共享变量在多线程访问时能够正确输出结果呢？ 在解决这个问题之前，我们要先了解并发编程的三大概念：原子性，有序性，可见性。 二、原子性1.定义原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 2.实例一个很经典的例子就是银行账户转账问题： 比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。 试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。 所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。 同样地反映到并发编程中会出现什么结果呢？ 举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？12345678910111213141516i = 9;``` 假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。### 3.Java中的原子性在Java中，**对基本数据类型的变量的读取和赋值操作是原子性操作**，即这些操作是不可被中断的，要么执行，要么不执行。上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：请分析以下哪些操作是原子性操作：```javax = 10; //语句1y = x; //语句2x++; //语句3x = x + 1; //语句4 咋一看，可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。 同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。 所以上面4个语句只有语句1的操作具备原子性。 也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。 从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。 三、可见性1.定义可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 2.实例举个简单的例子，看下面这段代码：123456//线程1执行的代码int i = 0;i = 10; //线程2执行的代码j = i; 由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到工作内存中，然后赋值为10，那么在线程1的工作内存当中i的值变为10了，却没有立即写入到主存当中。 此时线程2执行 j = i，它会先去主存读取i的值并加载到线程2的工作内存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10. 这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。 3.Java中的可见性对于可见性，Java提供了volatile关键字来保证可见性。 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。 四、有序性1.定义有序性：即程序执行的顺序按照代码的先后顺序执行。 2.实例举个简单的例子，看下面这段代码：123456int i = 0; boolean flag = false;i = 1; //语句1 flag = true; //语句2 上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。 下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。 比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。 但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：1234int a = 10; //语句1int r = 2; //语句2a = a + 3; //语句3r = a*a; //语句4 这段代码有4个语句，那么可能的一个执行顺序是： 那么可不可能是这个执行顺序呢： 语句2 语句1 语句4 语句3 不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。 虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：12345678910//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。 从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。 也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。 3.Java中的有序性在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。 另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。 ####下面就来具体介绍下happens-before原则（先行发生原则）： ①程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 ②锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作 ③volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 ④传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C ⑤线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作 ⑥线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生 ⑦线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 ⑧对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始 这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。 下面我们来解释一下前4条规则： 对于程序次序规则来说，就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，但是虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。 第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。 第三条规则是一条比较重要的规则。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。 第四条规则实际上就是体现happens-before原则具备传递性。 五、深入理解volatile关键字1.volatile保证可见性一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义： 1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。 2）禁止进行指令重排序。 先看一段代码，假如线程1先执行，线程2后执行：12345678//线程1boolean stop = false;while(!stop)&#123; doSomething();&#125; //线程2stop = true; 这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。 下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。 那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。 但是用volatile修饰之后就变得不一样了： 第一：使用volatile关键字会强制将修改的值立即写入主存； 第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）； 第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。 那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。 那么线程1读取到的就是最新的正确的值。 2.volatile不能确保原子性下面看一个例子：1234567891011121314151617181920212223public class Test &#123; public volatile int inc = 0; public void increase() &#123; inc++; &#125; public static void main(String[] args) &#123; final Test test = new Test(); for(int i=0;i&lt;10;i++)&#123; new Thread()&#123; public void run() &#123; for(int j=0;j&lt;1000;j++) test.increase(); &#125;; &#125;.start(); &#125; while(Thread.activeCount()&gt;1) //保证前面的线程都执行完 Thread.yield(); System.out.println(test.inc); &#125;&#125; 大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。 可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。 这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。 在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现： 假如某个时刻变量inc的值为10， 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了； 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，也不会导致主存中的值刷新，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。 那么两个线程分别进行了一次自增操作后，inc只增加了1。 根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。 解决方案：可以通过synchronized或lock，进行加锁，来保证操作的原子性。也可以通过AtomicInteger。 在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。 3.volatile保证有序性在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。 volatile关键字禁止指令重排序有两层意思： 1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行； 2）在进行指令优化时，不能将在对volatile变量的读操作或者写操作的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。 可能上面说的比较绕，举个简单的例子：12345678//x、y为非volatile变量//flag为volatile变量 x = 2; //语句1y = 0; //语句2flag = true; //语句3x = 4; //语句4y = -1; //语句5 由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。 并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。 那么我们回到前面举的一个例子：123456789//线程1:context = loadContext(); //语句1inited = true; //语句2 //线程2:while(!inited )&#123; sleep()&#125;doSomethingwithconfig(context); 前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。 这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。 ##六、volatile的实现原理 1.可见性处理器为了提高处理速度，不直接和内存进行通讯，而是将系统内存的数据独到内部缓存后再进行操作，但操作完后不知什么时候会写到内存。 如果对声明了volatile变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写会到系统内存。 这一步确保了如果有其他线程对声明了volatile变量进行修改，则立即更新主内存中数据。 但这时候其他处理器的缓存还是旧的，所以在多处理器环境下，为了保证各个处理器缓存一致，每个处理会通过嗅探在总线上传播的数据来检查 自己的缓存是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作时，会强制重新从系统内存把数据读到处理器缓存里。 这一步确保了其他线程获得的声明了volatile变量都是从主内存中获取最新的。 2.有序性Lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成。 七、volatile的应用场景synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件： 1）对变量的写操作不依赖于当前值 2）该变量没有包含在具有其他变量的不变式中 下面列举几个Java中使用volatile的几个场景。 ①.状态标记量123456789volatile boolean flag = false; //线程1while(!flag)&#123; doSomething();&#125; //线程2public void setFlag() &#123; flag = true;&#125; 根据状态标记，终止线程。 ②.单例模式中的double check1234567891011121314151617class Singleton&#123; private volatile static Singleton instance = null; private Singleton() &#123; &#125; public static Singleton getInstance() &#123; if(instance==null) &#123; synchronized (Singleton.class) &#123; if(instance==null) instance = new Singleton(); &#125; &#125; return instance; &#125;&#125; 为什么要使用volatile 修饰instance？主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情: 1.给 instance 分配内存 2.调用 Singleton 的构造函数来初始化成员变量 3.将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了）。 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生产者/消费者模式]]></title>
    <url>%2F2018%2F06%2F08%2F%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、线程间通信的两种方式1.wait()/notify()Object类中相关的方法有notify方法和wait方法。因为wait和notify方法定义在Object类中，因此会被所有的类所继承。这些方法都是final的，即它们都是不能被重写的，不能通过子类覆写去改变它们的行为。 ①wait()方法：让当前线程进入等待，并释放锁。 ②wait(long)方法：让当前线程进入等待，并释放锁，不过等待时间为long，超过这个时间没有对当前线程进行唤醒，将自动唤醒。 ③notify()方法：让当前线程通知那些处于等待状态的线程，当前线程执行完毕后释放锁，并从其他线程中唤醒其中一个继续执行。 ④notifyAll()方法：让当前线程通知那些处于等待状态的线程，当前线程执行完毕后释放锁，将唤醒所有等待状态的线程。 wait()方法使用注意事项①当前的线程必须拥有当前对象的monitor，也即lock，就是锁，才能调用wait()方法，否则将抛出异常java.lang.IllegalMonitorStateException。 ②线程调用wait()方法，释放它对锁的拥有权，然后等待另外的线程来通知它（通知的方式是notify()或者notifyAll()方法），这样它才能重新获得锁的拥有权和恢复执行。 ③要确保调用wait()方法的时候拥有锁，即，wait()方法的调用必须放在synchronized方法或synchronized块中。wait()与sleep()比较 当线程调用了wait()方法时，它会释放掉对象的锁。 Thread.sleep()，它会导致线程睡眠指定的毫秒数，但线程在睡眠的过程中是不会释放掉对象的锁的。 notify()方法使用注意事项①如果多个线程在等待，它们中的一个将会选择被唤醒。这种选择是随意的，和具体实现有关。（线程等待一个对象的锁是由于调用了wait()方法）。 ②被唤醒的线程是不能被执行的，需要等到当前线程放弃这个对象的锁，当前线程会在方法执行完毕后释放锁。 wait()/notify()协作的两个注意事项①通知过早 如果通知过早，则会打乱程序的运行逻辑。 1234567891011121314151617181920212223242526272829public class MyRun &#123; private String lock = new String(""); public Runnable runnableA = new Runnable() &#123; @Override public void run() &#123; try &#123; synchronized (lock) &#123; System.out.println("begin wait"); lock.wait(); System.out.println("end wait"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; public Runnable runnableB = new Runnable() &#123; @Override public void run() &#123; synchronized (lock) &#123; System.out.println("begin notify"); lock.notify(); System.out.println("end notify"); &#125; &#125; &#125;;&#125; 两个方法，分别执行wait()/notify()方法。 12345678public static void main(String[] args) throws InterruptedException &#123; MyRun run = new MyRun(); Thread bThread = new Thread(run.runnableB); bThread.start(); Thread.sleep(100); Thread aThread = new Thread(run.runnableA); aThread.start(); &#125; 如果notify()方法先执行，将导致wait()方法释放锁进入等待状态后，永远无法被唤醒，影响程序逻辑。应避免这种情况。 ②等待wait的条件发生变化 在使用wait/notify模式时，还需要注意另外一种情况，也就是wait等待条件发生了变化，也容易造成程序逻辑的混乱。 Add类，执行加法操作，然后通知Subtract类 1234567891011121314public class Add &#123; private String lock; public Add(String lock) &#123; super(); this.lock = lock; &#125; public void add()&#123; synchronized (lock) &#123; ValueObject.list.add("anyThing"); lock.notifyAll(); &#125; &#125;&#125; Subtract类，执行减法操作，执行完后进入等待状态，等待Add类唤醒notify 1234567891011121314151617181920212223public class Subtract &#123; private String lock; public Subtract(String lock) &#123; super(); this.lock = lock; &#125; public void subtract()&#123; try &#123; synchronized (lock) &#123; if(ValueObject.list.size()==0)&#123; System.out.println("wait begin ThreadName="+Thread.currentThread().getName()); lock.wait(); System.out.println("wait end ThreadName="+Thread.currentThread().getName()); &#125; ValueObject.list.remove(0); System.out.println("list size ="+ValueObject.list.size()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 线程ThreadAdd 12345678910111213public class ThreadAdd extends Thread&#123; private Add pAdd; public ThreadAdd(Add pAdd) &#123; super(); this.pAdd = pAdd; &#125; @Override public void run() &#123; pAdd.add(); &#125;&#125; 线程ThreadSubtract 12345678910111213public class ThreadSubtract extends Thread&#123; private Subtract rSubtract; public ThreadSubtract(Subtract rSubtract) &#123; super(); this.rSubtract = rSubtract; &#125; @Override public void run() &#123; rSubtract.subtract(); &#125;&#125; 先开启两个ThreadSubtract线程，由于list中没有元素，进入等待状态。再开启一个ThreadAdd线程，向list中增加一个元素，然后唤醒两个ThreadSubtract线程 123456789101112131415public static void main(String[] args) throws InterruptedException &#123; String lock = new String(""); Add add = new Add(lock); Subtract subtract = new Subtract(lock); ThreadSubtract subtractThread1 = new ThreadSubtract(subtract); subtractThread1.setName("subtractThread1"); subtractThread1.start(); ThreadSubtract subtractThread2 = new ThreadSubtract(subtract); subtractThread2.setName("subtractThread2"); subtractThread2.start(); Thread.sleep(1000); ThreadAdd addThread = new ThreadAdd(add); addThread.setName("addThread"); addThread.start(); &#125; 输出结果 wait begin ThreadName=subtractThread1wait begin ThreadName=subtractThread2wait end ThreadName=subtractThread2Exception in thread “subtractThread1” list size =0wait end ThreadName=subtractThread1java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at java.util.ArrayList.rangeCheck(Unknown Source) at java.util.ArrayList.remove(Unknown Source) at com.lvr.communication.Subtract.subtract(Subtract.java:18) at com.lvr.communication.ThreadSubtract.run(ThreadSubtract.java:12) 当第二个ThreadSubtract线程执行减法操作时，抛出下标越界异常。 原因分析：一开始两个ThreadSubtract线程等待状态，当ThreadAdd线程添加一个元素并唤醒所有线程后，第一个ThreadSubtract线程接着原来的执行到的地点开始继续执行，删除一个元素并输出集合大小。同样，第二个ThreadSubtract线程也如此，可是此时集合中已经没有元素了，所以抛出异常。 解决办法：从等待状态被唤醒后，重新判断条件，看看是否扔需要进入等待状态，不需要进入再进行下一步操作。即把if()判断，改成while()。 123456789101112131415public void subtract()&#123; try &#123; synchronized (lock) &#123; while(ValueObject.list.size()==0)&#123; System.out.println("wait begin ThreadName="+Thread.currentThread().getName()); lock.wait(); System.out.println("wait end ThreadName="+Thread.currentThread().getName()); &#125; ValueObject.list.remove(0); System.out.println("list size ="+ValueObject.list.size()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; 这是线程间协作中经常出现的一种情况，需要避免。 2.Condition实现等待/通知关键字synchronized与wait()和notify()/notifyAll()方法相结合可以实现等待/通知模式，类似ReentrantLock也可以实现同样的功能，但需要借助于Condition对象。 关于Condition实现等待/通知就不详细介绍了，可以完全类比wait()/notify()，基本使用和注意事项完全一致。就只简单介绍下类比情况： condition.await()————&gt;lock.wait() condition.await(long time, TimeUnit unit)————&gt;lock.wait(long timeout) condition.signal()————&gt;lock.notify() condition.signaAll()————&gt;lock.notifyAll() 特殊之处：synchronized相当于整个ReentrantLock对象只有一个单一的Condition对象情况。而一个ReentrantLock却可以拥有多个Condition对象，来实现通知部分线程。 具体实现方式：假设有两个Condition对象：ConditionA和ConditionB。那么由ConditionA.await()方法进入等待状态的线程，由ConditionA.signalAll()通知唤醒；由ConditionB.await()方法进入等待状态的线程，由ConditionB.signalAll()通知唤醒。篇幅有限，代码示例就不写了。 二、生产者/消费者模式实现1.一生产与一消费下面情形是一个生产者，一个消费者的模式。假设场景：一个String对象，其中生产者为其设置值，消费者拿走其中的值，不断的循环往复，实现生产者/消费者的情形。 wait()/notify()实现 生产者 123456789101112131415161718192021222324public class Product &#123; private String lock; public Product(String lock) &#123; super(); this.lock = lock; &#125; public void setValue()&#123; try &#123; synchronized (lock) &#123; if(!StringObject.value.equals(""))&#123; //有值，不生产 lock.wait(); &#125; String value = System.currentTimeMillis()+""+System.nanoTime(); System.out.println("set的值是："+value); StringObject.value = value; lock.notify(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 消费者 1234567891011121314151617181920212223public class Consumer &#123; private String lock; public Consumer(String lock) &#123; super(); this.lock = lock; &#125; public void getValue()&#123; try &#123; synchronized (lock) &#123; if(StringObject.value.equals(""))&#123; //没值，不进行消费 lock.wait(); &#125; System.out.println("get的值是："+StringObject.value); StringObject.value = ""; lock.notify(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 生产者线程 12345678910111213141516public class ThreadProduct extends Thread&#123; private Product product; public ThreadProduct(Product product) &#123; super(); this.product = product; &#125; @Override public void run() &#123; //死循环，不断的生产 while(true)&#123; product.setValue(); &#125; &#125;&#125; 消费者线程 12345678910111213141516public class ThreadConsumer extends Thread&#123; private Consumer consumer; public ThreadConsumer(Consumer consumer) &#123; super(); this.consumer = consumer; &#125; @Override public void run() &#123; //死循环，不断的消费 while(true)&#123; consumer.getValue(); &#125; &#125;&#125; 开启生产者/消费者模式 12345678910111213public class Test &#123; public static void main(String[] args) throws InterruptedException &#123; String lock = new String(""); Product product = new Product(lock); Consumer consumer = new Consumer(lock); ThreadProduct pThread = new ThreadProduct(product); ThreadConsumer cThread = new ThreadConsumer(consumer); pThread.start(); cThread.start(); &#125;&#125; 输出结果： set的值是：148827033184127168687409691get的值是：148827033184127168687409691set的值是：148827033184127168687449887get的值是：148827033184127168687449887set的值是：148827033184127168687475117get的值是：148827033184127168687475117 Condition方式实现类似，篇幅有限不全部贴出来。 2.多生产与多消费特殊情况：按照上述一生产与一消费的情况，通过创建多个生产者和消费者线程，实现多生产与多消费的情况，将会出现“假死”。 具体原因：多个生产者和消费者线程。当全部运行后，生产者线程生产数据后，可能唤醒的同类即生产者线程。此时可能会出现如下情况：所有生产者线程进入等待状态，然后消费者线程消费完数据后，再次唤醒的还是消费者线程，直至所有消费者线程都进入等待状态，此时将进入“假死”。 解决方法：将notify()或signal()方法改为notifyAll()或signalAll()方法，这样就不怕因为唤醒同类而进入“假死”状态了。 Condition方式实现生产者 123456789101112131415161718192021222324252627282930public class Product &#123; private ReentrantLock lock; private Condition condition; public Product(ReentrantLock lock, Condition condition) &#123; super(); this.lock = lock; this.condition = condition; &#125; public void setValue() &#123; try &#123; lock.lock(); while (!StringObject.value.equals("")) &#123; // 有值，不生产 condition.await(); &#125; String value = System.currentTimeMillis() + "" + System.nanoTime(); System.out.println("set的值是：" + value); StringObject.value = value; condition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 消费者 123456789101112131415161718192021222324252627public class Consumer &#123; private ReentrantLock lock; private Condition condition; public Consumer(ReentrantLock lock,Condition condition) &#123; super(); this.lock = lock; this.condition = condition; &#125; public void getValue()&#123; try &#123; lock.lock(); while(StringObject.value.equals(""))&#123; //没值，不进行消费 condition.await(); &#125; System.out.println("get的值是："+StringObject.value); StringObject.value = ""; condition.signalAll(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;&#125; 生产者线程和消费者线程与一生产一消费的模式相同。 开启多生产/多消费模式 12345678910111213public static void main(String[] args) throws InterruptedException &#123; ReentrantLock lock = new ReentrantLock(); Condition newCondition = lock.newCondition(); Product product = new Product(lock,newCondition); Consumer consumer = new Consumer(lock,newCondition); for(int i=0;i&lt;3;i++)&#123; ThreadProduct pThread = new ThreadProduct(product); ThreadConsumer cThread = new ThreadConsumer(consumer); pThread.start(); cThread.start(); &#125; &#125; 输出结果: set的值是：148827212374628960540784817get的值是：148827212374628960540784817set的值是：148827212374628960540810047get的值是：148827212374628960540810047 可见交替地进行get/set实现多生产/多消费模式。注意：相比一生产一消费的模式，改动了两处。①signal()–&gt;signalAll()避免进入“假死”状态。②if()判断–&gt;while()循环，重新判断条件，避免逻辑混乱。 以上就是Java线程间通信的相关知识，以生产者/消费者模式为例，讲解线程间通信的使用以及注意事项。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Synchronized/ReentrantLock]]></title>
    <url>%2F2018%2F06%2F08%2FSynchronized-ReentrantLock%2F</url>
    <content type="text"><![CDATA[###一、线程同步问题的产生及解决方案问题的产生：Java允许多线程并发控制，当多个线程同时操作一个可共享的资源变量时（如数据的增删改查），将会导致数据不准确，相互之间产生冲突。如下例：假设有一个卖票系统，一共有100张票，有4个窗口同时卖。1234567891011121314151617public class Ticket implements Runnable &#123; // 当前拥有的票数 private int num = 100; public void run() &#123; while (true) &#123; if (num &gt; 0) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; &#125; // 输出卖票信息 System.out.println(Thread.currentThread().getName() + &quot;.....sale....&quot; + num--); &#125; &#125; &#125;&#125; 12345678910111213public static void main(String[] args) &#123; Ticket t = new Ticket();//创建一个线程任务对象。 //创建4个线程同时卖票 Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); Thread t4 = new Thread(t); //启动线程 t1.start(); t2.start(); t3.start(); t4.start(); &#125; 输出部分结果： Thread-1…..sale….2Thread-0…..sale….3Thread-2…..sale….1Thread-0…..sale….0Thread-1…..sale….0Thread-3…..sale….1 显然上述结果是不合理的，对于同一张票进行了多次售出。这就是多线程情况下，出现了数据“脏读”情况。即多个线程访问余票num时，当一个线程获得余票的数量，要在此基础上进行-1的操作之前，其他线程可能已经卖出多张票，导致获得的num不是最新的，然后-1后更新的数据就会有误。这就需要线程同步的实现了。 问题的解决：因此加入同步锁以避免在该线程没有完成操作之前，被其他线程的调用，从而保证了该变量的唯一性和准确性。 一共有两种锁，来实现线程同步问题，分别是：synchronized和ReentrantLock。下面我们就带着上述问题，看看这两种锁是如何解决的。 ####二、synchronized关键字 #####1.synchronized简介synchronized实现同步的基础：Java中每个对象都可以作为锁。当线程试图访问同步代码时，必须先获得对象锁，退出或抛出异常时必须释放锁。Synchronzied实现同步的表现形式分为：代码块同步和方法同步。 #####2.synchronized原理JVM基于进入和退出Monitor对象来实现代码块同步和方法同步，两者实现细节不同。 代码块同步：在编译后通过将monitorenter指令插入到同步代码块的开始处，将monitorexit指令插入到方法结束处和异常处，通过反编译字节码可以观察到。任何一个对象都有一个monitor与之关联，线程执行monitorenter指令时，会尝试获取对象对应的monitor的所有权，即尝试获得对象的锁。 方法同步：synchronized方法在method_info结构有ACC_synchronized标记，线程执行时会识别该标记，获取对应的锁，实现方法同步。 两者虽然实现细节不同，但本质上都是对一个对象的监视器（monitor）的获取。任意一个对象都拥有自己的监视器，当同步代码块或同步方法时，执行方法的线程必须先获得该对象的监视器才能进入同步块或同步方法，没有获取到监视器的线程将会被阻塞，并进入同步队列，状态变为BLOCKED。当成功获取监视器的线程释放了锁后，会唤醒阻塞在同步队列的线程，使其重新尝试对监视器的获取。 对象、监视器、同步队列和执行线程间的关系如下图： #####3.synchronized的使用场景①方法同步1public synchronized void method1 锁住的是该对象,类的其中一个实例，当该对象(仅仅是这一个对象)在不同线程中执行这个同步方法时，线程之间会形成互斥。达到同步效果，但如果不同线程同时对该类的不同对象执行这个同步方法时，则线程之间不会形成互斥，因为他们拥有的是不同的锁。 ②代码块同步1synchronized(this)&#123; //TODO &#125; 描述同① ③方法同步1public synchronized static void method3 锁住的是该类，当所有该类的对象(多个对象)在不同线程中调用这个static同步方法时，线程之间会形成互斥，达到同步效果。 ④代码块同步1synchronized(Test.class)&#123; //TODO&#125; 同③ ⑤代码块同步1synchronized(o) &#123;&#125; 这里面的o可以是一个任何Object对象或数组，并不一定是它本身对象或者类，谁拥有o这个锁，谁就能够操作该块程序代码。 #####4.解决线程同步的实例针对上述方法，具体的解决方式如下：1234567891011121314151617181920public class Ticket implements Runnable &#123; // 当前拥有的票数 private int num = 100; public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; &#125; synchronized (this) &#123; // 输出卖票信息 if(num&gt;0)&#123; System.out.println(Thread.currentThread().getName() + &quot;.....sale....&quot; + num--); &#125; &#125; &#125; &#125;&#125; 输出部分结果： Thread-2…..sale….10Thread-1…..sale….9Thread-3…..sale….8Thread-0…..sale….7Thread-2…..sale….6Thread-1…..sale….5Thread-2…..sale….4Thread-1…..sale….3Thread-3…..sale….2Thread-0…..sale….1 可以看出实现了线程同步。同时改了一下逻辑，在进入到同步代码块时，先判断现在是否有没有票，然后再买票，防止出现没票还要售出的情况。通过同步代码块实现了线程同步，其他方法也一样可以实现该效果。 ###三、ReentrantLock锁 #####1.Lock接口Lock，锁对象。在Java中锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但有的锁可以允许多个线程并发访问共享资源，比如读写锁，后面我们会分析）。在Lock接口出现之前，Java程序是靠synchronized关键字（后面分析）实现锁功能的，而JAVA SE5.0之后并发包中新增了Lock接口用来实现锁的功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁，缺点就是缺少像synchronized那样隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。 Lock接口的主要方法（还有两个方法比较复杂，暂不介绍）： void lock(): 执行此方法时, 如果锁处于空闲状态, 当前线程将获取到锁. 相反, 如果锁已经被其他线程持有, 将禁用当前线程, 直到当前线程获取到锁.boolean tryLock()：如果锁可用, 则获取锁, 并立即返回true, 否则返回false. 该方法和lock()的区别在于, tryLock()只是”试图”获取锁, 如果锁不可用, 不会导致当前线程被禁用, 当前线程仍然继续往下执行代码. 而lock()方法则是一定要获取到锁, 如果锁不可用, 就一直等待, 在未获得锁之前,当前线程并不继续向下执行. 通常采用如下的代码形式调用tryLock()方法:void unlock()：执行此方法时, 当前线程将释放持有的锁. 锁只能由持有者释放, 如果线程并不持有锁, 却执行该方法, 可能导致异常的发生.Condition newCondition()：条件对象，获取等待通知组件。该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await()方法，而调用后，当前线程将缩放锁。 ReentrantLock，一个可重入的互斥锁，它具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。（重入锁后面介绍） #####2.ReentrantLock的使用关于ReentrantLock的使用很简单，只需要显示调用，获得同步锁，释放同步锁即可。12345678ReentrantLock lock = new ReentrantLock(); //参数默认false，不公平锁 ..................... lock.lock(); //如果被其它资源锁定，会在此等待锁释放，达到暂停的效果 try &#123; //操作 &#125; finally &#123; lock.unlock(); //释放锁 &#125; #####3.解决线程同步的实例针对上述方法，具体的解决方式如下：12345678910111213141516171819202122public class Ticket implements Runnable &#123; // 当前拥有的票数 private int num = 100; ReentrantLock lock = new ReentrantLock(); public void run() &#123; while (true) &#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; &#125; lock.lock(); // 输出卖票信息 if (num &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;.....sale....&quot; + num--); &#125; lock.unlock(); &#125; &#125;&#125; ###四、重入锁当一个线程得到一个对象后，再次请求该对象锁时是可以再次得到该对象的锁的。具体概念就是：自己可以再次获取自己的内部锁。Java里面内置锁(synchronized)和Lock(ReentrantLock)都是可重入的。12345678910111213141516public class SynchronizedTest &#123; public void method1() &#123; synchronized (SynchronizedTest.class) &#123; System.out.println(&quot;方法1获得ReentrantTest的锁运行了&quot;); method2(); &#125; &#125; public void method2() &#123; synchronized (SynchronizedTest.class) &#123; System.out.println(&quot;方法1里面调用的方法2重入锁,也正常运行了&quot;); &#125; &#125; public static void main(String[] args) &#123; new SynchronizedTest().method1(); &#125;&#125; 上面便是synchronized的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时，由于本身已经具有该锁，所以可以再次获取。1234567891011121314151617181920212223public class ReentrantLockTest &#123; private Lock lock = new ReentrantLock(); public void method1() &#123; lock.lock(); try &#123; System.out.println(&quot;方法1获得ReentrantLock锁运行了&quot;); method2(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void method2() &#123; lock.lock(); try &#123; System.out.println(&quot;方法1里面调用的方法2重入ReentrantLock锁,也正常运行了&quot;); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; new ReentrantLockTest().method1(); &#125;&#125; 上面便是ReentrantLock的重入锁特性，即调用method1()方法时，已经获得了锁，此时内部调用method2()方法时，由于本身已经具有该锁，所以可以再次获取。 ###五、公平锁CPU在调度线程的时候是在等待队列里随机挑选一个线程，由于这种随机性所以是无法保证线程先到先得的（synchronized控制的锁就是这种非公平锁）。但这样就会产生饥饿现象，即有些线程（优先级较低的线程）可能永远也无法获取CPU的执行权，优先级高的线程会不断的强制它的资源。那么如何解决饥饿问题呢，这就需要公平锁了。公平锁可以保证线程按照时间的先后顺序执行，避免饥饿现象的产生。但公平锁的效率比较低，因为要实现顺序执行，需要维护一个有序队列。 ReentrantLock便是一种公平锁，通过在构造方法中传入true就是公平锁，传入false，就是非公平锁。123public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; 以下是使用公平锁实现的效果：123456789101112131415161718192021public class LockFairTest implements Runnable&#123; //创建公平锁 private static ReentrantLock lock=new ReentrantLock(true); public void run() &#123; while(true)&#123; lock.lock(); try&#123; System.out.println(Thread.currentThread().getName()+&quot;获得锁&quot;); &#125;finally&#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; LockFairTest lft=new LockFairTest(); Thread th1=new Thread(lft); Thread th2=new Thread(lft); th1.start(); th2.start(); &#125;&#125; 输出结果： Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁Thread-1获得锁Thread-0获得锁 这是截取的部分执行结果，分析结果可看出两个线程是交替执行的，几乎不会出现同一个线程连续执行多次。 ###六、synchronized和ReentrantLock的比较 #####1.区别： 1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现； 2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁； 3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断； 4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。 5）Lock可以提高多个线程进行读操作的效率。 总结：ReentrantLock相比synchronized，增加了一些高级的功能。但也有一定缺陷。在ReentrantLock类中定义了很多方法，比如：1234567isFair() //判断锁是否是公平锁isLocked() //判断锁是否被任何线程获取了isHeldByCurrentThread() //判断锁是否被当前线程获取了hasQueuedThreads() //判断是否有线程在等待该锁 #####2.两者在锁的相关概念上区别：1)可中断锁顾名思义，就是可以相应中断的锁。 在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。 lockInterruptibly()的用法体现了Lock的可中断性。 2)公平锁 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁（并不是绝对的，大体上是这种顺序），这种就是公平锁。 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。 在Java中，synchronized就是非公平锁，它无法保证等待的线程获取锁的顺序。ReentrantLock可以设置成公平锁。 3)读写锁 读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。 正因为有了读写锁，才使得多个线程之间的读操作可以并发进行，不需要同步，而写操作需要同步进行，提高了效率。 ReadWriteLock就是读写锁，它是一个接口，ReentrantReadWriteLock实现了这个接口。 可以通过readLock()获取读锁，通过writeLock()获取写锁。 4)绑定多个条件 一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多余一个条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这么做，只需要多次调用new Condition()方法即可。 #####3.性能比较在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时ReentrantLock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。 在JDK1.5中，synchronized是性能低效的。因为这是一个重量级操作，它对性能最大的影响是阻塞的是实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性带来了很大的压力。相比之下使用Java提供的ReentrankLock对象，性能更高一些。到了JDK1.6，发生了变化，对synchronize加入了很多优化措施，有自适应自旋，锁消除，锁粗化，轻量级锁，偏向锁等等。导致在JDK1.6上synchronize的性能并不比Lock差。官方也表示，他们也更支持synchronize，在未来的版本中还有优化余地，所以还是提倡在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[死锁]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[一、死锁产生的条件一般来说，要出现死锁问题需要满足以下条件： 互斥条件：一个资源每次只能被一个线程使用。 请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：线程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。 在JAVA编程中，有3种典型的死锁类型：静态的锁顺序死锁，动态的锁顺序死锁，协作对象之间发生的死锁。 二、静态的锁顺序死锁a和b两个方法都需要获得A锁和B锁。一个线程执行a方法且已经获得了A锁，在等待B锁；另一个线程执行了b方法且已经获得了B锁，在等待A锁。这种状态，就是发生了静态的锁顺序死锁。 1234567891011121314151617181920//可能发生静态锁顺序死锁的代码 class StaticLockOrderDeadLock&#123; private final Object lockA=new Object(); private final Object lockB=new Object(); public void a()&#123; synchronized (lockA) &#123; synchronized (lockB) &#123; System.out.println("function a"); &#125; &#125; &#125; public void b()&#123; synchronized (lockB) &#123; synchronized (lockA) &#123; System.out.println("function b"); &#125; &#125; &#125; &#125; 解决静态的锁顺序死锁的方法就是：所有需要多个锁的线程，都要以相同的顺序来获得锁。 1234567891011121314151617181920//正确的代码 class StaticLockOrderDeadLock&#123; private final Object lockA=new Object(); private final Object lockB=new Object(); public void a()&#123; synchronized (lockA) &#123; synchronized (lockB) &#123; System.out.println("function a"); &#125; &#125; &#125; public void b()&#123; synchronized (lockA) &#123; synchronized (lockB) &#123; System.out.println("function b"); &#125; &#125; &#125; &#125; 三、动态的锁顺序死锁：动态的锁顺序死锁是指两个线程调用同一个方法时，传入的参数颠倒造成的死锁。如下代码，一个线程调用了transferMoney方法并传入参数accountA,accountB；另一个线程调用了transferMoney方法并传入参数accountB,accountA。此时就可能发生在静态的锁顺序死锁中存在的问题，即：第一个线程获得了accountA锁并等待accountB锁，第二个线程获得了accountB锁并等待accountA锁。 12345678910111213//可能发生动态锁顺序死锁的代码 class DynamicLockOrderDeadLock&#123; public void transefMoney(Account fromAccount,Account toAccount,Double amount)&#123; synchronized (fromAccount) &#123; synchronized (toAccount) &#123; //... fromAccount.minus(amount); toAccount.add(amount); //... &#125; &#125; &#125; &#125; 动态的锁顺序死锁解决方案如下：使用System.identifyHashCode来定义锁的顺序。确保所有的线程都以相同的顺序获得锁 123456789101112131415161718192021222324252627282930313233343536373839//正确的代码 class DynamicLockOrderDeadLock&#123; private final Object myLock=new Object(); public void transefMoney(final Account fromAccount,final Account toAccount,final Double amount)&#123; class Helper&#123; public void transfer()&#123; //... fromAccount.minus(amount); toAccount.add(amount); //... &#125; &#125; int fromHash=System.identityHashCode(fromAccount); int toHash=System.identityHashCode(toAccount); if(fromHash&lt;toHash)&#123; synchronized (fromAccount) &#123; synchronized (toAccount) &#123; new Helper().transfer(); &#125; &#125; &#125;else if(fromHash&gt;toHash)&#123; synchronized (toAccount) &#123; synchronized (fromAccount) &#123; new Helper().transfer(); &#125; &#125; &#125;else&#123; synchronized (myLock) &#123; synchronized (fromAccount) &#123; synchronized (toAccount) &#123; new Helper().transfer(); &#125; &#125; &#125; &#125; &#125; &#125; 四、协作对象之间发生的死锁：有时，死锁并不会那么明显，比如两个相互协作的类之间的死锁，比如下面的代码：一个线程调用了Taxi对象的setLocation方法，另一个线程调用了Dispatcher对象的getImage方法。此时可能会发生，第一个线程持有Taxi对象锁并等待Dispatcher对象锁，另一个线程持有Dispatcher对象锁并等待Taxi对象锁。 123456789101112131415161718192021222324252627282930313233//可能发生死锁 class Taxi&#123; private Point location,destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) &#123; this.dispatcher=dispatcher; &#125; public synchronized Point getLocation()&#123; return location; &#125; public synchronized void setLocation(Point location)&#123; this.location=location; if(location.equals(destination)) dispatcher.notifyAvailable(this);//外部调用方法，可能等待Dispatcher对象锁 &#125; &#125; class Dispatcher&#123; private final Set&lt;Taxi&gt; taxis; private final Set&lt;Taxi&gt; availableTaxis; public Dispatcher()&#123; taxis=new HashSet&lt;Taxi&gt;(); availableTaxis=new HashSet&lt;Taxi&gt;(); &#125; public synchronized void notifyAvailable(Taxi taxi)&#123; availableTaxis.add(taxi); &#125; public synchronized Image getImage()&#123; Image image=new Image(); for(Taxi t:taxis) image.drawMarker(t.getLocation());//外部调用方法，可能等待Taxi对象锁 return image; &#125; &#125; 上面的代码中，我们在持有锁的情况下调用了外部的方法，这是非常危险的（可能发生死锁）。为了避免这种危险的情况发生，我们使用开放调用。如果调用某个外部方法时不需要持有锁，我们称之为开放调用。 解决协作对象之间发生的死锁：需要使用开放调用，即避免在持有锁的情况下调用外部的方法。 1234567891011121314151617181920212223242526272829303132333435363738394041//正确的代码 class Taxi&#123; private Point location,destination; private final Dispatcher dispatcher; public Taxi(Dispatcher dispatcher) &#123; this.dispatcher=dispatcher; &#125; public synchronized Point getLocation()&#123; return location; &#125; public void setLocation(Point location)&#123; boolean flag=false; synchronized (this) &#123; this.location=location; flag=location.equals(destination); &#125; if(flag) dispatcher.notifyAvailable(this);//使用开放调用 &#125; &#125; class Dispatcher&#123; private final Set&lt;Taxi&gt; taxis; private final Set&lt;Taxi&gt; availableTaxis; public Dispatcher()&#123; taxis=new HashSet&lt;Taxi&gt;(); availableTaxis=new HashSet&lt;Taxi&gt;(); &#125; public synchronized void notifyAvailable(Taxi taxi)&#123; availableTaxis.add(taxi); &#125; public Image getImage()&#123; Set&lt;Taxi&gt; copy; synchronized (this) &#123; copy=new HashSet&lt;Taxi&gt;(taxis); &#125; Image image=new Image(); for(Taxi t:copy) image.drawMarker(t.getLocation());//使用开放调用 return image; &#125; &#125; 五、总结综上，是常见的3种死锁的类型。即：静态的锁顺序死锁，动态的锁顺序死锁，协作对象之间的死锁。在写代码时，要确保线程在获取多个锁时采用一致的顺序。同时，要避免在持有锁的情况下调用外部方法。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[###一、概述在我们的开发中经常会使用到多线程。例如在Android中，由于主线程的诸多限制，像网络请求等一些耗时的操作我们必须在子线程中运行。我们往往会通过new Thread来开启一个子线程，待子线程操作完成以后通过Handler切换到主线程中运行。这么以来我们无法管理我们所创建的子线程，并且无限制的创建子线程，它们相互之间竞争，很有可能由于占用过多资源而导致死机或者OOM。所以在Java中为我们提供了线程池来管理我们所创建的线程。 #####线程池的优势①降低系统资源消耗，通过重用已存在的线程，降低线程创建和销毁造成的消耗； ②提高系统响应速度，当有任务到达时，无需等待新线程的创建便能立即执行； ③方便线程并发数的管控，线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率； ④更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。 ###二、ThreadPoolExecutor我们可以通过ThreadPoolExecutor来创建一个线程池。1ExecutorService service = new ThreadPoolExecutor(....); 下面我们就来看一下ThreadPoolExecutor中的一个构造方法。1234567public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) #####ThreadPoolExecutor参数含义 1. corePoolSize 线程池中的核心线程数，默认情况下，核心线程一直存活在线程池中，即便他们在线程池中处于闲置状态。除非我们将ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这时候处于闲置的核心线程在等待新任务到来时会有超时策略，这个超时时间由keepAliveTime来指定。一旦超过所设置的超时时间，闲置的核心线程就会被终止。 2. maximumPoolSize 线程池中所容纳的最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞。包含核心线程数+非核心线程数。 3. keepAliveTime 非核心线程闲置时的超时时长，对于非核心线程，闲置时间超过这个时间，非核心线程就会被回收。只有对ThreadPoolExecutor的allowCoreThreadTimeOut属性设为true的时候，这个超时时间才会对核心线程产生效果。 4. unit 用于指定keepAliveTime参数的时间单位。他是一个枚举，可以使用的单位有天（TimeUnit.DAYS），小时（TimeUnit.HOURS），分钟（TimeUnit.MINUTES），毫秒(TimeUnit.MILLISECONDS)，微秒(TimeUnit.MICROSECONDS, 千分之一毫秒)和毫微秒(TimeUnit.NANOSECONDS, 千分之一微秒); 5. workQueue 线程池中保存等待执行的任务的阻塞队列。通过线程池中的execute方法提交的Runable对象都会存储在该队列中。我们可以选择下面几个阻塞队列。 ArrayBlockingQueue:基于数组实现的有界的阻塞队列,该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 LinkedBlockingQueue:基于链表实现的阻塞队列，该队列按照FIFO（先进先出）原则对队列中的元素进行排序。 SynchronousQueue:内部没有任何容量的阻塞队列。在它内部没有任何的缓存空间。对于SynchronousQueue中的数据元素只有当我们试着取走的时候才可能存在。 PriorityBlockingQueue:具有优先级的无限阻塞队列。 我们还能够通过实现BlockingQueue接口来自定义我们所需要的阻塞队列。 6. threadFactory 线程工厂，为线程池提供新线程的创建。ThreadFactory是一个接口，里面只有一个newThread方法。 默认为DefaultThreadFactory类。 7. handler 是RejectedExecutionHandler对象，而RejectedExecutionHandler是一个接口，里面只有一个rejectedExecution方法。当任务队列已满并且线程池中的活动线程已经达到所限定的最大值或者是无法成功执行任务，这时候ThreadPoolExecutor会调用RejectedExecutionHandler中的rejectedExecution方法。在ThreadPoolExecutor中有四个内部类实现了RejectedExecutionHandler接口。在线程池中它默认是AbortPolicy，在无法处理新任务时抛出RejectedExecutionException异常。 下面是在ThreadPoolExecutor中提供的四个可选值。 CallerRunsPolicy:只用调用者所在线程来运行任务。 AbortPolicy:直接抛出RejectedExecutionException异常。 DiscardPolicy:丢弃掉该任务，不进行处理 DiscardOldestPolicy:丢弃队列里最近的一个任务，并执行当前任务。 我们也可以通过实现RejectedExecutionHandler接口来自定义我们自己的handler。如记录日志或持久化不能处理的任务。 #####ThreadPoolExecutor的使用1ExecutorService service = new ThreadPoolExecutor(5, 10, 10, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;()); 对于ThreadPoolExecutor有多个构造方法，对于上面的构造方法中的其他参数都采用默认值。可以通过execute和submit两种方式来向线程池提交一个任务。execute当我们使用execute来提交任务时，由于execute方法没有返回值，所以说我们也就无法判定任务是否被线程池执行成功。12345678service.execute(new Runnable() &#123; public void run() &#123; System.out.println(&quot;execute方式&quot;); &#125; &#125;);``` **submit**当我们使用submit来提交任务时,它会返回一个future,我们就可以通过这个future来判断任务是否执行成功，还可以通过future的get方法来获取返回值。如果子线程任务没有完成，get方法会阻塞住直到任务完成，而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时候有可能任务并没有执行完。 Future future = service.submit(new Callable() { @Override public Integer call() throws Exception { System.out.println(&quot;submit方式&quot;); return 2; } }); try { Integer number = future.get(); } catch (ExecutionException e) { // TODO Auto-generated catch block e.printStackTrace(); } 123456789101112131415161718192021#####线程池关闭调用线程池的shutdown()或shutdownNow()方法来关闭线程池shutdown原理：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。shutdownNow原理：将线程池的状态设置成STOP状态，然后中断所有任务(包括正在执行的)的线程，并返回等待执行任务的列表。**中断采用interrupt方法，所以无法响应中断的任务可能永远无法终止。**但调用上述的两个关闭之一，isShutdown()方法返回值为true，当所有任务都已关闭，表示线程池关闭完成，则isTerminated()方法返回值为true。当需要立刻中断所有的线程，不一定需要执行完任务，可直接调用shutdownNow()方法。###三、线程池执行流程![](http://upload-images.jianshu.io/upload_images/3985563-c05771982ad27f86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)①如果在线程池中的线程数量没有达到核心的线程数量，这时候就回启动一个核心线程来执行任务。②如果线程池中的线程数量已经超过核心线程数，这时候任务就会被插入到任务队列中排队等待执行。③由于任务队列已满，无法将任务插入到任务队列中。这个时候如果线程池中的线程数量没有达到线程池所设定的最大值，那么这时候就会立即启动一个非核心线程来执行任务。④如果线程池中的数量达到了所规定的最大值，那么就会拒绝执行此任务，这时候就会调用RejectedExecutionHandler中的rejectedExecution方法来通知调用者。###四、四种线程池类Java中四种具有不同功能常见的线程池。他们都是直接或者间接配置ThreadPoolExecutor来实现他们各自的功能。这四种线程池分别是newFixedThreadPool,newCachedThreadPool,newScheduledThreadPool和newSingleThreadExecutor。这四个线程池可以通过Executors类获取。#####1. newFixedThreadPool 通过Executors中的newFixedThreadPool方法来创建，该线程池是一种线程数量固定的线程池。 ExecutorService service = Executors.newFixedThreadPool(4);123在这个线程池中**所容纳最大的线程数就是我们设置的核心线程数。**如果线程池的线程处于空闲状态的话，它们并不会被回收，除非是这个线程池被关闭。如果所有的线程都处于活动状态的话，新任务就会处于等待状态，直到有线程空闲出来。由于newFixedThreadPool只有核心线程，并且这些线程都不会被回收，也就是**它能够更快速的响应外界请求**。从下面的newFixedThreadPool方法的实现可以看出，newFixedThreadPool只有核心线程，并且不存在超时机制，采用LinkedBlockingQueue，所以对于任务队列的大小也是没有限制的。 public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); }12##### 2. newCachedThreadPool 通过Executors中的newCachedThreadPool方法来创建。 public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue());}1234567通过s上面的newCachedThreadPool方法在这里我们可以看出它的**核心线程数为0，**线程池的最大线程数Integer.MAX_VALUE。而Integer.MAX_VALUE是一个很大的数，也差不多可以说**这个线程池中的最大线程数可以任意大。****当线程池中的线程都处于活动状态的时候，线程池就会创建一个新的线程来处理任务。该线程池中的线程超时时长为60秒，所以当线程处于闲置状态超过60秒的时候便会被回收。**这也就意味着若是整个线程池的线程都处于闲置状态超过60秒以后，在newCachedThreadPool线程池中是不存在任何线程的，所以这时候它几乎不占用任何的系统资源。对于newCachedThreadPool他的任务队列采用的是SynchronousQueue，上面说到在SynchronousQueue内部没有任何容量的阻塞队列。SynchronousQueue内部相当于一个空集合，我们无法将一个任务插入到SynchronousQueue中。所以说在线程池中如果现有线程无法接收任务,将会创建新的线程来执行任务。##### 3. newScheduledThreadPool 通过Executors中的newScheduledThreadPool方法来创建。 public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) { return new ScheduledThreadPoolExecutor(corePoolSize);}public ScheduledThreadPoolExecutor(int corePoolSize) { super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue());}123它的核心线程数是固定的，对于非核心线程几乎可以说是没有限制的，并且当非核心线程处于限制状态的时候就会立即被回收。创建一个可定时执行或周期执行任务的线程池 ScheduledExecutorService service = Executors.newScheduledThreadPool(4); service.schedule(new Runnable() { public void run() { System.out.println(Thread.currentThread().getName()+”延迟三秒执行”); } }, 3, TimeUnit.SECONDS); service.scheduleAtFixedRate(new Runnable() { public void run() { System.out.println(Thread.currentThread().getName()+”延迟三秒后每隔2秒执行”); } }, 3, 2, TimeUnit.SECONDS);123456789101112131415161718192021输出结果：&gt;pool-1-thread-2延迟三秒后每隔2秒执行pool-1-thread-1延迟三秒执行pool-1-thread-1延迟三秒后每隔2秒执行pool-1-thread-2延迟三秒后每隔2秒执行pool-1-thread-2延迟三秒后每隔2秒执行`schedule(Runnable command, long delay, TimeUnit unit)`:延迟一定时间后执行Runnable任务；`schedule(Callable callable, long delay, TimeUnit unit)`:延迟一定时间后执行Callable任务；`scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)`:延迟一定时间后，以间隔period时间的频率周期性地执行任务；`scheduleWithFixedDelay(Runnable command, long initialDelay, long delay,TimeUnit unit)`:与scheduleAtFixedRate()方法很类似，但是不同的是scheduleWithFixedDelay()方法的周期时间间隔是以上一个任务执行结束到下一个任务开始执行的间隔，而scheduleAtFixedRate()方法的周期时间间隔是以上一个任务开始执行到下一个任务开始执行的间隔，也就是这一些任务系列的触发时间都是可预知的。ScheduledExecutorService功能强大，对于定时执行的任务，建议多采用该方法。##### 4. newSingleThreadExecutor 通过Executors中的newSingleThreadExecutor方法来创建，**在这个线程池中只有一个核心线程**，对于任务队列没有大小限制，也就意味着**这一个任务处于活动状态时，其他任务都会在任务队列中排队等候依次执行**。newSingleThreadExecutor将所有的外界任务统一到一个线程中支持，所以在这个任务执行之间我们不需要处理线程同步的问题。 public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()));} ###五、线程池的使用技巧需要针对具体情况而具体处理，不同的任务类别应采用不同规模的线程池，任务类别可划分为CPU密集型任务、IO密集型任务和混合型任务。(N代表CPU个数) 对于CPU密集型任务：线程池中线程个数应尽量少，如配置N+1个线程的线程池； 对于IO密集型任务：由于IO操作速度远低于CPU速度，那么在运行这类任务时，CPU绝大多数时间处于空闲状态，那么线程池可以配置尽量多些的线程，以提高CPU利用率，如2*N； 对于混合型任务：可以拆分为CPU密集型任务和IO密集型任务，当这两类任务执行时间相差无几时，通过拆分再执行的吞吐率高于串行执行的吞吐率，但若这两类任务执行时间有数据级的差距，那么没有拆分的意义。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java创建线程的三种方式]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[一、继承Thread类创建线程类（1）定义Thread类的子类，并重写该类的run方法，该run方法的方法体就代表了线程要完成的任务。因此把run()方法称为执行体。 （2）创建Thread子类的实例，即创建了线程对象。 （3）调用线程对象的start()方法来启动该线程。 123456789101112131415161718192021222324public class FirstThreadTest extends Thread&#123; int i = 0; //重写run方法，run方法的方法体就是现场执行体 public void run() &#123; for(;i&lt;100;i++)&#123; System.out.println(getName()+" "+i); &#125; &#125; public static void main(String[] args) &#123; for(int i = 0;i&lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+" : "+i); if(i==20) &#123; new FirstThreadTest().start(); new FirstThreadTest().start(); &#125; &#125; &#125; &#125; 上述代码中Thread.currentThread()方法返回当前正在执行的线程对象。GetName()方法返回调用该方法的线程的名字。 二、通过Runnable接口创建线程类（1）定义runnable接口的实现类，并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。 （2）创建 Runnable实现类的实例，并依此实例作为Thread的target来创建Thread对象，该Thread对象才是真正的线程对象。 （3）调用线程对象的start()方法来启动该线程。 123456789101112131415161718192021222324252627public class RunnableThreadTest implements Runnable &#123; private int i; public void run() &#123; for(i = 0;i &lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; &#125; public static void main(String[] args) &#123; for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); if(i==20) &#123; RunnableThreadTest rtt = new RunnableThreadTest(); new Thread(rtt,"新线程1").start(); new Thread(rtt,"新线程2").start(); &#125; &#125; &#125; &#125; 三、通过Callable和Future创建线程（1）创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值。 （2）创建Callable实现类的实例，使用FutureTask类来包装Callable对象，该FutureTask对象封装了该Callable对象的call()方法的返回值。 （3）使用FutureTask对象作为Thread对象的target创建并启动新线程。 （4）调用FutureTask对象的get()方法来获得子线程执行结束后的返回值，调用get()方法会阻塞线程。 12345678910111213141516171819202122232425262728293031323334353637383940public class CallableThreadTest implements Callable&lt;Integer&gt; &#123; public static void main(String[] args) &#123; CallableThreadTest ctt = new CallableThreadTest(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); for(int i = 0;i &lt; 100;i++) &#123; System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i); if(i==20) &#123; new Thread(ft,"有返回值的线程").start(); &#125; &#125; try &#123; System.out.println("子线程的返回值："+ft.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; @Override public Integer call() throws Exception &#123; int i = 0; for(;i&lt;100;i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; return i; &#125; &#125; 四、创建线程的三种方式的对比采用实现Runnable、Callable接口的方式创见多线程时，优势是： 线程类只是实现了Runnable接口或Callable接口，还可以继承其他类。 在这种方式下，多个线程可以共享同一个target对象，所以非常适合多个相同线程来处理同一份资源的情况，从而可以将CPU、代码和数据分开，形成清晰的模型，较好地体现了面向对象的思想。 劣势是： 编程稍微复杂，如果要访问当前线程，则必须使用Thread.currentThread()方法。 使用继承Thread类的方式创建多线程时优势是： 编写简单，如果需要访问当前线程，则无需使用Thread.currentThread()方法，直接使用this即可获得当前线程。 劣势是： 线程类已经继承了Thread类，所以不能再继承其他父类。]]></content>
      <categories>
        <category>Java</category>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RandomAccessFile了解]]></title>
    <url>%2F2018%2F06%2F08%2FRandomAccessFile%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、RandomAccessFile简介RandomAccessFile既可以读取文件内容，也可以向文件输出数据。同时，RandomAccessFile支持“随机访问”的方式，程序快可以直接跳转到文件的任意地方来读写数据。 由于RandomAccessFile可以自由访问文件的任意位置，所以如果需要访问文件的部分内容，而不是把文件从头读到尾，使用RandomAccessFile将是更好的选择。 与OutputStream、Writer等输出流不同的是，RandomAccessFile允许自由定义文件记录指针，RandomAccessFile可以不从开始的地方开始输出，因此RandomAccessFile可以向已存在的文件后追加内容。如果程序需要向已存在的文件后追加内容，则应该使用RandomAccessFile。 RandomAccessFile的方法虽然多，但它有一个最大的局限，就是只能读写文件，不能读写其他IO节点。 RandomAccessFile的一个重要使用场景就是网络请求中的多线程下载及断点续传。 二、RandomAccessFile中的方法1.RandomAccessFile的构造函数RandomAccessFile类有两个构造函数，其实这两个构造函数基本相同，只不过是指定文件的形式不同——一个需要使用String参数来指定文件名，一个使用File参数来指定文件本身。除此之外，创建RandomAccessFile对象时还需要指定一个mode参数，该参数指定RandomAccessFile的访问模式，一共有4种模式。 “r”: 以只读方式打开。调用结果对象的任何 write 方法都将导致抛出 IOException。“rw”: 打开以便读取和写入。“rws”: 打开以便读取和写入。相对于 “rw”，”rws” 还要求对“文件的内容”或“元数据”的每个更新都同步写入到基础存储设备。“rwd” : 打开以便读取和写入，相对于 “rw”，”rwd” 还要求对“文件的内容”的每个更新都同步写入到基础存储设备。 2.RandomAccessFile的重要方法RandomAccessFile既可以读文件，也可以写文件，所以类似于InputStream的read()方法，以及类似于OutputStream的write()方法，RandomAccessFile都具备。除此之外，RandomAccessFile具备两个特有的方法，来支持其随机访问的特性。 RandomAccessFile对象包含了一个记录指针，用以标识当前读写处的位置，当程序新创建一个RandomAccessFile对象时，该对象的文件指针记录位于文件头（也就是0处），当读/写了n个字节后，文件记录指针将会后移n个字节。除此之外，RandomAccessFile还可以自由移动该记录指针。下面就是RandomAccessFile具有的两个特殊方法，来操作记录指针，实现随机访问： long getFilePointer( )：返回文件记录指针的当前位置void seek(long pos )：将文件指针定位到pos位置 三、RandomAccessFile的使用利用RandomAccessFile实现文件的多线程下载，即多线程下载一个文件时，将文件分成几块，每块用不同的线程进行下载。下面是一个利用多线程在写文件时的例子，其中预先分配文件所需要的空间，然后在所分配的空间中进行分块，然后写入： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 测试利用多线程进行文件的写操作 */ public class Test &#123; public static void main(String[] args) throws Exception &#123; // 预分配文件所占的磁盘空间，磁盘中会创建一个指定大小的文件 RandomAccessFile raf = new RandomAccessFile("D://abc.txt", "rw"); raf.setLength(1024*1024); // 预分配 1M 的文件空间 raf.close(); // 所要写入的文件内容 String s1 = "第一个字符串"; String s2 = "第二个字符串"; String s3 = "第三个字符串"; String s4 = "第四个字符串"; String s5 = "第五个字符串"; // 利用多线程同时写入一个文件 new FileWriteThread(1024*1,s1.getBytes()).start(); // 从文件的1024字节之后开始写入数据 new FileWriteThread(1024*2,s2.getBytes()).start(); // 从文件的2048字节之后开始写入数据 new FileWriteThread(1024*3,s3.getBytes()).start(); // 从文件的3072字节之后开始写入数据 new FileWriteThread(1024*4,s4.getBytes()).start(); // 从文件的4096字节之后开始写入数据 new FileWriteThread(1024*5,s5.getBytes()).start(); // 从文件的5120字节之后开始写入数据 &#125; // 利用线程在文件的指定位置写入指定数据 static class FileWriteThread extends Thread&#123; private int skip; private byte[] content; public FileWriteThread(int skip,byte[] content)&#123; this.skip = skip; this.content = content; &#125; public void run()&#123; RandomAccessFile raf = null; try &#123; raf = new RandomAccessFile("D://abc.txt", "rw"); raf.seek(skip); raf.write(content); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; try &#123; raf.close(); &#125; catch (Exception e) &#123; &#125; &#125; &#125; &#125; &#125; 当RandomAccessFile向指定文件中插入内容时，将会覆盖掉原有内容。如果不想覆盖掉，则需要将原有内容先读取出来，然后先把插入内容插入后再把原有内容追加到插入内容后。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[finally与return执行顺序]]></title>
    <url>%2F2018%2F06%2F08%2Ffinally%E4%B8%8Ereturn%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[网上有很多人探讨Java中异常捕获机制try…catch…finally块中的finally语句是不是一定会被执行？很多人都说不是，当然他们的回答是正确的，经过我试验，至少有两种情况下finally语句是不会被执行的： （1）try语句没有被执行到，如在try语句之前就返回了，这样finally语句就不会执行，这也说明了finally语句被执行的必要而非充分条件是：相应的try语句一定被执行到。 （2）在try块中有System.exit(0);这样的语句，System.exit(0);是终止Java虚拟机JVM的，连JVM都停止了，所有都结束了，当然finally语句也不会被执行到。 当然还有很多人探讨finally语句的执行与return的关系，颇为让人迷惑，不知道finally语句是在try的return之前执行还是之后执行？我也是一头雾水，我觉得他们的说法都不正确，我觉得应该是：finally语句是在try的return语句执行之后，return返回之前执行。这样的说法有点矛盾，也许是我表述不太清楚，下面我给出自己试验的一些结果和示例进行佐证，有什么问题欢迎大家提出来。 1. finally语句在return语句执行之后return返回之前执行的。1234567891011121314151617181920212223242526272829303132public class FinallyTest1 &#123; public static void main(String[] args) &#123; System.out.println(test1()); &#125; public static int test1() &#123; int b = 20; try &#123; System.out.println("try block"); return b += 80; &#125; catch (Exception e) &#123; System.out.println("catch block"); &#125; finally &#123; System.out.println("finally block"); if (b &gt; 25) &#123; System.out.println("b&gt;25, b = " + b); &#125; &#125; return b; &#125; &#125; 运行结果是： 1234try blockfinally blockb&gt;25, b = 100100 说明return语句已经执行了再去执行finally语句，不过并没有直接返回，而是等finally语句执行完了再返回结果。 如果觉得这个例子还不足以说明这个情况的话，下面再加个例子加强证明结论： 123456789101112131415161718192021222324public class FinallyTest1 &#123; public static void main(String[] args) &#123; System.out.println(test11()); &#125; public static String test11() &#123; try &#123; System.out.println("try block"); return test12(); &#125; finally &#123; System.out.println("finally block"); &#125; &#125; public static String test12() &#123; System.out.println("return statement"); return "after return"; &#125; &#125; 运行结果为： 1234try blockreturn statementfinally blockafter return 说明try中的return语句先执行了但并没有立即返回，等到finally执行结束后再返回。 这里大家可能会想：如果finally里也有return语句，那么是不是就直接返回了，try中的return就不能返回了？看下面。 2. finally块中的return语句会覆盖try块中的return返回。1234567891011121314151617181920212223242526272829303132public class FinallyTest2 &#123; public static void main(String[] args) &#123; System.out.println(test2()); &#125; public static int test2() &#123; int b = 20; try &#123; System.out.println("try block"); return b += 80; &#125; catch (Exception e) &#123; System.out.println("catch block"); &#125; finally &#123; System.out.println("finally block"); if (b &gt; 25) &#123; System.out.println("b&gt;25, b = " + b); &#125; return 200; &#125; // return b; &#125;&#125; 运行结果是： 1234try blockfinally blockb&gt;25, b = 100200 这说明finally里的return直接返回了，就不管try中是否还有返回语句，这里还有个小细节需要注意，finally里加上return过后，finally外面的return b就变成不可到达语句了，也就是永远不能被执行到，所以需要注释掉否则编译器报错。 这里大家可能又想：如果finally里没有return语句，但修改了b的值，那么try中return返回的是修改后的值还是原值？看下面。 3. 如果finally语句中没有return语句覆盖返回值，那么原来的返回值可能因为finally里的修改而改变也可能不变。测试用例1： 1234567891011121314151617181920212223242526272829303132public class FinallyTest3 &#123; public static void main(String[] args) &#123; System.out.println(test3()); &#125; public static int test3() &#123; int b = 20; try &#123; System.out.println("try block"); return b += 80; &#125; catch (Exception e) &#123; System.out.println("catch block"); &#125; finally &#123; System.out.println("finally block"); if (b &gt; 25) &#123; System.out.println("b&gt;25, b = " + b); &#125; b = 150; &#125; return 2000; &#125;&#125; 运行结果是： 1234try blockfinally blockb&gt;25, b = 100100 测试用例2： 123456789101112131415161718192021222324252627import java.util.*;public class FinallyTest6&#123; public static void main(String[] args) &#123; System.out.println(getMap().get("KEY").toString()); &#125; public static Map&lt;String, String&gt; getMap() &#123; Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); map.put("KEY", "INIT"); try &#123; map.put("KEY", "TRY"); return map; &#125; catch (Exception e) &#123; map.put("KEY", "CATCH"); &#125; finally &#123; map.put("KEY", "FINALLY"); map = null; &#125; return map; &#125;&#125; 运行结果是： 1FINALLY 为什么测试用例1中finally里的b = 150;并没有起到作用而测试用例2中finally的map.put(“KEY”, “FINALLY”);起了作用而map = null;却没起作用呢？这就是Java到底是传值还是传址的问题了，具体请看精选30道Java笔试题解答，里面有详细的解答，简单来说就是：Java中只有传值没有传址，这也是为什么map = null这句不起作用。这同时也说明了返回语句是try中的return语句而不是 finally外面的return b;这句，不相信的话可以试下，将return b;改为return 294，对原来的结果没有一点影响。 这里大家可能又要想：是不是每次返回的一定是try中的return语句呢？那么finally外的return b不是一点作用没吗？请看下面。 4. try块里的return语句在异常的情况下不会被执行，这样具体返回哪个看情况。1234567891011121314151617181920212223242526272829303132333435public class FinallyTest4 &#123; public static void main(String[] args) &#123; System.out.println(test4()); &#125; public static int test4() &#123; int b = 20; try &#123; System.out.println("try block"); b = b / 0; return b += 80; &#125; catch (Exception e) &#123; b += 15; System.out.println("catch block"); &#125; finally &#123; System.out.println("finally block"); if (b &gt; 25) &#123; System.out.println("b&gt;25, b = " + b); &#125; b += 50; &#125; return b; &#125;&#125; 运行结果是： 12345try blockcatch blockfinally blockb&gt;25, b = 3585 这里因 为在return之前发生了除0异常，所以try中的return不会被执行到，而是接着执行捕获异常的catch 语句和最终的finally语句，此时两者对b的修改都影响了最终的返回值，这时return b;就起到作用了。当然如果你这里将return b改为return 300什么的，最后返回的就是300，这毋庸置疑。 这里大家可能又有疑问：如果catch中有return语句呢？当然只有在异常的情况下才有可能会执行，那么是在finally之前就返回吗？看下面。 5. 当发生异常后，catch中的return执行情况与未发生异常时try中return的执行情况完全一样。1234567891011121314151617181920212223242526272829303132333435public class FinallyTest5 &#123; public static void main(String[] args) &#123; System.out.println(test5()); &#125; public static int test5() &#123; int b = 20; try &#123; System.out.println("try block"); b = b /0; return b += 80; &#125; catch (Exception e) &#123; System.out.println("catch block"); return b += 15; &#125; finally &#123; System.out.println("finally block"); if (b &gt; 25) &#123; System.out.println("b&gt;25, b = " + b); &#125; b += 50; &#125; //return b; &#125;&#125; 运行结果如下： 12345try blockcatch blockfinally blockb&gt;25, b = 3535 说明了发生异常后，catch中的return语句先执行，确定了返回值后再去执行finally块，执行完了catch再返回，finally里对b的改变对返回值无影响，原因同前面一样，也就是说情况与try中的return语句执行完全一样。 最后总结：finally块的语句在try或catch中的return语句执行之后返回之前执行且finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transient关键字]]></title>
    <url>%2F2018%2F06%2F08%2Ftransient%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[一、 transient的作用及使用方法我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 示例code如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Alexia"); user.setPasswd("123456"); System.out.println("read before Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream("C:/user.txt")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream( "C:/user.txt")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println("\nread after Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; private String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 输出为： 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: Alexiapassword: null 二、transient使用小结1）一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 2）transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 3）被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Alexia"); user.setPasswd("123456"); System.out.println("read before Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream("C:/user.txt")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; // 在反序列化之前改变username的值 User.username = "jmwang"; ObjectInputStream is = new ObjectInputStream(new FileInputStream( "C:/user.txt")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println("\nread after Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; public static String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 输出为： 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: jmwangpassword: null 三、transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？思考下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.Externalizable;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;/** * @descripiton Externalizable接口的使用 * * @author Alexia * @date 2013-10-15 * */public class ExternalizableTest implements Externalizable &#123; private transient String content = "是的，我将会被序列化，不管我是否被transient关键字修饰"; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(content); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; content = (String) in.readObject(); &#125; public static void main(String[] args) throws Exception &#123; ExternalizableTest et = new ExternalizableTest(); ObjectOutput out = new ObjectOutputStream(new FileOutputStream( new File("test"))); out.writeObject(et); ObjectInput in = new ObjectInputStream(new FileInputStream(new File( "test"))); et = (ExternalizableTest) in.readObject(); System.out.println(et.content); out.close(); in.close(); &#125;&#125; content变量会被序列化吗？好吧，我把答案都输出来了，是的，运行结果就是： 1是的，我将会被序列化，不管我是否被transient关键字修饰 这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？ 我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java深拷贝和浅拷贝]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[一、引言 对象拷贝(Object Copy)就是将一个对象的属性拷贝到另一个有着相同类类型的对象中去。在程序中拷贝对象是很常见的，主要是为了在新的上下文环境中复用对象的部分或全部数据。Java中有三种类型的对象拷贝：浅拷贝(Shallow Copy)、深拷贝(Deep Copy)、延迟拷贝(Lazy Copy)。 二、浅拷贝1、什么是浅拷贝 浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。 ​ 在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj”（引用ContainedObject类型的对象）。当对SourceObject做浅拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及仍指向refObj本身的引用。由于”field1”是基本类型，所以只是将它的值拷贝给”field2”，但是由于”refObj”是一个引用类型, 所以CopiedObject指向”refObj”相同的地址。因此对SourceObject中的”refObj”所做的任何改变都会影响到CopiedObject。 2、如何实现浅拷贝下面是实现浅拷贝的一个例子 12345678910111213141516public class Subject &#123; private String name; public Subject(String s) &#123; name = s; &#125; public String getName() &#123; return name; &#125; public void setName(String s) &#123; name = s; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738public class Student implements Cloneable &#123; // 对象引用 private Subject subj; private String name; public Student(String s, String sub) &#123; name = s; subj = new Subject(sub); &#125; public Subject getSubj() &#123; return subj; &#125; public String getName() &#123; return name; &#125; public void setName(String s) &#123; name = s; &#125; /** * 重写clone()方法 * @return */ public Object clone() &#123; //浅拷贝 try &#123; // 直接调用父类的clone()方法 return super.clone(); &#125; catch (CloneNotSupportedException e) &#123; return null; &#125; &#125; &#125; 12345678910111213141516171819202122232425public class CopyTest &#123; public static void main(String[] args) &#123; // 原始对象 Student stud = new Student("John", "Algebra"); System.out.println("Original Object: " + stud.getName() + " - " + stud.getSubj().getName()); // 拷贝对象 Student clonedStud = (Student) stud.clone(); System.out.println("Cloned Object: " + clonedStud.getName() + " - " + clonedStud.getSubj().getName()); // 原始对象和拷贝对象是否一样： System.out.println("Is Original Object the same with Cloned Object: " + (stud == clonedStud)); // 原始对象和拷贝对象的name属性是否一样 System.out.println("Is Original Object's field name the same with Cloned Object: " + (stud.getName() == clonedStud.getName())); // 原始对象和拷贝对象的subj属性是否一样 System.out.println("Is Original Object's field subj the same with Cloned Object: " + (stud.getSubj() == clonedStud.getSubj())); stud.setName("Dan"); stud.getSubj().setName("Physics"); System.out.println("Original Object after it is updated: " + stud.getName() + " - " + stud.getSubj().getName()); System.out.println("Cloned Object after updating original object: " + clonedStud.getName() + " - " + clonedStud.getSubj().getName()); &#125;&#125; ​ 输出结果如下： 1234567Original Object: John - AlgebraCloned Object: John - AlgebraIs Original Object the same with Cloned Object: falseIs Original Object's field name the same with Cloned Object: trueIs Original Object's field subj the same with Cloned Object: trueOriginal Object after it is updated: Dan - PhysicsCloned Object after updating original object: John - Physics 在这个例子中，我让要拷贝的类Student实现了Clonable接口并重写Object类的clone()方法，然后在方法内部调用super.clone()方法。从输出结果中我们可以看到，对原始对象stud的”name”属性所做的改变并没有影响到拷贝对象clonedStud，但是对引用对象subj的”name”属性所做的改变影响到了拷贝对象clonedStud。 三、深拷贝1、什么是深拷贝深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 ​ 在上图中，SourceObject有一个int类型的属性 “field1”和一个引用类型属性”refObj1”（引用ContainedObject类型的对象）。当对SourceObject做深拷贝时，创建了CopiedObject，它有一个包含”field1”拷贝值的属性”field2”以及包含”refObj1”拷贝值的引用类型属性”refObj2” 。因此对SourceObject中的”refObj”所做的任何改变都不会影响到CopiedObject 2、如何实现深拷贝下面是实现深拷贝的一个例子。只是在浅拷贝的例子上做了一点小改动，Subject 和CopyTest 类都没有变化。 12345678910111213141516171819202122232425262728293031323334public class Student implements Cloneable &#123; // 对象引用 private Subject subj; private String name; public Student(String s, String sub) &#123; name = s; subj = new Subject(sub); &#125; public Subject getSubj() &#123; return subj; &#125; public String getName() &#123; return name; &#125; public void setName(String s) &#123; name = s; &#125; /** * 重写clone()方法 * * @return */ public Object clone() &#123; // 深拷贝，创建拷贝类的一个新对象，这样就和原始对象相互独立 Student s = new Student(name, subj.getName()); return s; &#125; &#125; ​ 输出结果如下： 1234567Original Object: John - AlgebraCloned Object: John - AlgebraIs Original Object the same with Cloned Object: falseIs Original Object's field name the same with Cloned Object: trueIs Original Object's field subj the same with Cloned Object: falseOriginal Object after it is updated: Dan - PhysicsCloned Object after updating original object: John - Algebra 很容易发现clone()方法中的一点变化。因为它是深拷贝，所以你需要创建拷贝类的一个对象。因为在Student类中有对象引用，所以需要在Student类中实现Cloneable接口并且重写clone方法。 3、通过序列化实现深拷贝也可以通过序列化来实现深拷贝。序列化是干什么的?它将整个对象图写入到一个持久化存储文件中并且当需要的时候把它读取回来, 这意味着当你需要把它读取回来时你需要整个对象图的一个拷贝。这就是当你深拷贝一个对象时真正需要的东西。请注意，当你通过序列化进行深拷贝时，必须确保对象图中所有类都是可序列化的。 12345678910111213141516171819202122232425262728293031public class ColoredCircle implements Serializable &#123; private int x; private int y; public ColoredCircle(int x, int y) &#123; this.x = x; this.y = y; &#125; public int getX() &#123; return x; &#125; public void setX(int x) &#123; this.x = x; &#125; public int getY() &#123; return y; &#125; public void setY(int y) &#123; this.y = y; &#125; @Override public String toString() &#123; return "x=" + x + ", y=" + y; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940public class DeepCopy &#123; public static void main(String[] args) throws IOException &#123; ObjectOutputStream oos = null; ObjectInputStream ois = null; try &#123; // 创建原始的可序列化对象 ColoredCircle c1 = new ColoredCircle(100, 100); System.out.println("Original = " + c1); ColoredCircle c2 = null; // 通过序列化实现深拷贝 ByteArrayOutputStream bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); // 序列化以及传递这个对象 oos.writeObject(c1); oos.flush(); ByteArrayInputStream bin = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bin); // 返回新的对象 c2 = (ColoredCircle) ois.readObject(); // 校验内容是否相同 System.out.println("Copied = " + c2); // 改变原始对象的内容 c1.setX(200); c1.setY(200); // 查看每一个现在的内容 System.out.println("Original = " + c1); System.out.println("Copied = " + c2); &#125; catch (Exception e) &#123; System.out.println("Exception in main = " + e); &#125; finally &#123; oos.close(); ois.close(); &#125; &#125; &#125; ​ ​ 输出结果如下： 1234Original = x=100, y=100Copied = x=100, y=100Original = x=200, y=200Copied = x=100, y=100 这里，你只需要做以下几件事儿: 确保对象图中的所有类都是可序列化的 创建输入输出流 使用这个输入输出流来创建对象输入和对象输出流 将你想要拷贝的对象传递给对象输出流 从对象输入流中读取新的对象并且转换回你所发送的对象的类 在这个例子中，我创建了一个ColoredCircle对象c1然后将它序列化 (将它写到ByteArrayOutputStream中). 然后我反序列化这个序列化后的对象并将它保存到c2中。随后我修改了原始对象c1。然后结果如你所见，c1不同于c2，对c1所做的任何修改都不会影响c2。 注意，序列化这种方式有其自身的限制和问题： 因为无法序列化transient变量, 使用这种方法将无法拷贝transient变量。 再就是性能问题。创建一个socket, 序列化一个对象, 通过socket传输它, 然后反序列化它，这个过程与调用已有对象的方法相比是很慢的。所以在性能上会有天壤之别。如果性能对你的代码来说是至关重要的，建议不要使用这种方式。它比通过实现Clonable接口这种方式来进行深拷贝几乎多花100倍的时间。 四、延迟拷贝延迟拷贝是浅拷贝和深拷贝的一个组合，实际上很少会使用。 当最开始拷贝一个对象时，会使用速度较快的浅拷贝，还会使用一个计数器来记录有多少对象共享这个数据。当程序想要修改原始的对象时，它会决定数据是否被共享（通过检查计数器）并根据需要进行深拷贝。 延迟拷贝从外面看起来就是深拷贝，但是只要有可能它就会利用浅拷贝的速度。当原始对象中的引用不经常改变的时候可以使用延迟拷贝。由于存在计数器，效率下降很高，但只是常量级的开销。而且, 在某些情况下, 循环引用会导致一些问题。 五、如何选择如果对象的属性全是基本类型的，那么可以使用浅拷贝，但是如果对象有引用属性，那就要基于具体的需求来选择浅拷贝还是深拷贝。我的意思是如果对象引用任何时候都不会被改变，那么没必要使用深拷贝，只需要使用浅拷贝就行了。如果对象引用经常改变，那么就要使用深拷贝。没有一成不变的规则，一切都取决于具体需求。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java抽象类和接口的区别]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[理解抽象abstract class和interface是Java语言中对于抽象类定义进行支持的两种机制，正是由于这两种机制的存在，才赋予了Java强大的面向对象能力。 abstract class和interface之间在对于抽象类定义的支持方面具有很大的相似性，甚至可以相互替换，因此很多开发者在进行抽象类定义时对于 abstract class和interface的选择显得比较随意。 其实，两者之间还是有很大的区别的，对于它们的选择甚至反映出对于问题领域本质的理解、对于设计意图的理解是否正确、合理。本文将对它们之间的区别进行一番剖析，试图给开发者提供一个在二者之间进行选择的依据。 语法定义理解 抽象类 123456789abstract class Demo ｛ abstract void method1(); abstract void method2(); … ｝ 接口 123456789interface Demo &#123; void method1(); void method2(); … &#125; 在abstract class方式中，Demo可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface方式的实现中，Demo只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的成员方法都是abstract的。从某种意义上说，interface是一种特殊形式的abstract class。 编程角度理解首先，abstract class在Java语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。也许，这是Java语言的设计者在考虑Java对于多重继承的支持方面的一种折中考虑吧。 其次，在abstract class的定义中，我们可以赋予方法的默认行为。 但是在interface的定义中，方法却不能拥有默认行为，不过在JDK1.8中可以使用default关键字实现默认方法。 12345interface InterfaceA &#123; default void foo() &#123; System.out.println("InterfaceA foo"); &#125;&#125; 在 Java 8 之前，接口与其实现类之间的 耦合度 太高了（tightly coupled），当需要为一个接口添加方法时，所有的实现类都必须随之修改。默认方法解决了这个问题，它可以为接口添加新的方法，而不会破坏已有的接口的实现。这在 lambda 表达式作为Jjava 8 语言的重要特性而出现之际，为升级旧接口且保持向后兼容（backward compatibility）提供了途径。 一般性理解接口和抽象类的概念不一样。接口是对动作的抽象，抽象类是对根源的抽象。从设计理念上，接口反映的是 “like-a” 关系，抽象类反映的是 “is-a” 关系。抽象类表示的是，这个对象是什么。接口表示的是，这个对象能做什么。比如，男人，女人，这两个类（如果是类的话……），他们的抽象类是人。说明，他们都是人。人可以吃东西，狗也可以吃东西，你可以把“吃东西”定义成一个接口，然后让这些类去实现它.所以，在高级语言上，一个类只能继承一个类（抽象类）(正如人不可能同时是生物和非生物)，但是可以实现多个接口(吃饭接口、走路接口)。 总结 抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。 抽象类要被子类继承，接口要被类实现。 接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 抽象类里可以没有抽象方法。 接口可以被类多实现（被其他接口多继承），抽象类只能被单继承。 接口中没有 this 指针，没有构造函数，不能拥有实例字段（实例变量）或实例方法。 抽象类不能在Java 8 的 lambda 表达式中使用。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaNIO]]></title>
    <url>%2F2018%2F06%2F08%2FJavaNIO%2F</url>
    <content type="text"><![CDATA[一、NIO的概念Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java1.4开始)，Java NIO提供了与标准IO不同的IO工作方式。 所以Java NIO是一种新式的IO标准，与之间的普通IO的工作方式不同。标准的IO基于字节流和字符流进行操作的，而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入通道也类似。 由上面的定义就说明NIO是一种新型的IO，但NIO不仅仅就是等于Non-blocking IO（非阻塞IO），NIO中有实现非阻塞IO的具体类，但不代表NIO就是Non-blocking IO（非阻塞IO）。 Java NIO 由以下几个核心部分组成： Buffer Channel Selector 传统的IO操作面向数据流，意味着每次从流中读一个或多个字节，直至完成，数据没有被缓存在任何地方。NIO操作面向缓冲区，数据从Channel读取到Buffer缓冲区，随后在Buffer中处理数据。 二、Buffer的使用利用Buffer读写数据，通常遵循四个步骤： 把数据写入buffer； 调用flip； 从Buffer中读取数据； 调用buffer.clear() 当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过flip()方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。 当读取完数据后，需要清空buffer，以满足后续写入操作。清空buffer有两种方式：调用clear()，一旦读完Buffer中的数据，需要让Buffer准备好再次被写入，clear会恢复状态值，但不会擦除数据。 Buffer的容量，位置，上限（Buffer Capacity, Position and Limit）buffer缓冲区实质上就是一块内存，用于写入数据，也供后续再次读取数据。这块内存被NIO Buffer管理，并提供一系列的方法用于更简单的操作这块内存。 一个Buffer有三个属性是必须掌握的，分别是： capacity容量 position位置 limit限制 position和limit的具体含义取决于当前buffer的模式。capacity在两种模式下都表示容量。下面有张示例图，描诉了不同模式下position和limit的含义： 容量（Capacity） 作为一块内存，buffer有一个固定的大小，叫做capacity容量。也就是最多只能写入容量值得字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据。 位置（Position） 当写入数据到Buffer的时候需要中一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1。当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。 上限（Limit）在写模式，limit的含义是我们所能写入的最大数据量。它等同于buffer的容量。一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。数据读取的上限时buffer中已有的数据，也就是limit的位置（原position所指的位置）。 分配一个Buffer（Allocating a Buffer）为了获取一个Buffer对象，你必须先分配。每个Buffer实现类都有一个allocate()方法用于分配内存。下面看一个实例,开辟一个48字节大小的buffer： 1ByteBuffer buf = ByteBuffer.allocate(48); 开辟一个1024个字符的CharBuffer： 1CharBuffer buf = CharBuffer.allocate(1024); Buffer的实现类其中MappedByteBuffer比较特殊。Java类库中的NIO包相对于IO 包来说有一个新功能是内存映射文件，日常编程中并不是经常用到，但是在处理大文件时是比较理想的提高效率的手段。其中MappedByteBuffer实现的就是内存映射文件，可以实现大文件的高效读写。 可以参考这两篇文章理解： [Java][IO]JAVA NIO之浅谈内存映射文件原理与DirectMemory，深入浅出MappedByteBuffer。 三、Channel的使用Java NIO Channel通道和流非常相似，主要有以下几点区别： 通道可以读也可以写，流一般来说是单向的（只能读或者写）。 通道可以异步读写。 通道总是基于缓冲区Buffer来读写。 正如上面提到的，我们可以从通道中读取数据，写入到buffer；也可以中buffer内读数据，写入到通道中。下面有个示意图： Channel的实现类有： FileChannel DatagramChannel SocketChannel ServerSocketChannel 还有一些异步IO类，后面有介绍。 FileChannel用于文件的数据读写。 DatagramChannel用于UDP的数据读写。 SocketChannel用于TCP的数据读写。 ServerSocketChannel允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel。 Channel使用实例12345678910111213141516171819RandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw"); FileChannel inChannel = aFile.getChannel(); ByteBuffer buf = ByteBuffer.allocate(48); int bytesRead = inChannel.read(buf); while (bytesRead != -1) &#123; System.out.println("Read " + bytesRead); buf.flip(); while(buf.hasRemaining())&#123; System.out.print((char) buf.get()); &#125; buf.clear(); bytesRead = inChannel.read(buf); &#125; aFile.close(); 上面介绍了NIO中的两个关键部分Buffer/Channel，对于Selector的介绍，先放一放，先介绍阻塞/非阻塞/同步/非同步的关系。 四、阻塞/非阻塞/同步/非同步的关系为什么要介绍这四者的关系，就是因为Selector是对于多个非阻塞IO流的调度器，通过Selector来实现读写操作。所以有必要理解一下什么是阻塞/非阻塞？ 本文讨论的背景是UNIX环境下的network IO。本文最重要的参考文献是Richard Stevens的“UNIX® Network Programming Volume 1, Third Edition: The Sockets Networking ”，6.2节“I/O Models ”，Stevens在这节中详细说明了各种IO的特点和区别。 Stevens在文章中一共比较了五种IO Model： blocking IO nonblocking IO IO multiplexing signal driven IO asynchronous IO。 由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。再说一下IO发生时涉及的对象和步骤。对于一个network IO (这里我们以read举例)，它会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。 当一个read操作发生时，它会经历两个阶段：1 等待数据准备 (Waiting for the data to be ready)2 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process) 记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。 blocking IO 在UNIX中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样： 当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。所以，blocking IO的特点就是在IO执行的两个阶段都被block了。 non-blocking IO UNIX下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。所以，用户进程其实是需要不断的主动询问kernel数据好了没有。 IO multiplexing IO multiplexing这个词可能有点陌生，但是如果我说select，epoll，大概就都能明白了。有些地方也称这种IO方式为event driven IO。我们都知道，select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select/epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。它的流程如图： 当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。 这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（多说一句。所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。 Asynchronous I/O UNIX下的asynchronous IO其实用得很少。先看一下它的流程：用户进程发起read操作之后，立刻就可以开始去做其它的事。 而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。 到目前为止，已经将四个IO Model都介绍完了。现在回过头来回答最初的那几个问题： blocking和non-blocking的区别在哪，synchronous IO和asynchronous IO的区别在哪？ 先回答最简单的这个：blocking vs non-blocking。前面的介绍中其实已经很明确的说明了这两者的区别。调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。 在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。Stevens给出的定义（其实是POSIX的定义）是这样子的：A synchronous I/O operation causes the requesting process to be blocked until that I/O operationcompletes; An asynchronous I/O operation does not cause the requesting process to be blocked; 两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。 按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。 有人可能会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。 各个IO Model的比较如图所示： 经过上面的介绍，会发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。 五、NIO中的blocking IO/nonblocking IO/IO multiplexing/asynchronous IO上面讲完了IO中的几种模式，虽然是基于UNIX环境下，具体操作系统的知识个人认识很浅，下面就说下自己的个人理解，不对的地方欢迎指正。 首先，标准的IO显然属于blocking IO。 其次，NIO中的实现了SelectableChannel类的对象，可以通过如下方法设置是否支持非阻塞模式： SelectableChannel configureBlocking(boolean block)：调整此通道的阻塞模式。 如果为 true，则此通道将被置于阻塞模式；如果为 false，则此通道将被置于非阻塞模式设置为false的NIO类将是nonblocking IO。 再其次，通过Selector监听实现多个NIO对象的读写操作，显然属于IO multiplexing。关于Selector，其负责调度多个非阻塞式IO，当有其感兴趣的读写操作到来时，再执行相应的操作。Selector执行select()方法来进行轮询查找是否到来了读写操作，这个过程是阻塞的，具体详细使用下面介绍。 最后，在Java 7中增加了asynchronous IO，具体结构和实现类框架如下： 篇幅有限，具体使用可以看这篇文章：Java 学习之路 之 基于TCP协议的网络编程（八十二）。 六、Selector使用Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。 通过上面的了解我们知道Selector是一种IO multiplexing的情况。 下面这幅图描述了单线程处理三个channel的情况： 创建Selector(Creating a Selector)。创建一个Selector可以通过Selector.open()方法：1Selector selector = Selector.open(); 注册Channel到Selector上：12channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ); Channel必须是非阻塞的。上面对IO multiplexing的图解中可以看出。所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式。Socket channel可以正常使用。 注意register的第二个参数，这个参数是一个“关注集合”，代表我们关注的channel状态，有四种基础类型可供监听： Connect Accept Read Write 一个channel触发了一个事件也可视作该事件处于就绪状态。 因此当channel与server连接成功后，那么就是“Connetct”状态。server channel接收请求连接时处于“Accept”状态。channel有数据可读时处于“Read”状态。channel可以进行数据写入时处于“Writer”状态。当注册到Selector的所有Channel注册完后，调用Selector的select()方法，将会不断轮询检查是否有以上设置的状态产生，如果产生便会加入到SelectionKey集合中，进行后续操作。 上述的四种就绪状态用SelectionKey中的常量表示如下： SelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 如果对多个事件感兴趣可利用位的或运算结合多个常量，比如： int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 从Selector中选择channel(Selecting Channels via a Selector)一旦我们向Selector注册了一个或多个channel后，就可以调用select来获取channel。select方法会返回所有处于就绪状态的channel。 select方法具体如下： int select()int select(long timeout)int selectNow() select()方法在返回channel之前处于阻塞状态。 select(long timeout)和select做的事一样，不过他的阻塞有一个超时限制。 selectNow()不会阻塞，根据当前状态立刻返回合适的channel。 select()方法的返回值是一个int整形，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。 举例来说，假设第一次调用select时正好有一个channel就绪，那么返回值是1，并且对这个channel做任何处理，接着再次调用select，此时恰好又有一个新的channel就绪，那么返回值还是1，现在我们一共有两个channel处于就绪，但是在每次调用select时只有一个channel是就绪的。 selectedKeys()在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法： 1Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); 遍历这些SelectionKey可以通过如下方法： 1234567891011121314151617181920212223Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator();while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // a connection was accepted by a ServerSocketChannel. &#125; else if (key.isConnectable()) &#123; // a connection was established with a remote server. &#125; else if (key.isReadable()) &#123; // a channel is ready for reading &#125; else if (key.isWritable()) &#123; // a channel is ready for writing &#125; keyIterator.remove();&#125; 上述循环会迭代key集合，针对每个key我们单独判断他是处于何种就绪状态。 注意keyIterater.remove()方法的调用，Selector本身并不会移除SelectionKey对象，这个操作需要我们收到执行。当下次channel处于就绪是，Selector任然会把这些key再次加入进来。 SelectionKey.channel返回的channel实例需要强转为我们实际使用的具体的channel类型，例如ServerSocketChannel或SocketChannel. wakeUp()由于调用select而被阻塞的线程，可以通过调用Selector.wakeup()来唤醒即便此时已然没有channel处于就绪状态。具体操作是，在另外一个线程调用wakeup，被阻塞与select方法的线程就会立刻返回。 close()当操作Selector完毕后，需要调用close方法。close的调用会关闭Selector并使相关的SelectionKey都无效。channel本身不管被关闭。 完整的Selector案例这有一个完整的案例，首先打开一个Selector,然后注册channel，最后调用select()获取感兴趣的操作： 123456789101112131415161718192021222324252627282930313233343536Selector selector = Selector.open();channel.configureBlocking(false);SelectionKey key = channel.register(selector, SelectionKey.OP_READ);while(true) &#123; int readyChannels = selector.select(); if(readyChannels == 0) continue; Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator(); while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // a connection was accepted by a ServerSocketChannel. &#125; else if (key.isConnectable()) &#123; // a connection was established with a remote server. &#125; else if (key.isReadable()) &#123; // a channel is ready for reading &#125; else if (key.isWritable()) &#123; // a channel is ready for writing &#125; keyIterator.remove(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO(二)]]></title>
    <url>%2F2018%2F06%2F08%2FJavaIO-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一、IO流的概念Java的IO流是实现输入/输出的基础，它可以方便地实现数据的输入/输出操作，在Java中把不同的输入/输出源抽象表述为”流”。流是一组有顺序的，有起点和终点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。流有输入和输出，输入时是流从数据源流向程序。输出时是流从程序传向数据源，而数据源可以是内存，文件，网络或程序等。 二、IO流的分类1.输入流和输出流根据数据流向不同分为：输入流和输出流。 输入流:只能从中读取数据，而不能向其写入数据。输出流：只能向其写入数据，而不能从中读取数据。 如下如所示：对程序而言，向右的箭头，表示输入，向左的箭头，表示输出。 2.字节流和字符流字节流和字符流和用法几乎完全一样，区别在于字节流和字符流所操作的数据单元不同。字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。字节流和字符流的区别：（1）读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。（2）处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。 只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。 3.节点流和处理流按照流的角色来分，可以分为节点流和处理流。可以从/向一个特定的IO设备（如磁盘、网络）读/写数据的流，称为节点流，节点流也被成为低级流。处理流是对一个已存在的流进行连接或封装，通过封装后的流来实现数据读/写功能，处理流也被称为高级流。 1234//节点流，直接传入的参数是IO设备FileInputStream fis = new FileInputStream("test.txt");//处理流，直接传入的参数是流对象BufferedInputStream bis = new BufferedInputStream(fis); 当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入/输出节点连接。使用处理流的一个明显好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装节点流的变化，程序实际所访问的数据源也相应地发生变化。实际上，Java使用处理流来包装节点流是一种典型的装饰器设计模式，通过使用处理流来包装不同的节点流，既可以消除不同节点流的实现差异，也可以提供更方便的方法来完成输入/输出功能。 三、IO流的四大基类根据流的流向以及操作的数据单元不同，将流分为了四种类型，每种类型对应一种抽象基类。这四种抽象基类分别为：InputStream,Reader,OutputStream以及Writer。四种基类下，对应不同的实现类，具有不同的特性。在这些实现类中，又可以分为节点流和处理流。下面就是整个由着四大基类支撑下，整个IO流的框架图。InputStream,Reader,OutputStream以及Writer，这四大抽象基类，本身并不能创建实例来执行输入/输出，但它们将成为所有输入/输出流的模版，所以它们的方法是所有输入/输出流都可以使用的方法。类似于集合中的Collection接口。 1.InputStreamInputStream 是所有的输入字节流的父类，它是一个抽象类，主要包含三个方法： 123456//读取一个字节并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 int read() ； //读取一系列字节并存储到一个数组buffer，返回实际读取的字节数，如果读取前已到输入流的末尾返回-1。 int read(byte[] buffer) ； //读取length个字节并存储到一个字节数组buffer，从off位置开始存,最多len， 返回实际读取的字节数，如果读取前以到输入流的末尾返回-1。 int read(byte[] buffer, int off, int len) ； 2.ReaderReader 是所有的输入字符流的父类，它是一个抽象类，主要包含三个方法： 123456//读取一个字符并以整数的形式返回(0~255),如果返回-1已到输入流的末尾。 int read() ； //读取一系列字符并存储到一个数组buffer，返回实际读取的字符数，如果读取前已到输入流的末尾返回-1。 int read(char[] cbuf) ； //读取length个字符,并存储到一个数组buffer，从off位置开始存,最多读取len，返回实际读取的字符数，如果读取前以到输入流的末尾返回-1。 int read(char[] cbuf, int off, int len) 对比InputStream和Reader所提供的方法，就不难发现两个基类的功能基本一样的，只不过读取的数据单元不同。 在执行完流操作后，要调用close()方法来关系输入流，因为程序里打开的IO资源不属于内存资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件IO资源。 除此之外，InputStream和Reader还支持如下方法来移动流中的指针位置： 123456789//在此输入流中标记当前的位置//readlimit - 在标记位置失效前可以读取字节的最大限制。void mark(int readlimit)// 测试此输入流是否支持 mark 方法boolean markSupported()// 跳过和丢弃此输入流中数据的 n 个字节/字符long skip(long n)//将此流重新定位到最后一次对此输入流调用 mark 方法时的位置void reset() 3.OutputStreamOutputStream 是所有的输出字节流的父类，它是一个抽象类，主要包含如下四个方法： 12345678//向输出流中写入一个字节数据,该字节数据为参数b的低8位。 void write(int b) ; //将一个字节类型的数组中的数据写入输出流。 void write(byte[] b); //将一个字节类型的数组中的从指定位置（off）开始的,len个字节写入到输出流。 void write(byte[] b, int off, int len); //将输出流中缓冲的数据全部写出到目的地。 void flush(); 4.WriterWriter 是所有的输出字符流的父类，它是一个抽象类,主要包含如下六个方法： 123456789101112//向输出流中写入一个字符数据,该字节数据为参数b的低16位。 void write(int c); //将一个字符类型的数组中的数据写入输出流， void write(char[] cbuf) //将一个字符类型的数组中的从指定位置（offset）开始的,length个字符写入到输出流。 void write(char[] cbuf, int offset, int length); //将一个字符串中的字符写入到输出流。 void write(String string); //将一个字符串从offset开始的length个字符写入到输出流。 void write(String string, int offset, int length); //将输出流中缓冲的数据全部写出到目的地。 void flush() 可以看出，Writer比OutputStream多出两个方法，主要是支持写入字符和字符串类型的数据。 使用Java的IO流执行输出时，不要忘记关闭输出流，关闭输出流除了可以保证流的物理资源被回收之外，还能将输出流缓冲区的数据flush到物理节点里（因为在执行close()方法之前，自动执行输出流的flush()方法） 以上内容就是整个IO流的框架介绍。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaIO(一)]]></title>
    <url>%2F2018%2F06%2F08%2FJavaIO-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、字符与字节在Java中有输入、输出两种IO流，每种输入、输出流又分为字节流和字符流两大类。关于字节，我们在学习8大基本数据类型中都有了解，每个字节(byte)有8bit组成，每种数据类型又几个字节组成等。关于字符，我们可能知道代表一个汉字或者英文字母。 但是字节与字符之间的关系是怎样的？ Java采用unicode编码，2个字节来表示一个字符，这点与C语言中不同，C语言中采用ASCII，在大多数系统中，一个字符通常占1个字节，但是在0~127整数之间的字符映射，unicode向下兼容ASCII。而Java采用unicode来表示字符，一个中文或英文字符的unicode编码都占2个字节。但如果采用其他编码方式，一个字符占用的字节数则各不相同。可能有点晕，举个例子解释下。 例如：Java中的String类是按照unicode进行编码的，当使用String(byte[] bytes, String encoding)构造字符串时，encoding所指的是bytes中的数据是按照那种方式编码的，而不是最后产生的String是什么编码方式，换句话说，是让系统把bytes中的数据由encoding编码方式转换成unicode编码。如果不指明，bytes的编码方式将由jdk根据操作系统决定。 getBytes(String charsetName)使用指定的编码方式将此String编码为 byte 序列，并将结果存储到一个新的 byte 数组中。如果不指定将使用操作系统默认的编码方式，我的电脑默认的是GBK编码。 12345678910public class Hel &#123; public static void main(String[] args)&#123; String str = "你好hello"; int byte_len = str.getBytes().length; int len = str.length(); System.out.println("字节长度为：" + byte_len); System.out.println("字符长度为：" + len); System.out.println("系统默认编码方式：" + System.getProperty("file.encoding")); &#125; &#125; 输出结果 字节长度为：9字符长度为：7系统默认编码方式：GBK 这是因为：在 GB 2312 编码或 GBK 编码中，一个英文字母字符存储需要1个字节，一个汉字字符存储需要2个字节。 在UTF-8编码中，一个英文字母字符存储需要1个字节，一个汉字字符储存需要3到4个字节。在UTF-16编码中，一个英文字母字符存储需要2个字节，一个汉字字符储存需要3到4个字节（Unicode扩展区的一些汉字存储需要4个字节）。在UTF-32编码中，世界上任何字符的存储都需要4个字节。 简单来讲，一个字符表示一个汉字或英文字母，具体字符与字节之间的大小比例视编码情况而定。有时候读取的数据是乱码，就是因为编码方式不一致，需要进行转换，然后再按照unicode进行编码。 二、File类File类是java.io包下代表与平台无关的文件和目录，也就是说，如果希望在程序中操作文件和目录，都可以通过File类来完成。 ①构造函数12345678//构造函数File(String pathname)File f1 =new File("c:\\abc\\1.txt");//File(String parent,String child)File f2 =new File("c:\\abc","2.txt");//File(File parent,String child)File f3 =new File("c:"+File.separator+"abc");//separator 跨平台分隔符File f4 =new File(f3,"3.txt");System.out.println(f1);//c:\abc\1.txt 路径分隔符：windows： “/“ “\” 都可以linux/unix： “/“注意:如果windows选择用”\”做分割符的话,那么请记得替换成”\“,因为Java中”\”代表转义字符所以推荐都使用”/“，也可以直接使用代码File.separator，表示跨平台分隔符。路径：相对路径：./表示当前路径../表示上一级路径其中当前路径：默认情况下，java.io 包中的类总是根据当前用户目录来分析相对路径名。此目录由系统属性 user.dir 指定，通常是 Java 虚拟机的调用目录。” 绝对路径：绝对路径名是完整的路径名，不需要任何其他信息就可以定位自身表示的文件 ②创建与删除方法12345678910//如果文件存在返回false，否则返回true并且创建文件 boolean createNewFile();//创建一个File对象所对应的目录，成功返回true，否则false。且File对象必须为路径而不是文件。只会创建最后一级目录，如果上级目录不存在就抛异常。boolean mkdir();//创建一个File对象所对应的目录，成功返回true，否则false。且File对象必须为路径而不是文件。创建多级目录，创建路径中所有不存在的目录boolean mkdirs() ;//如果文件存在返回true并且删除文件，否则返回falseboolean delete();//在虚拟机终止时，删除File对象所表示的文件或目录。void deleteOnExit(); ③判断方法12345678boolean canExecute() ;//判断文件是否可执行boolean canRead();//判断文件是否可读boolean canWrite();//判断文件是否可写boolean exists();//判断文件是否存在boolean isDirectory();//判断是否是目录boolean isFile();//判断是否是文件boolean isHidden();//判断是否是隐藏文件或隐藏目录boolean isAbsolute();//判断是否是绝对路径 文件不存在也能判断 ③获取方法1234567891011String getName();//返回文件或者是目录的名称String getPath();//返回路径String getAbsolutePath();//返回绝对路径String getParent();//返回父目录，如果没有父目录则返回nulllong lastModified();//返回最后一次修改的时间long length();//返回文件的长度File[] listRoots();// 列出所有的根目录（Window中就是所有系统的盘符）String[] list() ;//返回一个字符串数组，给定路径下的文件或目录名称字符串String[] list(FilenameFilter filter);//返回满足过滤器要求的一个字符串数组File[] listFiles();//返回一个文件对象数组，给定路径下文件或目录File[] listFiles(FilenameFilter filter);//返回满足过滤器要求的一个文件对象数组 其中包含了一个重要的接口FileNameFilter，该接口是个文件过滤器，包含了一个accept(File dir,String name)方法，该方法依次对指定File的所有子目录或者文件进行迭代，按照指定条件，进行过滤，过滤出满足条件的所有文件。 1234567// 文件过滤File[] files = file.listFiles(new FilenameFilter() &#123; @Override public boolean accept(File file, String filename) &#123; return filename.endsWith(".mp3"); &#125;&#125;); file目录下的所有子文件如果满足后缀是.mp3的条件的文件都会被过滤出来。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java注解]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、元数据要想理解注解（Annotation）的作用，就要先理解Java中元数据的概念。 1.元数据概念元数据是关于数据的数据。在编程语言上下文中，元数据是添加到程序元素如方法、字段、类和包上的额外信息。对数据进行说明描述的数据。 2.元数据的作用一般来说，元数据可以用于创建文档（根据程序元素上的注释创建文档），跟踪代码中的依赖性（可声明方法是重载，依赖父类的方法），执行编译时检查（可声明是否编译期检测），代码分析。如下：1） 编写文档：通过代码里标识的元数据生成文档 2）代码分析：通过代码里标识的元数据对代码进行分析 3）编译检查：通过代码里标识的元数据让编译器能实现基本的编译检查 3.Java平台元数据注解Annotation就是java平台的元数据，是 J2SE5.0新增加的功能，该机制允许在Java 代码中添加自定义注释，并允许通过反射（reflection），以编程方式访问元数据注释。通过提供为程序元素（类、方法等）附加额外数据的标准方法，元数据功能具有简化和改进许多应用程序开发领域的潜在能力，其中包括配置管理、框架实现和代码生成。 二、注解（Annotation）1.注解（Annotation）的概念注解(Annotation)在JDK1.5之后增加的一个新特性，注解的引入意义很大，有很多非常有名的框架，比如Hibernate、Spring等框架中都大量使用注解。注解作为程序的元数据嵌入到程序。注解可以被解析工具或编译工具解析。 关于注解（Annotation）的作用，其实就是上述元数据的作用。 注意：Annotation能被用来为程序元素（类、方法、成员变量等）设置元素据。Annotaion不影响程序代码的执行，无论增加、删除Annotation，代码都始终如一地执行。如果希望让程序中的Annotation起一定的作用，只有通过解析工具或编译工具对Annotation中的信息进行解析和处理。 2.内建注解Java提供了多种内建的注解，下面接下几个比较常用的注解：@Override、@Deprecated、@SuppressWarnings以及@FunctionalInterface这4个注解。内建注解主要实现了元数据的第二个作用：编译检查。 @Override用途：用于告知编译器，我们需要覆写超类的当前方法。如果某个方法带有该注解但并没有覆写超类相应的方法，则编译器会生成一条错误信息。如果父类没有这个要覆写的方法，则编译器也会生成一条错误信息。 @Override可适用元素为方法，仅仅保留在java源文件中。 @Deprecated用途：使用这个注解，用于告知编译器，某一程序元素(比如方法，成员变量)不建议使用了（即过时了）。例如：Person类中的info()方法使用@Deprecated表示该方法过时了。 123456public class Person &#123; @Deprecated public void info()&#123; &#125;&#125; 调用info()方法会编译器会出现警告，告知该方法已过时。 注解类型分析：@Deprecated可适合用于除注解类型声明之外的所有元素，保留时长为运行时。 @SuppressWarnings用途：用于告知编译器忽略特定的警告信息，例在泛型中使用原生数据类型，编译器会发出警告，当使用该注解后，则不会发出警告。 注解类型分析： @SuppressWarnings可适合用于除注解类型声明和包名之外的所有元素，仅仅保留在java源文件中。 该注解有方法value(）,可支持多个字符串参数，用户指定忽略哪种警告，例如： 1@SupressWarning(value=&#123;"uncheck","deprecation"&#125;) @FunctionalInterface用途：用户告知编译器，检查这个接口，保证该接口是函数式接口，即只能包含一个抽象方法，否则就会编译出错。 注解类型分析： @FunctionalInterface可适合用于注解类型声明，保留时长为运行时。 3.元AnnotationJDK除了在java.lang提供了上述内建注解外，还在java.lang。annotation包下提供了6个Meta Annotation(元Annotataion)，其中有5个元Annotation都用于修饰其他的Annotation定义。其中@Repeatable专门用户定义Java 8 新增的可重复注解。 我们先介绍其中4个常用的修饰其他Annotation的元Annotation。在此之前，我们先了解如何自定义Annotation。 当一个接口直接继承java.lang.annotation.Annotation接口时，仍是接口，而并非注解。要想自定义注解类型，只能通过@interface关键字的方式，其实通过该方式会隐含地继承.Annotation接口。 @Documented @Documented用户指定被该元Annotation修饰的Annotation类将会被javadoc工具提取成文档，如果定义Annotation类时使用了@Documented修饰，则所有使用该Annotation修饰的程序元素的API文档中将会包含该Annotation说明。 例如： 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)public @interface Deprecated &#123;&#125; 定义@Deprecated时使用了@Documented，则任何元素使用@Deprecated修饰时，在生成API文档时，将会包含@Deprecated的说明以下是String的一个过时的构造方法： 12@Deprecatedpublic String(byte[] ascii,int hibyte,int offset, int count) 该注解实现了元数据的第一个功能：编写文档。 @Inherited @Inherited指定被它修饰的Annotation将具有继承性——如果某个类使用了@Xxx注解（定义该Annotation时使用了@Inherited修饰）修饰，则其子类将自动被@Xxx修饰。 @Retention @Retention：表示该注解类型的注解保留的时长。当注解类型声明中没有@Retention元注解，则默认保留策略为RetentionPolicy.CLASS。关于保留策略(RetentionPolicy)是枚举类型，共定义3种保留策略，如下表： @Target @Target：表示该注解类型的所适用的程序元素类型。当注解类型声明中没有@Target元注解，则默认为可适用所有的程序元素。如果存在指定的@Target元注解，则编译器强制实施相应的使用限制。关于程序元素(ElementType)是枚举类型，共定义8种程序元素，如下表： 三、自定义注解（Annotation）创建自定义注解，与创建接口有几分相似，但注解需要以@开头。 123456789@Documented@Target(ElementType.METHOD)@Inherited@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotataion&#123; String name(); String website() default "hello"; int revision() default 1;&#125; 自定义注解中定义成员变量的规则： 其定义是以无形参的方法形式来声明的。即：注解方法不带参数，比如name()，website()；注解方法返回值类型：基本类型、String、Enums、Annotation以及前面这些类型的数组类型注解方法可有默认值，比如default “hello”，默认website=”hello” 当然注解中也可以不存在成员变量，在使用解析注解进行操作时，仅以是否包含该注解来进行操作。当注解中有成员变量时，若没有默认值，需要在使用注解时，指定成员变量的值。 123456789101112public class AnnotationDemo &#123; @AuthorAnno(name="lvr", website="hello", revision=1) public static void main(String[] args) &#123; System.out.println("I am main method"); &#125; @SuppressWarnings(&#123; "unchecked", "deprecation" &#125;) @AuthorAnno(name="lvr", website="hello", revision=2) public void demo()&#123; System.out.println("I am demo method"); &#125;&#125; 由于该注解的保留策略为RetentionPolicy.RUNTIME，故可在运行期通过反射机制来使用，否则无法通过反射机制来获取。这时候注解实现的就是元数据的第二个作用：代码分析。下面来具体介绍如何通过反射机制来进行注解解析。 四、注解解析接下来，通过反射技术来解析自定义注解。关于反射类位于包java.lang.reflect，其中有一个接口AnnotatedElement，该接口主要有如下几个实现类：Class，Constructor，Field，Method，Package。除此之外，该接口定义了注释相关的几个核心方法，如下：因此，当获取了某个类的Class对象，然后获取其Field,Method等对象，通过上述4个方法提取其中的注解，然后获得注解的详细信息。 1234567891011121314151617public class AnnotationParser &#123; public static void main(String[] args) throws SecurityException, ClassNotFoundException &#123; String clazz = "com.lvr.annotation.AnnotationDemo"; Method[] demoMethod = AnnotationParser.class .getClassLoader().loadClass(clazz).getMethods(); for (Method method : demoMethod) &#123; if (method.isAnnotationPresent(MyAnnotataion.class)) &#123; MyAnnotataion annotationInfo = method.getAnnotation(MyAnnotataion.class); System.out.println("method: "+ method); System.out.println("name= "+ annotationInfo.name() + " , website= "+ annotationInfo.website() + " , revision= "+annotationInfo.revision()); &#125; &#125; &#125;&#125; 以上仅是一个示例，其实可以根据拿到的注解信息做更多有意义的事。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射三]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E5%8F%8D%E5%B0%84%E4%B8%89%2F</url>
    <content type="text"><![CDATA[一、泛型和Class类从JDK 1.5 后，Java中引入泛型机制，Class类也增加了泛型功能，从而允许使用泛型来限制Class类，例如：String.class的类型实际上是Class&lt;String&gt;。如果Class对应的类暂时未知，则使用Class&lt;?&gt;(?是通配符)。通过反射中使用泛型，可以避免使用反射生成的对象需要强制类型转换。 泛型的好处众多，最主要的一点就是避免类型转换，防止出现ClassCastException，即类型转换异常。以下面程序为例： 1234567891011121314public class ObjectFactory &#123; public static Object getInstance(String name)&#123; try &#123; //创建指定类对应的Class对象 Class cls = Class.forName(name); //返回使用该Class对象创建的实例 return cls.newInstance(); &#125; catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 上面程序是个工厂类，通过指定的字符串创建Class对象并创建一个类的实例对象返回。但是这个对象的类型是Object对象，取出实例后需要强制类型转换。如下例： 1Date date = (Date) ObjectFactory.getInstance("java.util.Date"); 或者如下： 1String string = (String) ObjectFactory.getInstance("java.util.Date"); 上面代码在编译时不会有任何问题，但是运行时将抛出ClassCastException异常，因为程序试图将一个Date对象转换成String对象。 但是泛型的出现后，就可以避免这种情况。 123456789101112public class ObjectFactory &#123; public static &lt;T&gt; T getInstance(Class&lt;T&gt; cls) &#123; try &#123; // 返回使用该Class对象创建的实例 return cls.newInstance(); &#125; catch (InstantiationException | IllegalAccessException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 在上面程序的getInstance()方法中传入一个Class&lt;T&gt;参数，这是一个泛型化的Class对象，调用该Class对象的newInstance()方法将返回一个T对象。 1String instance = ObjectFactory.getInstance(String.class); 通过传入String.class便知道T代表String，所以返回的对象是String类型的，避免强制类型转换。 当然Class类引入泛型的好处不止这一点，在以后的实际应用中会更加能体会到。 二、使用反射来获取泛型信息通过指定类对应的 Class 对象，可以获得该类里包含的所有 Field，不管该 Field 是使用 private 修饰，还是使用 public 修饰。获得了 Field 对象后，就可以很容易地获得该 Field 的数据类型，即使用如下代码即可获得指定 Field 的类型。 12// 获取 Field 对象 f 的类型Class&lt;?&gt; a = f.getType(); 但这种方式只对普通类型的 Field 有效。如果该 Field 的类型是有泛型限制的类型，如 Map&lt;String, Integer&gt; 类型，则不能准确地得到该 Field 的泛型参数。 为了获得指定 Field 的泛型类型，应先使用如下方法来获取指定 Field 的类型。 12// 获得 Field 实例的泛型类型Type type = f.getGenericType(); 然后将 Type 对象强制类型转换为 ParameterizedType 对象，ParameterizedType 代表被参数化的类型，也就是增加了泛型限制的类型。ParameterizedType 类提供了如下两个方法。 getRawType()：返回没有泛型信息的原始类型。 getActualTypeArguments()：返回泛型参数的类型。 下面是一个获取泛型类型的完整程序。 123456789101112131415161718192021222324252627282930313233343536public class GenericTest&#123; private Map&lt;String , Integer&gt; score; public static void main(String[] args) throws Exception &#123; Class&lt;GenericTest&gt; clazz = GenericTest.class; Field f = clazz.getDeclaredField("score"); // 直接使用getType()取出Field类型只对普通类型的Field有效 Class&lt;?&gt; a = f.getType(); // 下面将看到仅输出java.util.Map System.out.println("score的类型是:" + a); // 获得Field实例f的泛型类型 Type gType = f.getGenericType(); // 如果gType类型是ParameterizedType对象 if(gType instanceof ParameterizedType) &#123; // 强制类型转换 ParameterizedType pType = (ParameterizedType)gType; // 获取原始类型 Type rType = pType.getRawType(); System.out.println("原始类型是：" + rType); // 取得泛型类型的泛型参数 Type[] tArgs = pType.getActualTypeArguments(); System.out.println("泛型类型是:"); for (int i = 0; i &lt; tArgs.length; i++) &#123; System.out.println("第" + i + "个泛型类型是：" + tArgs[i]); &#125; &#125; else &#123; System.out.println("获取泛型类型出错！"); &#125; &#125;&#125; 输出结果： score 的类型是: interface java.util.Map原始类型是: interface java.util.Map泛型类型是:第 0 个泛型类型是: class java.lang.String第 1 个泛型类型是：class java.lang.Integer 从上面的运行结果可以看出，直接使用 Field 的 getType() 方法只能获取普通类型的 Field 的数据类型：对于增加了泛型参数的类型的 Field，应该使用 getGenericType() 方法来取得其类型。 Type 也是 java.lang.reflect 包下的一个接口，该接口代表所有类型的公共高级接口，Class 是 Type 接口的实现类。Type 包括原始类型、参数化类型、数组类型、类型变量和基本类型等。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射二]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E5%8F%8D%E5%B0%84%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[一、代理模式定义：给某个对象提供一个代理对象，并由代理对象控制对于原对象的访问，即客户不直接操控原对象，而是通过代理对象间接地操控原对象。 1、代理模式的理解代理模式使用代理对象完成用户请求，屏蔽用户对真实对象的访问。现实世界的代理人被授权执行当事人的一些事宜，无需当事人出面，从第三方的角度看，似乎当事人并不存在，因为他只和代理人通信。而事实上代理人是要有当事人的授权，并且在核心问题上还需要请示当事人。在软件设计中，使用代理模式的意图也很多，比如因为安全原因需要屏蔽客户端直接访问真实对象，或者在远程调用中需要使用代理类处理远程方法调用的技术细节，也可能为了提升系统性能，对真实对象进行封装，从而达到延迟加载的目的。 2、代理模式的参与者代理模式的角色分四种： 主题接口：Subject 是委托对象和代理对象都共同实现的接口，即代理类的所实现的行为接口。Request() 是委托对象和代理对象共同拥有的方法。目标对象：ReaSubject 是原对象，也就是被代理的对象。代理对象：Proxy 是代理对象，用来封装真是主题类的代理类。客户端 ：使用代理类和主题接口完成一些工作。 3、代理模式的分类代理的实现分为： 静态代理：代理类是在编译时就实现好的。也就是说 Java 编译完成后代理类是一个实际的 class 文件。动态代理：代理类是在运行时生成的。也就是说 Java 编译完之后并没有实际的 class 文件，而是在运行时动态生成的类字节码，并加载到JVM中。 4、代理模式的实现思路1.代理对象和目标对象均实现同一个行为接口。 2.代理类和目标类分别具体实现接口逻辑。 3.在代理类的构造函数中实例化一个目标对象。 4.在代理类中调用目标对象的行为接口。 5.客户端想要调用目标对象的行为接口，只能通过代理类来操作。 5、静态代理模式的简单实现1234567891011121314151617181920212223242526272829public class ProxyDemo &#123; public static void main(String args[])&#123; RealSubject subject = new RealSubject(); Proxy p = new Proxy(subject); p.request(); &#125;&#125;interface Subject&#123; void request();&#125;class RealSubject implements Subject&#123; public void request()&#123; System.out.println("request"); &#125;&#125;class Proxy implements Subject&#123; private Subject subject; public Proxy(Subject subject)&#123; this.subject = subject; &#125; public void request()&#123; System.out.println("PreProcess"); subject.request(); System.out.println("PostProcess"); &#125;&#125; 目标对象(RealSubject )以及代理对象（Proxy）都实现了主题接口（Subject）。在代理对象（Proxy）中，通过构造函数传入目标对象(RealSubject )，然后重写主题接口（Subject）的request()方法，在该方法中调用目标对象(RealSubject )的request()方法，并可以添加一些额外的处理工作在目标对象(RealSubject )的request()方法的前后。 代理模式的好处： 假如有这样的需求，要在某些模块方法调用前后加上一些统一的前后处理操作，比如在添加购物车、修改订单等操作前后统一加上登陆验证与日志记录处理，该怎样实现？首先想到最简单的就是直接修改源码，在对应模块的对应方法前后添加操作。如果模块很多，你会发现，修改源码不仅非常麻烦、难以维护，而且会使代码显得十分臃肿。 这时候就轮到代理模式上场了，它可以在被调用方法前后加上自己的操作，而不需要更改被调用类的源码，大大地降低了模块之间的耦合性，体现了极大的优势。 静态代理比较简单，上面的简单实例就是静态代理的应用方式，下面介绍本篇文章的主题：动态代理。 二、Java反射机制与动态代理动态代理的思路和上述思路一致，下面主要讲解如何实现。 1、动态代理介绍动态代理是指在运行时动态生成代理类。即，代理类的字节码将在运行时生成并载入当前代理的 ClassLoader。与静态处理类相比，动态类有诸多好处。 ①不需要为(RealSubject )写一个形式上完全一样的封装类，假如主题接口（Subject）中的方法很多，为每一个接口写一个代理方法也很麻烦。如果接口有变动，则目标对象和代理类都要修改，不利于系统维护； ②使用一些动态代理的生成方法甚至可以在运行时制定代理类的执行逻辑，从而大大提升系统的灵活性。 2、动态代理涉及的主要类主要涉及两个类，这两个类都是java.lang.reflect包下的类，内部主要通过反射来实现的。 java.lang.reflect.Proxy:这是生成代理类的主类，通过 Proxy 类生成的代理类都继承了 Proxy 类。Proxy提供了用户创建动态代理类和代理对象的静态方法，它是所有动态代理类的父类。 java.lang.reflect.InvocationHandler:这里称他为”调用处理器”，它是一个接口。当调用动态代理类中的方法时，将会直接转接到执行自定义的InvocationHandler中的invoke()方法。即我们动态生成的代理类需要完成的具体内容需要自己定义一个类，而这个类必须实现 InvocationHandler 接口，通过重写invoke()方法来执行具体内容。 Proxy提供了如下两个方法来创建动态代理类和动态代理实例。 static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;… interfaces) 返回代理类的java.lang.Class对象。第一个参数是类加载器对象（即哪个类加载器来加载这个代理类到 JVM 的方法区），第二个参数是接口（表明你这个代理类需要实现哪些接口），第三个参数是调用处理器类实例（指定代理类中具体要干什么），该代理类将实现interfaces所指定的所有接口，执行代理对象的每个方法时都会被替换执行InvocationHandler对象的invoke方法。 static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) 返回代理类实例。参数与上述方法一致。 对应上述两种方法创建动态代理对象的方式： 12345678//创建一个InvocationHandler对象InvocationHandler handler = new MyInvocationHandler(.args..);//使用Proxy生成一个动态代理类Class proxyClass = Proxy.getProxyClass(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces(), handler);//获取proxyClass类中一个带InvocationHandler参数的构造器Constructor constructor = proxyClass.getConstructor(InvocationHandler.class);//调用constructor的newInstance方法来创建动态实例RealSubject real = (RealSubject)constructor.newInstance(handler); 1234//创建一个InvocationHandler对象InvocationHandler handler = new MyInvocationHandler(.args..);//使用Proxy直接生成一个动态代理对象RealSubject real =Proxy.newProxyInstance(RealSubject.class.getClassLoader(),RealSubject.class.getInterfaces(), handler); newProxyInstance这个方法实际上做了两件事：第一，创建了一个新的类【代理类】，这个类实现了Class[] interfaces中的所有接口，并通过你指定的ClassLoader将生成的类的字节码加载到JVM中，创建Class对象；第二，以你传入的InvocationHandler作为参数创建一个代理类的实例并返回。 Proxy 类还有一些静态方法，比如： InvocationHandler getInvocationHandler(Object proxy):获得代理对象对应的调用处理器对象。 Class getProxyClass(ClassLoader loader, Class[] interfaces):根据类加载器和实现的接口获得代理类。 InvocationHandler 接口中有方法： invoke(Object proxy, Method method, Object[] args)这个函数是在代理对象调用任何一个方法时都会调用的，方法不同会导致第二个参数method不同，第一个参数是代理对象（表示哪个代理对象调用了method方法），第二个参数是 Method 对象（表示哪个方法被调用了），第三个参数是指定调用方法的参数。 3、动态代理模式的简单实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DynamicProxyDemo &#123; public static void main(String[] args) &#123; //1.创建目标对象 RealSubject realSubject = new RealSubject(); //2.创建调用处理器对象 ProxyHandler handler = new ProxyHandler(realSubject); //3.动态生成代理对象 Subject proxySubject = (Subject)Proxy.newProxyInstance(RealSubject.class.getClassLoader(), RealSubject.class.getInterfaces(), handler); //4.通过代理对象调用方法 proxySubject.request(); &#125;&#125;/** * 主题接口 */interface Subject&#123; void request();&#125;/** * 目标对象类 */class RealSubject implements Subject&#123; public void request()&#123; System.out.println("====RealSubject Request===="); &#125;&#125;/** * 代理类的调用处理器 */class ProxyHandler implements InvocationHandler&#123; private Subject subject; public ProxyHandler(Subject subject)&#123; this.subject = subject; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //定义预处理的工作，当然你也可以根据 method 的不同进行不同的预处理工作 System.out.println("====before===="); //调用RealSubject中的方法 Object result = method.invoke(subject, args); System.out.println("====after===="); return result; &#125;&#125; 可以看到，我们通过newProxyInstance就产生了一个Subject 的实例，即代理类的实例，然后就可以通过Subject .request()，就会调用InvocationHandler中的invoke()方法，传入方法Method对象，以及调用方法的参数，通过Method.invoke调用RealSubject中的方法的request()方法。同时可以在InvocationHandler中的invoke()方法加入其他执行逻辑。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射一]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E5%8F%8D%E5%B0%84%E4%B8%80%2F</url>
    <content type="text"><![CDATA[一、概述Java反射机制定义 Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类中的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。Java 反射机制的功能 1.在运行时判断任意一个对象所属的类。 2.在运行时构造任意一个类的对象。 3.在运行时判断任意一个类所具有的成员变量和方法。 4.在运行时调用任意一个对象的方法。 5.生成动态代理。 Java 反射机制的应用场景 1.逆向代码 ，例如反编译 2.与注解相结合的框架 例如Retrofit 3.单纯的反射机制应用框架 例如EventBus 4.动态生成类框架 例如Gson 二、通过Java反射查看类信息获得Class对象每个类被加载之后，系统就会为该类生成一个对应的Class对象。通过该Class对象就可以访问到JVM中的这个类。 在Java程序中获得Class对象通常有如下三种方式： 1.使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定名（必须添加完整包名）。 2.调用某个类的class属性来获取该类对应的Class对象。 3.调用某个对象的getClass()方法。该方法是java.lang.Object类中的一个方法。 1234567//第一种方式 通过Class类的静态方法——forName()来实现class1 = Class.forName("com.lvr.reflection.Person");//第二种方式 通过类的class属性class1 = Person.class;//第三种方式 通过对象getClass方法Person person = new Person();Class&lt;?&gt; class1 = person.getClass(); 获取class对象的属性、方法、构造函数等 1.获取class对象的成员变量 1234Field[] allFields = class1.getDeclaredFields();//获取class对象的所有属性Field[] publicFields = class1.getFields();//获取class对象的public属性Field ageField = class1.getDeclaredField("age");//获取class指定属性Field desField = class1.getField("des");//获取class指定的public属性 2.获取class对象的方法 1234Method[] methods = class1.getDeclaredMethods();//获取class对象的所有声明方法Method[] allMethods = class1.getMethods();//获取class对象的所有public方法 包括父类的方法Method method = class1.getMethod("info", String.class);//返回次Class对象对应类的、带指定形参列表的public方法Method declaredMethod = class1.getDeclaredMethod("info", String.class);//返回次Class对象对应类的、带指定形参列表的方法 3.获取class对象的构造函数 1234Constructor&lt;?&gt;[] allConstructors = class1.getDeclaredConstructors();//获取class对象的所有声明构造函数Constructor&lt;?&gt;[] publicConstructors = class1.getConstructors();//获取class对象public构造函数Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数Constructor publicConstructor = class1.getConstructor(String.class);//获取指定声明的public构造函数 4.其他方法 1234Annotation[] annotations = (Annotation[]) class1.getAnnotations();//获取class对象的所有注解Annotation annotation = (Annotation) class1.getAnnotation(Deprecated.class);//获取class对象指定注解Type genericSuperclass = class1.getGenericSuperclass();//获取class对象的直接超类的 TypeType[] interfaceTypes = class1.getGenericInterfaces();//获取class对象的所有接口的type集合 获取class对象的信息 比较多。 12345678910111213boolean isPrimitive = class1.isPrimitive();//判断是否是基础类型boolean isArray = class1.isArray();//判断是否是集合类boolean isAnnotation = class1.isAnnotation();//判断是否是注解类boolean isInterface = class1.isInterface();//判断是否是接口类boolean isEnum = class1.isEnum();//判断是否是枚举类boolean isAnonymousClass = class1.isAnonymousClass();//判断是否是匿名内部类boolean isAnnotationPresent = class1.isAnnotationPresent(Deprecated.class);//判断是否被某个注解类修饰String className = class1.getName();//获取class名字 包含包名路径Package aPackage = class1.getPackage();//获取class的包信息String simpleName = class1.getSimpleName();//获取class类名int modifiers = class1.getModifiers();//获取class访问权限Class&lt;?&gt;[] declaredClasses = class1.getDeclaredClasses();//内部类Class&lt;?&gt; declaringClass = class1.getDeclaringClass();//外部类 三、通过Java反射生成并操作对象生成类的实例对象 1.使用Class对象的newInstance()方法来创建该Class对象对应类的实例。这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()方法时实际上是利用默认构造器来创建该类的实例。 2.先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。 12345//第一种方式 Class对象调用newInstance()方法生成Object obj = class1.newInstance();//第二种方式 对象获得对应的Constructor对象，再通过该Constructor对象的newInstance()方法生成Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class);//获取指定声明构造函数obj = constructor.newInstance("hello"); 调用类的方法 1.通过Class对象的getMethods()方法或者getMethod()方法获得指定方法，返回Method数组或对象。 2.调用Method对象中的Object invoke(Object obj, Object... args)方法。第一个参数对应调用该方法的实例对象，第二个参数对应该方法的参数。 123456 // 生成新的对象：用newInstance()方法 Object obj = class1.newInstance();//首先需要获得与该方法对应的Method对象Method method = class1.getDeclaredMethod("setAge", int.class);//调用指定的函数并传递参数method.invoke(obj, 28); 当通过Method的invoke()方法来调用对应的方法时，Java会要求程序必须有调用该方法的权限。如果程序确实需要调用某个对象的private方法，则可以先调用Method对象的如下方法。setAccessible(boolean flag)：将Method对象的acessible设置为指定的布尔值。值为true，指示该Method在使用时应该取消Java语言的访问权限检查；值为false，则知识该Method在使用时要实施Java语言的访问权限检查。 访问成员变量值 1.通过Class对象的getFields()方法或者getField()方法获得指定方法，返回Field数组或对象。 2.Field提供了两组方法来读取或设置成员变量的值：getXXX(Object obj):获取obj对象的该成员变量的值。此处的XXX对应8种基本类型。如果该成员变量的类型是引用类型，则取消get后面的XXX。setXXX(Object obj,XXX val)：将obj对象的该成员变量设置成val值。 12345678//生成新的对象：用newInstance()方法 Object obj = class1.newInstance();//获取age成员变量Field field = class1.getField("age");//将obj对象的age的值设置为10field.setInt(obj, 10);//获取obj对象的age的值field.getInt(obj);]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaJava泛型]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、泛型简介1.引入泛型的目的了解引入泛型的动机，就先从语法糖开始了解。 语法糖 语法糖（Syntactic Sugar），也称糖衣语法，是由英国计算机学家Peter.J.Landin发明的一个术语，指在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。Java中最常用的语法糖主要有泛型、变长参数、条件编译、自动拆装箱、内部类等。虚拟机并不支持这些语法，它们在编译阶段就被还原回了简单的基础语法结构，这个过程成为解语法糖。 泛型的目的： Java 泛型就是把一种语法糖，通过泛型使得在编译阶段完成一些类型转换的工作，避免在运行时强制类型转换而出现ClassCastException，即类型转换异常。 2.泛型初探JDK 1.5 时才增加了泛型，并在很大程度上都是方便集合的使用，使其能够记住其元素的数据类型。 在泛型（Generic type或Generics）出现之前，是这么写代码的： 12345678public static void main(String[] args)&#123; List list = new ArrayList(); list.add("123"); list.add("456"); System.out.println((String)list.get(0));&#125; 当然这是完全允许的，因为List里面的内容是Object类型的，自然任何对象类型都可以放入、都可以取出，但是这么写会有两个问题： 1、当一个对象放入集合时，集合不会记住此对象的类型，当再次从集合中取出此对象时，该对象的编译类型变成了Object。 2、运行时需要人为地强制转换类型到具体目标，实际的程序绝不会这么简单，一个不小心就会出现java.lang.ClassCastException。 所以，泛型出现之后，上面的代码就改成了大家都熟知的写法： 123456789public static void main(String[] args)&#123; List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("123"); list.add("456"); System.out.println(list.get(0));&#125; 这就是泛型。泛型是对Java语言类型系统的一种扩展，有点类似于C++的模板，可以把类型参数看作是使用参数化类型时指定的类型的一个占位符。引入泛型，是对Java语言一个较大的功能增强，带来了很多的好处。 3.泛型的好处①类型安全。类型错误现在在编译期间就被捕获到了，而不是在运行时当作java.lang.ClassCastException展示出来，将类型检查从运行时挪到编译时有助于开发者更容易找到错误，并提高程序的可靠性。 ②消除了代码中许多的强制类型转换，增强了代码的可读性。 ③为较大的优化带来了可能。 二、泛型的使用1.泛型类和泛型接口下面是JDK 1.5 以后，List接口，以及ArrayList类的代码片段。 1234567891011121314//定义接口时指定了一个类型形参，该形参名为Epublic interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; //在该接口里，E可以作为类型使用 public E get(int index) &#123;&#125; public void add(E e) &#123;&#125; &#125;//定义类时指定了一个类型形参，该形参名为Epublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt; &#123; //在该类里，E可以作为类型使用 public void set(E e) &#123; ....................... &#125;&#125; 这就是泛型的实质：允许在定义接口、类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都可以使用这种类型形参。 下面具体讲解泛型类的使用。泛型接口的使用与泛型类几乎相同，可以比对自行学习。 泛型类 定义一个容器类，存放键值对key-value，键值对的类型不确定，可以使用泛型来定义，分别指定为K和V。 123456789101112131415161718192021222324252627public class Container&lt;K, V&gt; &#123; private K key; private V value; public Container(K k, V v) &#123; key = k; value = v; &#125; public K getkey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public void setKey() &#123; this.key = key; &#125; public void setValue() &#123; this.value = value; &#125;&#125; 在使用Container类时，只需要指定K，V的具体类型即可，从而创建出逻辑上不同的Container实例，用来存放不同的数据类型。 12345678public static void main(String[] args) &#123; Container&lt;String,String&gt; c1=new Container&lt;String ,String&gt;("name","hello"); Container&lt;String,Integer&gt; c2=new Container&lt;String,Integer&gt;("age",22); Container&lt;Double,Double&gt; c3=new Container&lt;Double,Double&gt;(1.1,1.3); System.out.println(c1.getKey() + " : " + c1.getValue()); System.out.println(c2.getKey() + " : " + c2.getValue()); System.out.println(c3.getKey() + " : " + c3.getValue());&#125; 在JDK 1.7 增加了泛型的“菱形”语法：Java允许在构造器后不需要带完成的泛型信息，只要给出一对尖括号（&lt;&gt;）即可，Java可以推断尖括号里应该是什么泛型信息。如下所示： 12Container&lt;String,String&gt; c1=new Container&lt;&gt;("name","hello");Container&lt;String,Integer&gt; c2=new Container&lt;&gt;("age",22); 泛型类派生子类 当创建了带泛型声明的接口、父类之后，可以为该接口创建实现类，或者从该父类派生子类，需要注意：使用这些接口、父类派生子类时不能再包含类型形参，需要传入具体的类型。错误的方式： 1public class A extends Container&lt;K, V&gt;&#123;&#125; 正确的方式： 1public class A extends Container&lt;Integer, String&gt;&#123;&#125; 也可以不指定具体的类型，如下： 1public class A extends Container&#123;&#125; 此时系统会把K,V形参当成Object类型处理。 2.泛型的方法前面在介绍泛型类和泛型接口中提到，可以在泛型类、泛型接口的方法中，把泛型中声明的类型形参当成普通类型使用。 如下面的方式： 1234567891011public class Container&lt;K, V&gt; &#123;........................ public K getkey() &#123; return key; &#125; public void setKey() &#123; this.key = key; &#125;....................&#125; 但在另外一些情况下，在类、接口中没有使用泛型时，定义方法时想定义类型形参，就会使用泛型方法。如下方式： 123456789public class Main&#123; public static &lt;T&gt; void out(T t)&#123; System.out.println(t); &#125; public static void main(String[] args)&#123; out("hansheng"); out(123); &#125;&#125; 所谓泛型方法，就是在声明方法时定义一个或多个类型形参。 泛型方法的用法格式如下： 123修饰符&lt;T, S&gt; 返回值类型 方法名（形参列表）｛ 方法体｝ 注意： 方法声明中定义的形参只能在该方法里使用，而接口、类声明中定义的类型形参则可以在整个接口、类中使用。 1234567891011121314class Demo&#123; public &lt;T&gt; T fun(T t)&#123; // 可以接收任意类型的数据 return t ; // 直接把参数返回 &#125; &#125;; public class GenericsDemo26&#123; public static void main(String args[])&#123; Demo d = new Demo() ; // 实例化Demo对象 String str = d.fun("汤姆") ; // 传递字符串 int i = d.fun(30) ; // 传递数字，自动装箱 System.out.println(str) ; // 输出内容 System.out.println(i) ; // 输出内容 &#125; &#125;; 当调用fun()方法时，根据传入的实际对象，编译器就会判断出类型形参T所代表的实际类型。 3.泛型构造器正如泛型方法允许在方法签名中声明类型形参一样，Java也允许在构造器签名中声明类型形参，这样就产生了所谓的泛型构造器。和使用普通泛型方法一样没区别，一种是显式指定泛型参数，另一种是隐式推断，如果是显式指定则以显式指定的类型参数为准，如果传入的参数的类型和指定的类型实参不符，将会编译报错。 123456public class Person &#123; public &lt;T&gt; Person(T t) &#123; System.out.println(t); &#125;&#125; 123456public static void main(String[] args)&#123; //隐式 new Person(22); //显示 new&lt;String&gt; Person("hello");&#125; 这里唯一需要特殊注明的就是，如果构造器是泛型构造器，同时该类也是一个泛型类的情况下应该如何使用泛型构造器：因为泛型构造器可以显式指定自己的类型参数（需要用到菱形，放在构造器之前），而泛型类自己的类型实参也需要指定（菱形放在构造器之后），这就同时出现了两个菱形了，这就会有一些小问题，具体用法再这里总结一下。以下面这个例子为代表 123456public class Person&lt;E&gt; &#123; public &lt;T&gt; Person(T t) &#123; System.out.println(t); &#125;&#125; 这种用法：Person&lt;String&gt; a = new &lt;Integer&gt;Person&lt;&gt;(15);这种语法不允许，会直接编译报错！ 三、类型通配符顾名思义就是匹配任意类型的类型实参。 类型通配符是一个问号（？)，将一个问号作为类型实参传给List集合，写作：List&lt;?&gt;（意思是元素类型未知的List）。这个问号（？）被成为通配符，它的元素类型可以匹配任何类型。 12345public void test(List&lt;?&gt; c)&#123; for(int i =0;i&lt;c.size();i++)&#123; System.out.println(c.get(i)); &#125;&#125; 现在可以传入任何类型的List来调用test()方法，程序依然可以访问集合c中的元素，其类型是Object。 123List&lt;?&gt; c = new ArrayList&lt;String&gt;();//编译器报错c.add(new Object()); 但是并不能把元素加入到其中。因为程序无法确定c集合中元素的类型，所以不能向其添加对象。下面就该引入带限通配符，来确定集合元素中的类型。 带限通配符简单来讲，使用通配符的目的是来限制泛型的类型参数的类型，使其满足某种条件，固定为某些类。 主要分为两类即：上限通配符和下限通配符。 1.上限通配符如果想限制使用泛型类别时，只能用某个特定类型或者是其子类型才能实例化该类型时，可以在定义类型时，使用extends关键字指定这个类型必须是继承某个类，或者实现某个接口，也可以是这个类或接口本身。 12它表示集合中的所有元素都是Shape类型或者其子类List&lt;? extends Shape&gt; 这就是所谓的上限通配符，使用关键字extends来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。例如： 12//Circle是其子类List&lt;? extends Shape&gt; list = new ArrayList&lt;Circle&gt;(); 这样就确定集合中元素的类型，虽然不确定具体的类型，但最起码知道其父类。然后进行其他操作。 2.下限通配符如果想限制使用泛型类别时，只能用某个特定类型或者是其父类型才能实例化该类型时，可以在定义类型时，使用super关键字指定这个类型必须是是某个类的父类，或者是某个接口的父接口，也可以是这个类或接口本身。 12它表示集合中的所有元素都是Circle类型或者其父类List &lt;? super Circle&gt; 这就是所谓的下限通配符，使用关键字super来实现，实例化时，指定类型实参只能是extends后类型的子类或其本身。例如： 12//Shape是其父类List&lt;? super Circle&gt; list = new ArrayList&lt;Shape&gt;(); 四、类型擦除123Class c1=new ArrayList&lt;Integer&gt;().getClass();Class c2=new ArrayList&lt;String&gt;().getClass();System.out.println(c1==c2); 程序输出： true。 这是因为不管为泛型的类型形参传入哪一种类型实参，对于Java来说，它们依然被当成同一类处理，在内存中也只占用一块内存空间。从Java泛型这一概念提出的目的来看，其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 在静态方法、静态初始化块或者静态变量的声明和初始化中不允许使用类型形参。由于系统中并不会真正生成泛型类，所以instanceof运算符后不能使用泛型类。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaJava集合——LinkedHashMap]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E9%9B%86%E5%90%88%E2%80%94%E2%80%94LinkedHashMap%2F</url>
    <content type="text"><![CDATA[一、 概述在理解了HashMap后，我们来学习LinkedHashMap的工作原理及实现。首先还是类似的，我们写一个简单的LinkedHashMap的程序： 123456789101112LinkedHashMap&lt;String, Integer&gt; lmap = new LinkedHashMap&lt;String, Integer&gt;();lmap.put("语文", 1);lmap.put("数学", 2);lmap.put("英语", 3);lmap.put("历史", 4);lmap.put("政治", 5);lmap.put("地理", 6);lmap.put("生物", 7);lmap.put("化学", 8);for(Entry&lt;String, Integer&gt; entry : lmap.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 运行结果是： 语文: 1数学: 2英语: 3历史: 4政治: 5地理: 6生物: 7化学: 8 我们可以观察到，和HashMap的运行结果不同，LinkedHashMap的迭代输出的结果保持了插入顺序。是什么样的结构使得LinkedHashMap具有如此特性呢？我们还是一样的看看LinkedHashMap的内部结构，对它有一个感性的认识： 没错，正如官方文档所说： Hash table and linked list implementation of the Map interface, with predictable iteration order. This implementation differs from HashMap in that it maintains a doubly-linked list running through all of its entries. This linked list defines the iteration ordering, which is normally the order in which keys were inserted into the map (insertion-order). LinkedHashMap是Hash表和链表的实现，并且依靠着双向链表保证了迭代顺序是插入的顺序。 二、 三个重点实现的函数在HashMap中提到了下面的定义： 1234// Callbacks to allow LinkedHashMap post-actionsvoid afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;void afterNodeInsertion(boolean evict) &#123; &#125;void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125; LinkedHashMap继承于HashMap，因此也重新实现了这3个函数，顾名思义这三个函数的作用分别是：节点访问后、节点插入后、节点移除后做一些事情。 afterNodeAccess函数 12345678910111213141516171819202122232425void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; // 如果定义了accessOrder，那么就保证最近访问节点放到最后 if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; 就是说在进行put之后就算是对节点的访问了，那么这个时候就会更新链表，把最近访问的放到最后，保证链表。 afterNodeInsertion函数 12345678void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; // 如果定义了溢出规则，则执行相应的溢出 if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125; 如果用户定义了removeEldestEntry的规则，那么便可以执行相应的移除操作。 afterNodeRemoval函数 1234567891011121314void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink // 从链表中移除节点 LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; 这个函数是在移除节点后调用的，就是将节点从双向链表中删除。 我们从上面3个函数看出来，基本上都是为了保证双向链表中的节点次序或者双向链表容量所做的一些额外的事情，目的就是保持双向链表中节点的顺序要从eldest到youngest。 三、 put和get函数put函数在LinkedHashMap中未重新实现，只是实现了afterNodeAccess和afterNodeInsertion两个回调函数。get函数则重新实现并加入了afterNodeAccess来保证访问顺序，下面是get函数的具体实现： 12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 值得注意的是，在accessOrder模式下，只要执行get或者put等操作的时候，就会产生structural modification。官方文档是这么描述的： A structural modification is any operation that adds or deletes one or more mappings or, in the case of access-ordered linked hash maps, affects iteration order. In insertion-ordered linked hash maps, merely changing the value associated with a key that is already contained in the map is not a structural modification. In access-ordered linked hash maps, merely querying the map with get is a structural modification. 总之，LinkedHashMap不愧是HashMap的儿子，和老子太像了，当然，青出于蓝而胜于蓝，LinkedHashMap的其他的操作也基本上都是为了维护好那个具有访问顺序的双向链表。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaJava集合——TreeMap]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E9%9B%86%E5%90%88%E2%80%94%E2%80%94TreeMap%2F</url>
    <content type="text"><![CDATA[一、概述 {1-_概述} A Red-Black tree based NavigableMap implementation. The map is sorted according to the natural ordering of its keys, or by a Comparator provided at map creation time, depending on which constructor is used.This implementation provides guaranteed log(n) time cost for the containsKey, get, put and remove operations. Algorithms are adaptations of those in Cormen, Leiserson, and Rivest’s Introduction to Algorithms. 之前已经学习过HashMap和LinkedHashMap了，HashMap不保证数据有序，LinkedHashMap保证数据可以保持插入顺序，而如果我们希望Map可以保持key的大小顺序的时候，我们就需要利用TreeMap了。 123456789101112TreeMap&lt;Integer, String&gt; tmap = new TreeMap&lt;Integer, String&gt;();tmap.put(1, "语文");tmap.put(3, "英语");tmap.put(2, "数学");tmap.put(4, "政治");tmap.put(5, "历史");tmap.put(6, "地理");tmap.put(7, "生物");tmap.put(8, "化学");for(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 其大致的结构如下所示：使用红黑树的好处是能够使得树具有不错的平衡性，这样操作的速度就可以达到log(n)的水平了。具体红黑树的实现不在这里赘述，可以参考数据结构之红黑树、wikipedia-红黑树等的实现。 二、 put函数 {2-_put函数} Associates the specified value with the specified key in this map.If the map previously contained a mapping for the key, the old value is replaced. 如果存在的话，old value被替换；如果不存在的话，则新添一个节点，然后对做红黑树的平衡操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; // 如果该节点存在，则替换值直接返回 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 如果该节点未存在，则新建 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; // 红黑树平衡调整 fixAfterInsertion(e); size++; modCount++; return null;&#125; 三、 get函数 {3-_get函数}get函数则相对来说比较简单，以log(n)的复杂度进行get。 12345678910111213141516171819202122232425final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; // 按照二叉树搜索的方式进行搜索，搜到返回 while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125;public V get(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value);&#125; 四、successor后继 {4-_successor后继}TreeMap是如何保证其迭代输出是有序的呢？其实从宏观上来讲，就相当于树的中序遍历(LDR)。我们先看一下迭代输出的步骤 123for(Entry&lt;Integer, String&gt; entry : tmap.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 根据The enhanced for statement，for语句会做如下转换为： 1234for(Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it = tmap.entrySet().iterator() ; tmap.hasNext(); ) &#123; Entry&lt;Integer, String&gt; entry = it.next(); System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 在it.next()的调用中会使用nextEntry调用successor这个是过的后继的重点，具体实现如下： 1234567891011121314151617181920212223static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123; // 有右子树的节点，后继节点就是右子树的“最左节点” // 因为“最左子树”是右子树的最小节点 Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; // 如果右子树为空，则寻找当前节点所在左子树的第一个祖先节点 // 因为左子树找完了，根据LDR该D了 Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; // 保证左子树 while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125;&#125; 怎么理解这个successor呢？只要记住，这个是中序遍历就好了，L-D-R。具体细节如下： a. 空节点，没有后继b. 有右子树的节点，后继就是右子树的“最左节点”c. 无右子树的节点，后继就是该节点所在左子树的第一个祖先节点 a.好理解，不过b, c，有点像绕口令啊，没关系，上图举个例子就懂了！ 有右子树的节点，节点的下一个节点，肯定在右子树中，而右子树中“最左”的那个节点则是右子树中最小的一个，那么当然是右子树的“最左节点”，就好像下图所示： 无右子树的节点，先找到这个节点所在的左子树(右图)，那么这个节点所在的左子树的父节点(绿色节点)，就是下一个节点。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaJava集合——HashMap]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E9%9B%86%E5%90%88%E2%80%94%E2%80%94HashMap%2F</url>
    <content type="text"><![CDATA[一、概述从本文你可以学习到： 什么时候会使用HashMap？他有什么特点？ 你知道HashMap的工作原理吗？ 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？ 你知道hash的实现吗？为什么要这样实现？ 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？ 当我们执行下面的操作时： 123456789101112HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();map.put("语文", 1);map.put("数学", 2);map.put("英语", 3);map.put("历史", 4);map.put("政治", 5);map.put("地理", 6);map.put("生物", 7);map.put("化学", 8);for(Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ": " + entry.getValue());&#125; 运行结果是 政治: 5生物: 7历史: 4数学: 2化学: 8语文: 1英语: 3地理: 6 发生了什么呢？下面是一个大致的结构，希望我们对HashMap的结构有一个感性的认识： 在官方文档中是这样描述HashMap的： Hash table basedimplementation of the Map interface. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it isunsynchronizedandpermits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time. 几个关键的信息：基于Map接口实现、允许null键/值、非同步、不保证有序(比如插入的顺序)、也不保证序不随时间变化。 二、两个重要的参数在HashMap中有两个很重要的参数，容量(Capacity)和负载因子(Load factor) Initial capacityThe capacity isthe number of bucketsin the hash table, The initial capacity is simply the capacity at the time the hash table is created. Load factorThe load factor isa measure of how full the hash table is allowed to getbefore its capacity is automatically increased. 简单的说，Capacity就是bucket的大小，Load factor就是bucket填满程度的最大比例。如果对迭代性能要求很高的话，不要把capacity设置过大，也不要把load factor设置过小。当bucket中的entries的数目大于capacity*load factor时就需要调整bucket的大小为当前的2倍。 三、put函数的实现put函数大致的思路为： 对key的hashCode()做hash，然后再计算index; 如果没碰撞直接放到bucket里； 如果碰撞了，以链表的形式存在buckets后； 如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树； 如果节点已经存在就替换old value(保证key的唯一性) 如果bucket满了(超过load factor*current capacity)，就要resize。 具体代码的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public V put(K key, V value) &#123; // 对key的hashCode()做hash return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // tab为空则创建 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 计算index，并对null做处理 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; // 节点存在 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 该链为树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 该链为链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; // 写入 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; // 超过load factor*current capacity，resize if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 四、get函数的实现在理解了put之后，get就很简单了。大致思路如下： bucket里的第一个节点，直接命中； 如果有冲突，则通过key.equals(k)去查找对应的entry 若为树，则在树中通过key.equals(k)查找，O(logn)； 若为链表，则在链表中通过key.equals(k)查找，O(n)。 具体代码的实现如下： 123456789101112131415161718192021222324252627public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 直接命中 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 未命中 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 五、hash函数的实现在get和put的过程中，计算下标时，先对hashCode进行hash操作，然后再通过hash值进一步计算下标，如下图所示： 在对hashCode()计算hash时具体实现是这样的： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 可以看到这个函数大概的作用就是：高16bit不变，低16bit和高16bit做了一个异或。其中代码注释是这样写的： Computes key.hashCode() and spreads (XORs) higher bits of hash to lower. Because the table uses power-of-two masking, sets of hashes that vary only in bits above the current mask will always collide. (Among known examples are sets of Float keys holding consecutive whole numbers in small tables.) So we apply a transform that spreads the impact of higher bits downward. There is a tradeoff betweenspeed, utility, and qualityof bit-spreading. Because many common sets of hashes are alreadyreasonably distributed(so don’t benefit from spreading), and becausewe use trees to handle large sets of collisions in bins, we just XOR some shifted bits in the cheapest possible way to reduce systematic lossage, as well as to incorporate impact of the highest bits that would otherwise never be used in index calculations because of table bounds. 在设计hash函数时，因为目前的table长度n为2的幂，而计算下标的时候，是这样实现的(使用&amp;位操作，而非%求余)： 1(n - 1) &amp; hash 设计者认为这方法很容易发生碰撞。为什么这么说呢？不妨思考一下，在n - 1为15(0x1111)时，其实散列真正生效的只是低4bit的有效位，当然容易碰撞了。 因此，设计者想了一个顾全大局的方法(综合考虑了速度、作用、质量)，就是把高16bit和低16bit异或了一下。设计者还解释到因为现在大多数的hashCode的分布已经很不错了，就算是发生了碰撞也用O(logn)的tree去做了。仅仅异或一下，既减少了系统的开销，也不会造成的因为高位没有参与下标的计算(table长度比较小时)，从而引起的碰撞。 如果还是产生了频繁的碰撞，会发生什么问题呢？作者注释说，他们使用树来处理频繁的碰撞(we use trees to handle large sets of collisions in bins)，在JEP-180中，描述了这个问题： Improve the performance of java.util.HashMap under high hash-collision conditions byusing balanced trees rather than linked lists to store map entries. Implement the same improvement in the LinkedHashMap class. 之前已经提过，在获取HashMap的元素时，基本分两步： 首先根据hashCode()做hash，然后确定bucket的index； 如果bucket的节点的key不是我们需要的，则通过keys.equals()在链中找。 在Java 8之前的实现中是用链表解决冲突的，在产生碰撞的情况下，进行get时，两步的时间复杂度是O(1)+O(n)。因此，当碰撞很厉害的时候n很大，O(n)的速度显然是影响速度的。 因此在Java 8中，利用红黑树替换链表，这样复杂度就变成了O(1)+O(logn)了，这样在n很大的时候，能够比较理想的解决这个问题，在Java 8：HashMap的性能提升一文中有性能测试的结果。 六、RESIZE的实现当put时，如果发现目前的bucket占用程度已经超过了Load Factor所希望的比例，那么就会发生resize。在resize的过程，简单的说就是把bucket扩充为2倍，之后重新计算index，把节点再放到新的bucket中。resize的注释是这样描述的： Initializes or doubles table size. If null, allocates in accord with initial capacity target held in field threshold. Otherwise, because we are using power-of-two expansion, the elements from each bin must eitherstay at same index, ormove with a power of two offsetin the new table. 大致意思就是说，当超过限制的时候会resize，然而又因为我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。 怎么理解呢？例如我们从16扩展为32时，具体的变化如下所示： 因此元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： 因此，我们在扩充HashMap的时候，不需要重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。可以看看下图为16扩充为32的resize示意图： 这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。 下面是代码的具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 七、总结我们现在可以回答开始的几个问题，加深对HashMap的理解： 1. 什么时候会使用HashMap？他有什么特点？是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。 2. 你知道HashMap的工作原理吗？通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。 3. 你知道get和put的原理吗？equals()和hashCode()的都有什么作用？通过对key的hashCode()进行hashing，并计算下标( (n-1) &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点 4. 你知道hash的实现吗？为什么要这样实现？在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。 5. 如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JaJava集合——LinkedList]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E9%9B%86%E5%90%88%E2%80%94%E2%80%94LinkedList%2F</url>
    <content type="text"><![CDATA[一、 概述 以双向链表实现。链表无容量限制，但双向链表本身使用了更多空间，也需要额外的链表指针操作。 按下标访问元素—get(i)/set(i,e) 要悲剧的遍历链表将指针移动到位(如果i&gt;数组大小的一半，会从末尾移起)。 插入、删除元素时修改前后节点的指针即可，但还是要遍历部分链表的指针才能移动到下标所指的位置，只有在链表两头的操作—add()，addFirst()，removeLast()或用iterator()上的remove()能省掉指针的移动。 LinkedList是一个简单的数据结构，与ArrayList不同的是，他是基于链表实现的。 Doubly-linked list implementation of the List and Deque interfaces. Implements all optional list operations, and permits all elements (including null). 1234LinkedList&lt;String&gt; list = new LinkedList&lt;String&gt;();list.add("语文: 1");list.add("数学: 2");list.add("英语: 3"); 结构也相对简单一些，如下图所示： 二、 set和get函数 {2-_set和get函数}1234567891011public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; 这两个函数都调用了node函数，该函数会以O(n/2)的性能去获取一个节点，具体实现如下所示： 1234567891011121314Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 就是判断index是在前半区间还是后半区间，如果在前半区间就从head搜索，而在后半区间就从tail搜索。而不是一直从头到尾的搜索。如此设计，将节点访问的复杂度由O(n)变为O(n/2)。]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合——ArrayList]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E9%9B%86%E5%90%88%E2%80%94%E2%80%94ArrayList%2F</url>
    <content type="text"><![CDATA[一、概述 以数组实现。节约空间，但数组有容量限制。超出限制时会增加50%容量，用System.arraycopy()复制到新的数组，因此最好能给出数组大小的预估值。默认第一次插入元素时创建大小为10的数组。 按数组下标访问元素—get(i)/set(i,e) 的性能很高，这是数组的基本优势。 直接在数组末尾加入元素—add(e)的性能也高，但如果按下标插入、删除元素—add(i,e), remove(i), remove(e)，则要用System.arraycopy()来移动部分受影响的元素，性能就变差了，这是基本劣势。 然后再来学习一下官方文档： Resizable-arrayimplementation of the List interface. Implements all optional list operations, and permits all elements, including null. In addition to implementing the List interface, this class provides methods to manipulate the size of the array that is used internally to store the list. (This class is roughly equivalent to Vector, except that it is unsynchronized.) ArrayList是一个相对来说比较简单的数据结构，最重要的一点就是它的自动扩容，可以认为就是我们常说的“动态数组”。来看一段简单的代码： 12345ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add("语文: 99");list.add("数学: 98");list.add("英语: 100");list.remove(0); 在执行这四条语句时，是这么变化的：其中，add操作可以理解为直接将数组的内容置位，remove操作可以理解为删除index为0的节点，并将后面元素移到0处。 二、 add函数 {2-_add函数}当我们在ArrayList中增加元素的时候，会使用add函数。他会将元素放到末尾。具体实现如下： 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 我们可以看到他的实现其实最核心的内容就是ensureCapacityInternal。这个函数其实就是自动扩容机制的核心。我们依次来看一下他的具体实现 12345678910111213141516171819202122232425private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 扩展为原来的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 如果扩为1.5倍还不满足需求，直接扩为需求值 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; 也就是说，当增加数据的时候，如果ArrayList的大小已经不满足需求时，那么就将数组变为原长度的1.5倍，之后的操作就是把老的数组拷到新的数组里面。例如，默认的数组大小是10，也就是说当我们add10个元素之后，再进行一次add时，就会发生自动扩容，数组长度由10变为了15具体情况如下所示： 三、set和get函数 {3_set和get函数}Array的set和get函数就比较简单了，先做index检查，然后执行赋值或访问操作： 12345678910public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 四、remove函数 {4_remove函数}12345678910111213public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) // 把后面的往前移 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 把最后的置null elementData[--size] = null; // clear to let GC do its work return oldValue;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合框架]]></title>
    <url>%2F2018%2F06%2F08%2FJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[一、Java集合类简介：Java集合大致可以分为Set、List、Queue和Map四种体系。 其中Set代表无序、不可重复的集合；List代表有序、重复的集合；而Map则代表具有映射关系的集合。Java 5 又增加了Queue体系集合，代表一种队列集合实现。 Java集合就像一种容器，可以把多个对象（实际上是对象的引用，但习惯上都称对象）“丢进”该容器中。从Java 5 增加了泛型以后，Java集合可以记住容器中对象的数据类型，使得编码更加简洁、健壮。 1.Java集合和数组的区别：①.数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。 ②.数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。 2.Java集合类之间的继承关系:Java的集合类主要由两个接口派生而出：Collection和Map,Collection和Map是Java集合框架的根接口。 图中，ArrayList,HashSet,LinkedList,TreeSet是我们经常会有用到的已实现的集合类。 Map实现类用于保存具有映射关系的数据。Map保存的每项数据都是key-value对，也就是由key和value两个值组成。Map里的key是不可重复的，key用户标识集合里的每项数据。 图中，HashMap，TreeMap是我们经常会用到的集合类。 二、Collection接口：1.简介Collection接口是Set,Queue,List的父接口。Collection接口中定义了多种方法可供其子类进行实现，以实现数据操作。由于方法比较多，就偷个懒，直接把JDK文档上的内容搬过来。 1.1.接口中定义的方法 可以看出Collection用法有：添加元素，删除元素，返回Collection集合的个数以及清空集合等。其中重点介绍iterator()方法，该方法的返回值是Iterator。 1.2.使用Iterator遍历集合元素Iterator接口经常被称作迭代器，它是Collection接口的父接口。但Iterator主要用于遍历集合中的元素。Iterator接口中主要定义了2个方法： 下面程序简单示范了通过Iterator对象逐个获取元素的逻辑。 123456789101112131415161718public class IteratorExample &#123; public static void main(String[] args)&#123; //创建集合，添加元素 Collection&lt;Day&gt; days = new ArrayList&lt;Day&gt;(); for(int i =0;i&lt;10;i++)&#123; Day day = new Day(i,i*60,i*3600); days.add(day); &#125; //获取days集合的迭代器 Iterator&lt;Day&gt; iterator = days.iterator(); while(iterator.hasNext())&#123;//判断是否有下一个元素 Day next = iterator.next();//取出该元素 //逐个遍历，取得元素后进行后续操作 ..... &#125; &#125;&#125; 注意： 当使用Iterator对集合元素进行迭代时，把集合元素的值传给了迭代变量（就如同参数传递是值传递，基本数据类型传递的是值，引用类型传递的仅仅是对象的引用变量。 下面的程序演示了这一点：123456789101112131415161718192021222324252627282930public class IteratorExample &#123; public static void main(String[] args) &#123; List&lt;MyObject&gt; list = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; list.add(new MyObject(i)); &#125; System.out.println(list.toString()); Iterator&lt;MyObject&gt; iterator = list.iterator();//集合元素的值传给了迭代变量，仅仅传递了对象引用。保存的仅仅是指向对象内存空间的地址 while (iterator.hasNext()) &#123; MyObject next = iterator.next(); next.num = 99; &#125; System.out.println(list.toString()); &#125; static class MyObject &#123; int num; MyObject(int num) &#123; this.num = num; &#125; @Override public String toString() &#123; return String.valueOf(num); &#125; &#125;&#125; 输出结果如下： [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [99, 99, 99, 99, 99, 99, 99, 99, 99, 99] 下面具体介绍Collection接口的三个子接口Set，List，Queue。 2.Set集合简介Set集合与Collection集合基本相同，没有提供任何额外的方法。实际上Set就是Collection，只是行为略有不同（Set不允许包含重复元素）。 Set集合不允许包含相同的元素，如果试图把两个相同的元素加入同一个Set集合中，则添加操作失败，add()方法返回false，且新元素不会被加入。 3.List集合3.1.简介List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许使用重复元素，可以通过索引来访问指定位置的集合元素 。List集合默认按元素的添加顺序设置元素的索引，例如第一个添加的元素索引为0，第二个添加的元素索引为1…… List作为Collection接口的子接口，可以使用Collection接口里的全部方法。而且由于List是有序集合，因此List集合里增加了一些根据索引来操作集合元素的方法。 3.2.接口中定义的方法 void add(int index, Object element): 在列表的指定位置插入指定元素（可选操作）。 boolean addAll(int index, Collection&lt;? extends E&gt; c) : 将集合c 中的所有元素都插入到列表中的指定位置index处。 Object get(index): 返回列表中指定位置的元素。 int indexOf(Object o): 返回此列表中第一次出现的指定元素的索引；如果此列表不包含该元素，则返回 -1。 int lastIndexOf(Object o): 返回此列表中最后出现的指定元素的索引；如果列表不包含此元素，则返回 -1。 Object remove(int index): 移除列表中指定位置的元素。 Object set(int index, Object element): 用指定元素替换列表中指定位置的元素。 List subList(int fromIndex, int toIndex): 返回列表中指定的 fromIndex（包括 ）和 toIndex（不包括）之间的所有集合元素组成的子集。 Object[] toArray(): 返回按适当顺序包含列表中的所有元素的数组（从第一个元素到最后一个元素）。 除此之外，Java 8还为List接口添加了如下两个默认方法。 void replaceAll(UnaryOperator operator): 根据operator指定的计算规则重新设置List集合的所有元素。 void sort(Comparator c): 根据Comparator参数对List集合的元素排序。 4.Queue集合4.1.简介Queue用户模拟队列这种数据结构，队列通常是指“先进先出”(FIFO，first-in-first-out)的容器。队列的头部是在队列中存放时间最长的元素，队列的尾部是保存在队列中存放时间最短的元素。新元素插入（offer）到队列的尾部，访问元素（poll）操作会返回队列头部的元素。通常，队列不允许随机访问队列中的元素。 4.2.接口中定义的方法 三、Map集合1.简介Map用户保存具有映射关系的数据，因此Map集合里保存着两组数，一组值用户保存Map里的key,另一组值用户保存Map里的value，key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较总是返回false。 如下图所描述，key和value之间存在单向一对一关系，即通过指定的key,总能找到唯一的、确定的value。从Map中取出数据时，只要给出指定的key，就可以取出对应的value。 2.Map集合与Set集合、List集合的关系①.与Set集合的关系 如果 把Map里的所有key放在一起看，它们就组成了一个Set集合（所有的key没有顺序，key与key之间不能重复），实际上Map确实包含了一个keySet()方法，用户返回Map里所有key组成的Set集合。 ②.与List集合的关系 如果把Map里的所有value放在一起来看，它们又非常类似于一个List：元素与元素之间可以重复，每个元素可以根据索引来查找，只是Map中索引不再使用整数值，而是以另外一个对象作为索引。 3.接口中定义的方法 Map中还包括一个内部类Entry，该类封装了一个key-value对。Entry包含如下三个方法： Map集合最典型的用法就是成对地添加、删除key-value对，然后就是判断该Map中是否包含指定key，是否包含指定value，也可以通过Map提供的keySet()方法获取所有key组成的集合，然后使用foreach循环来遍历Map的所有key，根据key即可遍历所有的value。下面程序代码示范Map的一些基本功能： 1234567891011121314151617181920212223242526public class MapTest &#123; public static void main(String[] args)&#123; Day day1 = new Day(1, 2, 3); Day day2 = new Day(2, 3, 4); Map&lt;String,Day&gt; map = new HashMap&lt;String,Day&gt;(); //成对放入key-value对 map.put("第一个", day1); map.put("第二个", day2); //判断是否包含指定的key System.out.println(map.containsKey("第一个")); //判断是否包含指定的value System.out.println(map.containsValue(day1)); //循环遍历 //1.获得Map中所有key组成的set集合 Set&lt;String&gt; keySet = map.keySet(); //2.使用foreach进行遍历 for (String key : keySet) &#123; //根据key获得指定的value System.out.println(map.get(key)); &#125; //根据key来移除key-value对 map.remove("第一个"); System.out.println(map); &#125;&#125; 输出结果： true true Day [hour=2, minute=3, second=4] Day [hour=1, minute=2, second=3] {第二个=Day [hour=2, minute=3, second=4]}]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解SS-SurFaceSystem]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SS-SurFaceSystem%2F</url>
    <content type="text"><![CDATA[深入理解 Surface系统 http://gityuan.com/2017/02/11/surface_flinger/ http://gityuan.com/2017/02/18/surface_flinger_2/ Surface系统的任督二脉(应用程序和Surface的关系 &amp; Surface和SurfaceFlinger之间的关系) 如果没有创建Activity，那么onCreate和onDestroy就没有任何意义，可这个Activity究竟是在哪里创建的？。 第4章中的“Zygote分裂”一节已讲过，Zygote在响应请求后会fork一个子进程，这个子进程是App对应的进程，它的入口函数是ActivityThread类的main函数。ActivityThread类中有一个handleLaunchActivity函数，它就是创建Activity的地方。 Window和WindowManger的家族图谱 根据上图，可得出以下结论： Activity的mWindow成员变量其真实类型是PhoneWindow，而mWindowManager成员变量的真实类型是LocalWindowManager。 LocalWindowManager和WindowManagerImpl都实现了WindowManager接口。这里采用的是Proxy模式，表明LocalWindowManager将把它的工作委托WindowManagerImpl来完成。 一个Activity中的UI组件 ViewRoot和WMS的关系 总结一图中的知识点： ViewRoot通过IWindowSession和WMS进程进行跨进程通信。IWindowSession定义在IWindowSession.aidl文件中。这个文件在编译时由aidl工具处理，最后会生成类似于Native Binder中Bn端和Bp端的代码，后文会介绍它。 ViewRoot内部有一个W类型的对象，它也是一个基于Binder通信的类，W是IWindow的Bn端，用于响应请求。IWindow定义在另一个aidl文件IWindow.aidl中。 为什么需要这两个特殊的类呢？简单介绍一下： 首先，来看IWindowSession.aidl对自己的描述： System private per-application interface to the window manager：也就是说每个App进程都会和WMS建立一个IWindowSession会话。这个会话被App进程用于和WMS通信。后面会介绍它的requestLayout函数。 再看对IWindow.adil的描述： API back to a client window that the Window Manager uses to informit of interesting things happening：这句话的大意是IWindow是WMS用来做事件通知的。每当发生一些事情时，WMS就会把这些事告诉某个IWindow。可以把IWindow想象成一个回调函数。 Activity总结不得不承认的是前面几节的内容很多也很繁杂，为了让后面分析的过程更流畅轻松一些，所以我们必须要总结一下。关于Activity的创建和显示，前面几节的信息可提炼成如下几条： Activity的顶层View是DecorView，而我们在onCreate函数中通过setContentView设置的View只不过是这个DecorView中的一部分罢了。DecorView是一个FrameLayout类型的ViewGroup。 Activity和UI有关，它包含一个Window（真实类型是PhoneWindow）和一个WindowManager（真实类型是LocalWindowManager）对象。这两个对象将控制整个Activity的显示。 LocalWindowManager使用了WindowManagerImpl做为最终的处理对象（Proxy模式），这个WindowManagerImpl中有一个ViewRoot对象。 ViewRoot实现了ViewParent接口，它有两个重要的成员变量，一个是mView，它指向Activity顶层UI单元的DecorView，另外有一个mSurface，这个Surface包含了一个Canvas（画布）。除此之外，ViewRoot还通过Binder系统和WindowManagerService进行了跨进程交互。 ViewRoot能处理Handler的消息，Activity的显示就是由ViewRoot在它的performTraversals函数中完成的。 整个Activity的绘图流程就是从mSurface中lock一块Canvas，然后交给mView去自由发挥画画的才能，最后unlockCanvasAndPost释放这块Canvas。 这里和显示有关的就是最后三条了，其中最重要的内容都和Surface相关，既然mSurface是ViewRoot的本地变量，那就直接去看Surface。上面的代码分析一路走下来，真是比较流畅，波澜不惊，可事实果真如此吗？ 复杂的Surface创建流程 Surface的精简流程图 SurfaceFlinger工作线程的流程总结 SharedBuffer家族使用流程]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
        <tag>SurfaceSystem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解SS-SystemServer]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3SS-SystemServer%2F</url>
    <content type="text"><![CDATA[深入理解 SystemServer http://gityuan.com/2016/02/14/android-system-server/ http://gityuan.com/2016/02/20/android-system-server-2/ 概述SystemServer是什么？它可是Android Java世界的两大支柱之一。另外一个支柱是专门负责孵化Java进程的Zygote。这两大支柱倒了任何一根，都会导致Android Java世界的崩溃（所有由Zygote孵化的Java进程都会被销毁。SystemServer就是由Zygote孵化而来）。崩溃之后，幸好Linux系统中的天字号进程init会重新启动它们以重建Java世界。[①]SystemServer正如其名，和系统服务有着重要关系。Android系统中几乎所有的核心Service都在这个进程中，如ActivityManagerService、PowerManagerService和WindowManagerService等。那么，作为这些服务的大本营，SystemServer会是什么样的呢？ SystemServer是由Zygote孵化而来的一个进程，通过ps命令，可知其进程名为system_server。 启动流程SystemServer的在Android体系中所处的地位，SystemServer由Zygote fork生成的，进程名为system_server，该进程承载着framework的核心服务。 Android系统启动-zygote篇中讲到Zygote启动过程中会调用startSystemServer()，可知startSystemServer()函数是system_server启动流程的起点， 启动流程图如下： 上图前4步骤（即颜色为紫色的流程）运行在是Zygote进程，从第5步（即颜色为蓝色的流程）ZygoteInit.handleSystemServerProcess开始是运行在新创建的system_server，这是fork机制实现的（fork会返回2次）。 当system_server进程创建失败时，将会重启zygote进程。这里需要注意，对于Android 5.0以上系统，有两个zygote进程，分别是zygote、zygote64两个进程，system_server的父进程，一般来说64位系统其父进程是zygote64进程 当kill system_server进程后，只重启zygote64和system_server，不重启zygote; 当kill zygote64进程后，只重启zygote64和system_server，也不重启zygote； 当kill zygote进程，则重启zygote、zygote64以及system_server。 服务启动阶段SystemServiceManager的startBootPhase()贯穿system_server进程的整个启动过程： 服务类别system_server进程，从源码角度划分为引导服务、核心服务、其他服务3类。 以下这些系统服务的注册过程, 见Android系统服务的注册方式 引导服务(7个)：ActivityManagerService、PowerManagerService、LightsService、DisplayManagerService、PackageManagerService、UserManagerService、SensorService； 核心服务(3个)：BatteryService、UsageStatsService、WebViewUpdateService； 其他服务(70个+)：AlarmManagerService、VibratorService等。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
        <tag>SystemServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解PMS-PowerManagerService]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PMS-PowerManagerService%2F</url>
    <content type="text"><![CDATA[深入理解 PowerManagerService https://www.cnblogs.com/jamboo/articles/6003835.html 移动设备的电量主要由两种元件消耗：CPU和显示屏，因此设法降低这两种元件的耗电量就是电源管理的关键，为移动设备设计的CPU大多有两种工作频率，为了省电，大部分时间内cpu都工作在降低频率下，只有进行密集计算时，如视频解码才会切换到高频状态，而显示屏省电的方法是尽量减少亮屏时间，但是显示屏的开关和应用有很大的关系，因此系统中需要有一套机制来控制显示屏的开关和亮度，这也是电源管理的主要工作。 电源管理架构Android的电源管理主要是通过wakelock机制来管理系统的状态，整个android电源管理，可以分为四个层次：应用接口层（PowerManager.java）,Framework层（PowerManagerService.java）,HAL层（Power.c），和内核层（kernel/Power）。 应用接口层:PowerManager中开放给应用一系列接口，应用可以调用PM的接口申请wakelock，唤醒系统，使系统进入睡眠等操作； Framework层：应用调用PowerManager开放的接口，来对系统进行一些列的操作是在PowerManagerService中完成的，PowerManagerService计算系统中和Power相关的计算，是整个电源管理的决策系统。同时协调Power如何与系统其它模块的交互，比如亮屏，暗屏，系统睡眠，唤醒等等。 HAL层：该层只有一个power.c文件，该文件通过上层传下来的参数，向/sys/power/wake_lock或者/sys/power/wake_unlock文件节点写数据来与kernel进行通信，主要功能是申请/释放锁，维持屏幕亮灭 Kernel层：内核层实现电源管理的方案主要包含三个部分： Kernel/power/：实现了系统电源管理框架机制。 Arch/arm(ormips or powerpc)/mach-XXX/pm.c：实现对特定板的处理器电源管理。 drivers/power：是设备电源管理的基础框架，为驱动提供了电源管理接口。 Android电源管理框架如下图： PowerManagerServcie是android系统电源管理的核心服务，它在Framework层建立起一个策略控制方案，向下决策HAL层以及kernel层来控制设备待机状态，控制显示屏，背光灯，距离传感器，光线传感器等硬件设备的状态。向上提供给应用程序相应的操作接口，比如听音乐时持续保持系统唤醒，应用通知来临唤醒手机屏幕等场景 PowerManagerServcie的启动初始化过程如下：]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
        <tag>PowerManagerService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解PMS-PackageManagerService]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PKMS-PackageManagerService%2F</url>
    <content type="text"><![CDATA[深入理解 PackageManagerService http://gityuan.com/2016/11/06/packagemanager/ 一.概述PackageManagerService(简称PKMS)，是Android系统中核心服务之一，管理着所有跟package相关的工作，常见的比如安装、卸载应用。 PKMS服务也是通过binder进行通信，IPackageManager.aidl由工具转换后自动生成binder的服务端IPackageManager.Stub和客户端IPackageManager.Stub.Proxy，具体关系如图： Binder服务端：PackageManagerService继承于IPackageManager.Stub； Binder客户端：ApplicationPackageManager(简称APM)的成员变量mPM继承于IPackageManager.Stub.Proxy; 本身APM是继承于PackageManager对象。Android系统启动过程中，一路启动到SystemServer后，便可以启动framework的各大服务，本文将介绍PKMS的启动过程。 PKMS初始化过程，分为5个阶段： PMS_START阶段： 创建Settings对象； 将6类shareUserId到mSettings； 初始化SystemConfig； 创建名为“PackageManager”的handler线程mHandlerThread; 创建UserManagerService多用户管理服务； 通过解析4大目录中的xmL文件构造共享mSharedLibraries； PMS_SYSTEM_SCAN_START阶段： mSharedLibraries共享库中的文件执行dexopt操作； system/framework目录中满足条件的apk或jar文件执行dexopt操作； 扫描系统apk; PMS_DATA_SCAN_START阶段： 扫描/data/app目录下的apk; 扫描/data/app-private目录下的apk; PMS_SCAN_END阶段： 将上述信息写回/data/system/packages.xml; PMS_READY阶段： 创建服务PackageInstallerService；三、操作PKMS 第一阶段工作总结在继续征程前，先总结一下PKMS构造函数在第一阶段的工作，千言万语汇成一句话：扫描并解析XML文件，将其中的信息保存到特定的数据结构中。 第二阶段工作总结PKMS构造函数第二阶段的工作任务非常繁重，要创建比较多的对象，所以它是一个耗时耗内存的操作。在工作中，我们一直想优化该流程以加快启动速度，例如延时扫描不重要的APK，或者保存Package信息到文件中，然后在启动时从文件中恢复这些信息以减少APK文件读取并解析XML的工作量。但是一直没有一个比较完满的解决方案，原因有很多。比如APK之间有着比较微妙的依赖关系，因此到底延时扫描哪些APK，尚不能确定。另外，笔者感到比较疑惑的一个问题是：对于多核CPU架构，PKMS可以启动多个线程以扫描不同的目录 APK 安装流程总结没想到APK的安装流程竟然如此复杂，其目的无非是让APK中的私人财产公有化。相比之下，在PKMS构造函数中进行公有化改造就非常简单。另外，如果考虑安装到SD卡的处理流程，那么APK的安装将会更加复杂。 这里要总结APK安装过程中的几个重要步骤，如图所示。 安装APK到内部存储空间这一工作流程涉及的主要对象包括：PKMS、DCS、InstallParams和FileInstallArgs。 此工作流程中每个对象涉及到的关键函数。 对象之间的调用通过虚线表达，调用顺序通过①②③等标明。 包管理服务启动时主要做的工作大致有如下几方面: 建立 java 层的 installer 与 c 层的 installd 的 socket 联接,使得在上层的 install,remove,dexopt等功能最终由 installd 在底层实现 建 立 PackageHandler 消 息 循 环 , 用 于 处 理 外 部 的 apk 安 装 请 求 消 息 , 如 adbinstall,packageinstaller 安装 apk 时会发送消息 解析/system/etc/permission 下 xml 文件(framework/base/data/etc/),包括 platform.xml 和系统支持的各种硬件模块的 feature.主要工作: (1) 建立底层 user ids 和 group ids 同上层 permissions 之间的映射;可以指定一个权限与几个组 ID 对应。当一个 APK 被授予这个权限时,它也同时属于这几个组。 (2) 给一些底层用户分配权限,如给 shell 授予各种 permission 权限;把一个权限赋予一个UID,当进程使用这个 UID 运行时,就具备了这个权限。 (3) library,系统增加的一些应用需要 link 的扩展 jar 库; (4) feature, 系 统 每 增 加 一 个 硬 件 , 都 要 添 加 相 应 的 feature. 将 解 析 结 果mSystemPermissions,mSharedLibraries,mSettings.mPermissions,mAvailableFeatures 等几个集合中供系统查询和权限配置使用。 检查/data/system/packages.xml 是否存在,这个文件是在解析 apk 时由writeLP()创建的,里面记录了系统的 permissions,以及每个 apk name,codePath,flags,ts,version,uesrid 等信息,这些信息主要通过 apk 的AndroidManifest.xml 解析获取,解析完 apk 后将更新信息写入这个文件并保存到 flash,下次开机直接从里面读取相关信息添加到内存相关列表中。当有 apk升级,安装或删除时会更新这个文件。 检查 BootClassPath,mSharedLibraries 及/system/framework 下的 jar是否需要 dexopt,需要的则通过 dexopt 进行优化 启动 AppDirObserver 线程监测/system/framework,/system/app,/data/app,/data/app-private 目录的事件,主要监听 add 和 remove 事件。对于目录监听底层通过inotify 机制实现,inotify 是一种文件系统的变化通知机制,如文件增加、删除等事件可以立刻让用户态得知,它为用户态监视文件系统的变化提供了强大的支持。当有 add event 时调用 scanPackageLI(File , int , int)处理;当有 remove event 时调用 removePackageLI()处理; 对于以上几个目录下的 apk 逐个解析,主要是解析每个 apk 的 AndroidMa-nifest.xml 文件,处理 asset/res 等资源文件,建立起每个 apk 的配置结构信息,并将每个 apk 的配置信息添加到全局列表进行管理。调用 installer.install()进行安装工作,检查 apk 里的 dex 文件是否需要再优化,如果需要优化则通过辅助工具 dexopt 进行优化处理;将解析出的 componet 添加到 pkg 的对应列表里;对 apk 进行签名和证书校验,进行完整性验证。 将解析的每个 apk 的信息保存到 packages.xml 和 packages.list 文件里,packages.list 记录了如下数据:pkgName,userId,debugFlag,dataPath(包的数据路径) scanDirLI 流程分析:]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
        <tag>PackageManagerService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解ViewRoot]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ViewRoot%2F</url>
    <content type="text"><![CDATA[深入理解控件(ViewRoot)系统 WindowManager的结构体系: ViewManager接口：WindowManager体系中最基本的接口。WindowManager继承自这个接口说明了WindowManager与ViewGroup本质上的一致性。 WindowManager接口：WindowManager接口继承自ViewManager接口的同时，根据窗口的一些特殊性增加了两个新的接口。getDefaultDisplay()用以得知这个WindowManager的实例会将窗口添加到哪个屏幕上去。而removeViewImmediate()则要求WindowManager必须在这个调用返回之前完成所有的销毁工作。 WindowManagerImpl类：WindowManager接口的实现者。它自身没有什么实际的逻辑，WindowManager所定义的接口都是交由WindowManagerGlobal完成的。但是它保存了两个重要的只读成员，它们分别指明了通过这个WindowManagerImpl实例所管理的窗口将被显示在哪个屏幕上，以及将会作为哪个窗口的子窗口。因此在一个进程中，WindowManagerImpl的实例可能有多个。 WindowManagerGlobal类：它没有继承上述任何一个接口，但它是WindowManager的最终实现者。它维护了当前进程中所有已经添加到系统中的窗口的信息。另外，在一个进程中仅有一个WindowManagerGlobal的实例。 在理清了WindowManager的结构体系后，便可以探讨WindowManager是如何完成窗口管理的。其管理方式体现在其对ViewManager的三个接口的实现上。为了简洁起见，我们将直接分析WindowManagerGlobal中的实现。 添加窗口的代码并不复杂。其中的关键点有： 父窗口修改新窗口的布局参数。可能修改的只有LayoutParams.token和LayoutParams.mTitle两个属性。mTitle属性不必赘述，仅用于调试。而token属性则值得一提。回顾一下第4章的内容，每一个新窗口必须通过LayoutParams.token向WMS出示相应的令牌才可以。在addView()函数中通过父窗口修改这个token属性的目的是为了减少开发者的负担。开发者不需要关心token到底应该被设置为什么值，只需将LayoutParams丢给一个WindowManager，剩下的事情就不用再关心了。父窗口修改token属性的原则是：如果新窗口的类型为子窗口(其类型大于等于LayoutParams.FIRST_SUB_WINDOW并小于等于LayoutParams.LAST_SUB_WINDOW)，则LayoutParams.token所持有的令牌为其父窗口的ID（也就是IWindow.asBinder()的返回值）。否则LayoutParams.token将被修改为父窗口所属的Activity的ID(也就是在第4章中所介绍的AppToken)，这对类型为TYPE_APPLICATION的新窗口来说非常重要。从这点来说，当且仅当新窗的类型为子窗口时addView()的parentWindow参数才是真正意义上的父窗口。这类子窗口有上下文菜单、弹出式菜单以及游标等等，在WMS中，这些窗口对应的WindowState所保存的mAttachedWindow既是parentWindow所对应的WindowState。然而另外还有一些窗口，如对话框窗口，类型为TYPE_APPLICATION， 并不属于子窗口，但需要AppToken作为其令牌，为此parentWindow将自己的AppToken赋予了新窗口的的LayoutParams.token中。此时parentWindow便并不是严格意义上的父窗口了。 为新窗口创建一个ViewRootImpl对象。顾名思义，ViewRootImpl实现了一个控件树的根。它负责与WMS进行直接的通讯，负责管理Surface，负责触发控件的测量与布局，负责触发控件的绘制，同时也是输入事件的中转站。总之，ViewRootImpl是整个控件系统正常运转的动力所在，无疑是本章最关键的一个组件。 将控件、布局参数以及新建的ViewRootImpl以相同的索引值添加到三个对应的数组mViews、mParams以及mRoots中，以供之后的查询之需。控件、布局参数以及ViewRootImpl三者共同组成了客户端的一个窗口。或者说，在控件系统中的窗口就是控件、布局参数与ViewRootImpl对象的一个三元组。 注意 笔者并不认同将这个三元组分别存储在三个数组中的设计。如果创建一个WindowRecord类来统一保存这个三元组将可以省去很多麻烦。 另外，mViews、mParams以及mRoots这三个数组的容量是随着当前进程中的窗口数量的变化而变化的。因此在addView()以及随后的removeView()中都伴随着数组的新建、拷贝等操作。鉴于一个进程所添加的窗口数量不会太多，而且也不会很频繁，所以这些时间开销是可以接受的。不过笔者仍然认为相对于数组，ArrayList或CopyOnWriteArrayList是更好的选择。 调用ViewRootImpl.setView()函数，将控件交给ViewRootImpl进行托管。这个动作将使得ViewRootImpl向WMS添加窗口、获取Surface以及重绘等一系列的操作。这一步是控件能够作为一个窗口显示在屏幕上的根本原因！ 总体来说，WindowManagerGlobal在通过父窗口调整了布局参数之后，将新建的ViewRootImpl、控件以及布局参数保存在自己的三个数组中，然后将控件交由新建的ViewRootImpl进行托管，从而完成了窗口的添加。WindowManagerGlobal管理窗口的原理如图所示。 WindowManagerGlobal的窗口管理: WindowManager的总结经过前文的分析，相信读者对WindowManager的工作原理有了深入的认识。 鉴于窗口布局和控件布局的一致性，WindowManager继承并实现了接口ViewManager。 使用者可以通过Context.getSystemService(Context.WINDOW_SERVICE)来获取一个WindowManager的实例。这个实例的真实类型是WindowManagerImpl。WindowManagerImpl一旦被创建就确定了通过它所创建的窗口所属哪块屏幕？哪个父窗口？ WindowManagerImpl除了保存了窗口所属的屏幕以及父窗口以外，没有任何实质性的工作。窗口的管理都交由WindowManagerGlobal的实例完成。 WindowManagerGlobal在一个进程中只有一个实例。 WindowManagerGlobal在3个数组中统一管理整个进程中的所有窗口的信息。这些信息包括控件、布局参数以及ViewRootImpl三个元素。 除了管理窗口的上述3个元素以外，WindowManagerGlobal将窗口的创建、销毁与布局更新等任务交付给了ViewRootImpl完成。 说明 在实际的应用开发过程中，有时会在logcat的输出中遇到有关WindowLeaked的异常输出。WindowLeaked异常发生与WindowManagerGlobal中，其原因是Activity在destroy之前没有销毁其附属窗口，如对话框、弹出菜单等。 如此看来，WindowManager的实现仍然是很轻量的。窗口的创建、销毁与布局更新都指向了一个组件：ViewRootImpl。 深入理解ViewRootImpl ViewRootImpl实现了ViewParent接口，作为整个控件树的根部，它是控件树正常运作的动力所在，控件的测量、布局、绘制以及输入事件的派发处理都由ViewRootImpl触发。另一方面，它是WindowManagerGlobal工作的实际实现者，因此它还需要负责与WMS交互通信以调整窗口的位置大小，以及对来自WMS的事件（如窗口尺寸改变等）作出相应的处理。 performTraversals()的工作阶段 performTraversals()是Android 源码中最庞大的方法之一，因此在正式探讨它的实现之前最好先将其划分为以下几个工作阶段作为指导。 预测量阶段。这是进入performTraversals()方法后的第一个阶段，它会对控件树进行第一次测量。测量结果可以通过mView. getMeasuredWidth()/Height()获得。在此阶段中将会计算出控件树为显示其内容所需的尺寸，即期望的窗口尺寸。在这个阶段中，View及其子类的onMeasure()方法将会沿着控件树依次得到回调。 布局窗口阶段。根据预测量的结果，通过IWindowSession.relayout()方法向WMS请求调整窗口的尺寸等属性，这将引发WMS对窗口进行重新布局，并将布局结果返回给ViewRootImpl。 最终测量阶段。预测量的结果是控件树所期望的窗口尺寸。然而由于在WMS中影响窗口布局的因素很多(参考第4章)，WMS不一定会将窗口准确地布局为控件树所要求的尺寸，而迫于WMS作为系统服务的强势地位，控件树不得不接受WMS的布局结果。因此在这一阶段，performTraversals()将以窗口的实际尺寸对控件进行最终测量。在这个阶段中，View及其子类的onMeasure()方法将会沿着控件树依次被回调。 布局控件树阶段。完成最终测量之后便可以对控件树进行布局了。测量确定的是控件的尺寸，而布局则是确定控件的位置。在这个阶段中，View及其子类的onLayout()方法将会被回调。 绘制阶段。这是performTraversals()的最终阶段。确定了控件的位置与尺寸后，便可以对控件树进行绘制了。在这个阶段中，View及其子类的onDraw()方法将会被回调。 说明 很多文章都倾向于将performTraversals()的工作划分为测量、布局与绘制三个阶段。然而笔者认为如此划分隐藏了WMS在这个过程中的地位，并且没能体现出控件树对窗口尺寸的期望、WMS对窗口尺寸做最终的确定，最后以WMS给出的结果为准再次进行测量的协商过程。而这个协商过程充分体现了ViewRootImpl作为WMS与控件树的中间人的角色。 MeasureSpec.UNSPECIFIED (0)：表示控件在进行测量时，可以无视SPEC_SIZE的值。控件可以是它所期望的任意尺寸。 MeasureSpec.EXACTLY (1)：表示子控件必须为SPEC_SIZE所制定的尺寸。当控件的LayoutParams.width/height为一确定值，或者是MATCH_PARENT时，对应的MeasureSpec参数会使用这个SPEC_MODE。 MeasureSpec.AT_MOST (2)：表示子控件可以是它所期望的尺寸，但是不得大于SPEC_SIZE。当控件的LayoutParams.width/height为WRAP_CONTENT时，对应的MeasureSpec参数会使用这个SPEC_MODE。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ViewRoot</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解WMS-WindowManagerService]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3WMS-WindowManagerService%2F</url>
    <content type="text"><![CDATA[深入理解 WindowManagerService https://www.jianshu.com/p/6b31e650b347 窗口（Window）是什么。Android系统中的窗口是屏幕上的一块用于绘制各种UI元素并可以响应应用户输入的一个矩形区域。从原理上来讲，窗口的概念是独自占有一个Surface实例的显示区域。例如Dialog、Activity的界面、壁纸、状态栏以及Toast等都是窗口。《卷I》第8章曾详细介绍了一个Activity通过Surface来显示自己的过程： Surface是一块画布，应用可以随心所欲地通过Canvas或者OpenGL在其上作画。 然后通过SurfaceFlinger将多块Surface的内容按照特定的顺序（Z-order）进行混合并输出到FrameBuffer，从而将Android“漂亮的脸蛋”显示给用户。 既然每个窗口都有一块Surface供自己涂鸦，必然需要一个角色对所有窗口的Surface进行协调管理。于是，WMS便应运而生。WMS为所有窗口分配Surface，掌管Surface的显示顺序（Z-order）以及位置尺寸，控制窗口动画，并且还是输入系统的一重要的中转站。说明一个窗口拥有显示和响应用户输入这两层含义 总结在客户端创建一个窗口的步骤： 获取IWindowSession和WMS实例。客户端可以通过IWindowSession向WMS发送请求。 创建并初始化WindowManager.LayoutParams。注意这里是WindowManager下的LayoutParams，它继承自ViewGroup.LayoutParams类，并扩展了一些窗口相关的属性。其中最重要的是type属性。这个属性描述了窗口的类型，而窗口类型正是WMS对多个窗口进行ZOrder排序的依据。 向WMS添加一个窗口令牌（WindowToken）。本章后续将分析窗口令牌的概念，目前读者只要知道，窗口令牌描述了一个显示行为，并且WMS要求每一个窗口必须隶属于某一个显示令牌。 向WMS添加一个窗口。必须在LayoutParams中指明此窗口所隶属于的窗口令牌，否则在某些情况下添加操作会失败。在SampleWindow中，不设置令牌也可成功完成添加操作，因为窗口的类型被设为TYPE_SYSTEM_ALERT，它是系统窗口的一种。而对于系统窗口，WMS会自动为其创建显示令牌，故无需客户端操心。此话题将会在后文进行更具体的讨论。 向WMS申请对窗口进行重新布局（relayout）。所谓的重新布局，就是根据窗口新的属性去调整其Surface相关的属性，或者重新创建一个Surface（例如窗口尺寸变化导致之前的Surface不满足要求）。向WMS添加一个窗口之后，其仅仅是将它在WMS中进行了注册而已。只有经过重新布局之后，窗口才拥有WMS为其分配的画布。有了画布，窗口之后就可以随时进行绘制工作了。而窗口的绘制过程如下： 通过Surface.lock()函数获取可以在其上作画的Canvas实例。 使用Canvas实例进行作画。 通过Surface.unlockCanvasAndPost()函数提交绘制结果。 Android显示系统的三个层次 在图中： 第一个层次是UI框架层，其工作为在Surface上绘制UI元素以及响应输入事件。 第二个层次为WMS，其主要工作在于管理Surface的分配、层级顺序等。 第三层为SurfaceFlinger，负责将多个Surface混合并输出。 Android中的窗口概念：屏幕上一块用于绘制各种UI元素并可以响应用户输入的一块矩形区域。从原理上来看，窗口的概念是独自占有一个Surface实例的显示区域。如Dialog、Activity的界面、壁纸、状态栏以及Toast等都是窗口。上述对窗口的概念性描述，提取出来主要有以下几点信息： 用于绘制UI元素 响应用户输入 独自占有一个surface实例 Surface是一块画布，应用通过canvas或者openGL在上面作画作画后通过SurfaceFlinger将多块Surface的内容按照Z-order进行混合并输出到FrameBuffer，从而将Android的页面显示给用户。每个窗口都有一块Surface用于显示自己的ui，必然需要一个角色对窗口进行统一管理，这个时候，WMS应运而生。WMS为所有窗口分配Surface，掌管z-order以及位置、尺寸、窗口的进场出场动画，并且还是输入系统的中转站。本文的分析角度： 布局系统：计算管理窗口的位置和层次动画系统：根据布局系统的计算渲染窗口动画一个窗口的创建流程大概如下： 客户端通过WindowManagerGlobal获取IWindowSession，通过IWindowSession来向WMS发起添加请求。 初始化WindowManager.LayoutParam，指定响应的type，当type大于System级别的时候，不需要token，WMS会创建一个token，而type小于system级别的窗口，是必须要求有token带过来给WMS的。WMS根据这个type来对窗口的z-order进行排序。 向was申请relayout，所谓重新布局，是根据窗口新的属性去调整其Surface的相关属性，或者重新创建一个Surface。向wms添加一个窗口，仅仅是将它在wms中进行注册。只有经过了relayout后，窗口才拥有了wms为其分配的画布，有了画布，窗口才能进行绘制工作。 之后，窗口的绘制过程如下： 通过surface.lock()函数获取可以在surface上作画的canvas 使用canvas进行绘图 通过unlockCanvasAndPost提交绘制结果 说到底,Window的本质其实就是一块Surface画布.于是,根据对Surface的操作类型可以将Android的显示系统分为3个层次。 UI框架层，负责View空间的布局、绘制、事件分发、响应 WMS管理窗口Surface的布局与次序 SurfaceFlinger 将WMS维护的窗口Surface按照一定的次序混合后显示到屏幕上。 理解WindowToken WindowToken的意义为了搞清楚WindowToken的作用是什么，看一下其位于WindowToken.java中的定义。虽然它没有定义任何函数，但其成员变量的意义却很重要。 WindowToken将属于同一个应用组件的窗口组织在了一起。所谓的应用组件可以是Activity、InputMethod、Wallpaper以及Dream。在WMS对窗口的管理过程中，用WindowToken指代一个应用组件。例如在进行窗口ZOrder排序时，属于同一个WindowToken的窗口会被安排在一起，而且在其中定义的一些属性将会影响所有属于此WindowToken的窗口。这些都表明了属于同一个WindowToken的窗口之间的紧密联系。 WindowToken具有令牌的作用，是对应用组件的行为进行规范管理的一个手段。WindowToken由应用组件或其管理者负责向WMS声明并持有。应用组件在需要新的窗口时，必须提供WindowToken以表明自己的身份，并且窗口的类型必须与所持有的WindowToken的类型一致。从上面的代码可以看到，在创建系统类型的窗口时不需要提供一个有效的Token，WMS会隐式地为其声明一个WindowToken，看起来谁都可以添加个系统级的窗口。难道Android为了内部使用方便而置安全于不顾吗？非也，addWindow()函数一开始的mPolicy.checkAddPermission()的目的就是如此。它要求客户端必须拥有SYSTEM_ALERT_WINDOW或INTERNAL_SYSTEM_WINDOW权限才能创建系统类型的窗口。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
        <tag>WindowManagerService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解AMS-ActivityManagerService]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AMS-ActivityManagerService%2F</url>
    <content type="text"><![CDATA[深入理解 ActivityManagerService 概述相信绝大部分读者对本书提到的ActivityManagerService（以后简称AMS）都有所耳闻。AMS是Android中最核心的服务，主要负责系统中四大组件的启动、切换、调度及应用进程的管理和调度等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。AMS是本书碰到的第一块难啃的骨头[①]，涉及的知识点较多。为了帮助读者更好地理解AMS，本章将带领读者按五条不同的线来分析它。 第一条线：同其他服务一样，将分析SystemServer中AMS的调用轨迹。 第二条线：以am命令启动一个Activity为例，分析应用进程的创建、Activity的启动，以及它们和AMS之间的交互等知识。 第三条线和第四条线：分别以Broadcast和Service为例，分析AMS中Broadcast和Service的相关处理流程。 第五条线：以一个Crash的应用进程为出发点，分析AMS如何打理该应用进程的身后事。除了这五条线外，还将统一分析在这五条线中频繁出现的与AMS中应用进程的调度、内存管理等相关的知识。提示ContentProvider将放到下一章分析，不过本章将涉及和ContentProvider有关的知识点。先来看AMS的家族图谱: 由图可知： AMS由ActivityManagerNative（以后简称AMN）类派生，并实现Watchdog.Monitor和BatteryStatsImpl.BatteryCallback接口。而AMN由Binder派生，实现了IActivityManager接口。 客户端使用ActivityManager类。由于AMS是系统核心服务，很多API不能开放供客户端使用，所以设计者没有让ActivityManager直接加入AMS家族。在ActivityManager类内部通过调用AMN的getDefault函数得到一个ActivityManagerProxy对象，通过它可与AMS通信。 AMS由SystemServer的ServerThread线程创建; 1. 初识ActivityManagerService总结本节所分析的4个关键函数均较复杂，与之相关的知识点总结如下： AMS的main函数：创建AMS实例，其中最重要的工作是创建Android运行环境，得到一个ActivityThread和一个Context对象。 AMS的setSystemProcess函数：该函数注册AMS和meminfo等服务到ServiceManager中。另外，它为SystemServer创建了一个ProcessRecord对象。由于AMS是Java世界的进程管理及调度中心，要做到对Java进程一视同仁，尽管SystemServer贵为系统进程，此时也不得不将其并入AMS的管理范围内。 AMS的installSystemProviders：为SystemServer加载SettingsProvider。 AMS的systemReady：做系统启动完毕前最后一些扫尾工作。该函数调用完毕后，HomeActivity将呈现在用户面前。对AMS 调用轨迹分析是我们破解AMS的第一条线，希望读者反复阅读，以真正理解其中涉及的知识点，尤其是和Android运行环境及Context相关的知识。 2. startActivity总结本文详细startActivity的整个启动流程， 流程[2.1 ~2.4]:运行在调用者所在进程，比如从桌面启动Activity，则调用者所在进程为launcher进程，launcher进程利用ActivityManagerProxy作为Binder Client，进入system_server进程(AMS相应的Server端)。 流程[2.5 ~2.18]:运行在system_server系统进程，整个过程最为复杂、核心的过程，下面其中部分步骤： 流程[2.7]：会调用到resolveActivity()，借助PackageManager来查询系统中所有符合要求的Activity，当存在多个满足条件的Activity则会弹框让用户来选择; 流程[2.8]：创建ActivityRecord对象，并检查是否运行App切换，然后再处理mPendingActivityLaunches中的activity; 流程[2.9]：为Activity找到或创建新的Task对象，设置flags信息； 流程[2.13]：当没有处于非finishing状态的Activity，则直接回到桌面； 否则，当mResumedActivity不为空则执行startPausingLocked()暂停该activity;然后再进入startSpecificActivityLocked()环节; 流程[2.14]：当目标进程已存在则直接进入流程[2.17]，当进程不存在则创建进程，经过层层调用还是会进入流程[2.17]; 流程[2.17]：system_server进程利用的ATP(Binder Client)，经过Binder，程序接下来进入目标进程。 流程[2.19 ~2.18]:运行在目标进程，通过Handler消息机制，该进程中的Binder线程向主线程发送H.LAUNCH_ACTIVITY，最终会通过反射创建目标Activity，然后进入onCreate()生命周期。从另一个角度下图来概括： 启动流程： 点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求； system_server进程接收到请求后，向zygote进程发送创建进程的请求； Zygote进程fork出新的子进程，即App进程； App进程，通过Binder IPC向sytem_server进程发起attachApplication请求； system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求； App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息； 主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 startActivity后半程总结 startActivity总结Activity的启动就介绍到这里。这一路分析下来，相信读者也和笔者一样觉得此行绝不轻松。先回顾一下此次旅程： 行程的起点是am。am是Android中很重要的程序，读者务必要掌握它的用法。我们利用am start命令，发起本次目标Activity的启动请求。 接下来进入ActivityManagerService和ActivityStack这两个核心类。对于启动Activity来说，这段行程又可分细分为两个阶段：第一阶段的主要工作就是根据启动模式和启动标志找到或创建ActivityRecord及对应的TaskRecord；第二阶段工作就是处理Activity启动或切换相关的工作。 首先讨论了AMS直接创建目标进程并运行Activity的流程，其中涉及目标进程的创建，在目标进程中Android运行环境的初始化，目标Activity的创建以及触发onCreate、onStart及onResume等其生命周期中重要函数调用等相关知识点。 接着又讨论了AMS先pause当前Activity，然后再创建目标进程并运行Activity的流程。其中牵扯到两个应用进程和AMS的交互，其难度之大可见一斑。读者在阅读本节时，务必要区分此旅程中两个阶段工作的重点：其一是找到合适的ActivityRecord和TaskRecord；其二是调度相关进程进行Activity切换。在SDK文档中，介绍最为详细的是第一阶段中系统的处理策略，例如启动模式、启动标志的作用等。第二阶段工作其实是与Android组件调度相关的工作。SDK文档只是针对单个Activity进行生命周期方面的介绍。坦诚地说，这次旅程略过不少逻辑情况。原因有二，一方面受限于精力和篇幅，另方面是作为调度核心类，和AMS相关的代码及处理逻辑非常复杂，而且其间还夹杂了与WMS的交互逻辑，使复杂度更甚。再者，笔者个人感觉这部分代码绝谈不上高效、严谨和美观，甚至有些丑陋（在分析它们的过程中，远没有研究Audio、Surface时那种畅快淋漓的感觉）。此处列出几个供读者深入研究的点： 各种启动模式、启动标志的处理流程。 Configuration发生变化时Activity的处理，以及在Activity中对状态保存及恢复的处理流程。 Activity生命周期各个阶段的转换及相关处理。Android 2.3以后新增的与Fragment的生命周期相关的转换及处理。 3. 广播处理总结 4. startService流程图总结5.1 流程说明在整个startService过程，从进程角度看服务启动过程 Process A进程：是指调用startService命令所在的进程，也就是启动服务的发起端进程，比如点击桌面App图标，此处Process A便是Launcher所在进程。 system_server进程：系统进程，是java framework框架的核心载体，里面运行了大量的系统服务，比如这里提供ApplicationThreadProxy（简称ATP），ActivityManagerService（简称AMS），这个两个服务都运行在system_server进程的不同线程中，由于ATP和AMS都是基于IBinder接口，都是binder线程，binder线程的创建与销毁都是由binder驱动来决定的，每个进程binder线程个数的上限为16。 Zygote进程：是由init进程孵化而来的，用于创建Java层进程的母体，所有的Java层进程都是由Zygote进程孵化而来； Remote Service进程：远程服务所在进程，是由Zygote进程孵化而来的用于运行Remote服务的进程。主线程主要负责Activity/Service等组件的生命周期以及UI相关操作都运行在这个线程； 另外，每个App进程中至少会有两个binder线程 ApplicationThread(简称AT)和ActivityManagerProxy（简称AMP），当然还有其他线程，这里不是重点就不提了。 图中涉及3种IPC通信方式：Binder、Socket以及Handler，在图中分别用3种不同的颜色来代表这3种通信方式。一般来说，同一进程内的线程间通信采用的是 Handler消息队列机制，不同进程间的通信采用的是binder机制，另外与Zygote进程通信采用的Socket。 启动流程： Process A进程采用Binder IPC向system_server进程发起startService请求； system_server进程接收到请求后，向zygote进程发送创建进程的请求； zygote进程fork出新的子进程Remote Service进程； Remote Service进程，通过Binder IPC向sytem_server进程发起attachApplication请求； system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向remote Service进程发送scheduleCreateService请求； Remote Service进程的binder线程在收到请求后，通过handler向主线程发送CREATE_SERVICE消息； 主线程在收到Message后，通过发射机制创建目标Service，并回调Service.onCreate()方法。到此，服务便正式启动完成。当创建的是本地服务或者服务所属进程已创建时，则无需经过上述步骤2、3，直接创建服务即可。 5. AMS中的进程管理前面曾反复提到，Android平台中很少能接触到进程的概念，取而代之的是有明确定义的四大组件。但是作为运行在Linux用户空间内的一个系统或框架，Android不仅不能脱离进程，反而要大力利用Linux OS提供的进程管理机制和手段，更好地为自己服务。作为Android平台中组件运行管理的核心服务，ActivityManagerService当仁不让地接手了这方面的工作。目前，AMS对进程的管理仅涉及两个方面： 调节进程的调度优先级和调度策略。 调节进程的OOM值。 6. App的Crash处理总结应用进程进行Crash处理的流程。 一.概述ActivityManagerService是Framework层的核心服务之一,ActivityManagerService是Binder的子类,它的功能主要以下三点: 四大组件的统一调度 进程管理 内存管理 三.ActivityManagerService的启动过程ActivityManagerService的启动是在systemserver进程的startBootstrapServices方法中启动的.SystemServiceManager.startService(ActivityManagerService.Lifecycle.class) 功能主要：创建ActivityManagerService.Lifecycle对象；调用Lifecycle.onStart()方法。 四.主要功能之一的四大组件的统一调度ActivityManagerService最主要的功能就是统一的管理者activity,service,broadcast,provider的创建,运行,关闭.我们在应用程序中启动acitivity,关闭acitiviy等操作最终都是要通过ams来统一管理的.这个过程非常的复杂,不是一下子可以讲的清楚的,我这里推荐老罗的博客来讲解四大组件的启动过程: Android应用程序内部启动Activity过程（startActivity）的源代码分析Android系统在新进程中启动自定义服务过程（startService）的原理分析Android应用程序注册广播接收器（registerReceiver）的过程分析Android应用程序发送广播（sendBroadcast）的过程分析Android应用程序组件Content Provider简要介绍和学习计划 五.主要功能之一的内存管理我们知道当一个进程中的acitiviy全部都关闭以后,这个空进程并不会立即就被杀死.而是要等到系统内存不够时才会杀死.但是实际上ActivityManagerService并不能够管理内存,android的内存管理是Linux内核中的内存管理模块和OOM进程一起管理的.Android进程在运行的时候,会通过Ams把每一个应用程序的oom_adj值告诉OOM进程,这个值的范围在-16-15,值越低说明越重要,越不会被杀死.当发生内存低的时候,Linux内核内存管理模块会通知OOm进程根据AMs提供的优先级强制退出值较高的进程.因此Ams在内存管理中只是扮演着一个提供进程oom_adj值的功能.真正的内存管理还是要调用OOM进程来完成.下面通过调用Activity的finish()方法来看看内存释放的情况. 当我们手动调用finish()方法或者按back键时都是会关闭activity的,,在调用finish的时候只是会先调用ams的finishActivityLocked方法将当前要关闭的acitiviy的finish状态设置为true,然后就会先去启动新的acitiviy,当新的acitiviy启动完成以后就会通过消息机制通知Ams,Ams在调用activityIdleInternalLocked方法来关闭之前的acitiviy.]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
        <tag>ActivityManagerService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Binder]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder%2F</url>
    <content type="text"><![CDATA[深入理解 Binder]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Zygote]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Zygote%2F</url>
    <content type="text"><![CDATA[深入理解 zygote 读者可能已经知道，Android系统存在着两个完全不同的世界： Java世界，Google放出的SDK主要就是针对这个世界的。在这个世界中运行的程序都是基于Dalvik虚拟机的Java程序。 Native世界，也就是用Native语言C或C++开发的程序，它们组成了Native世界。初次接触Android的人，可能会有几个疑问： Android是基于Linux内核构建的，它最早存在的肯定是Native世界，那么Java世界是什么时候创建的呢？ 我们都知道，程序运行时一定要有一个进程，但是我们在编写Activity、Service的时候却绝少接触到“进程”这一概念。当然这是Google有意为之，但这些Activity或Service却又不能脱离“进程”而存在。那么，这个“进程”是怎么创建和运行的呢？这是一个值得琢磨的问题。 在程序中，我们经常使用系统的Service，那么，这些Service在哪里呢？这些问题的答案都和我们本章的两位主人公zygote和system_server有关。zygote这个词的中文意思是“受精卵”，它和Android系统中的Java世界有着重要关系。而system_server则“人如其名”，系统中重要的service都驻留于Java中。zygote和system_server这两个进程分别是Java世界的半边天，任何一个进程的死亡，都会导致Java世界的崩溃，够厉害吧？ Zygote本身是一个Native的应用程序，和驱动、内核等均无关系。根据第3章对于init的介绍我们可以知道，Zygote是由init进程根据init.rc文件中的配置项而创建的。在分析它之前，我们有必要先简单介绍一下“zygote”这个名字的来历。zygote最初的名字叫“app_process”，这个名字是在Android.mk文件中被指定的，但app_process在运行过程中，通过Linux下的pctrl系统调用将自己的名字换成了“zygote”，所以我们通过ps命令看到的进程名是“zygote”。 ① 创建虚拟机② 注册JNI函数③通过JNI调用Java函数，注意调用的函数是main，所属的类是 com.android.internal.os.ZygoteInit，传递的参数是 “com.android.internal.os.ZygoteInit true”， 调用ZygoteInit的main函数后，Zygote便进入了Java世界！ 也就是说，Zygote是开创Android系统中Java世界的盘古。 SystemServer的调用流程 Zygote进程能够重启的地方: servicemanager进程被杀; (onresart) surfaceflinger进程被杀; (onresart) Zygote进程自己被杀; (oneshot=false) system_server进程被杀; (waitpid) 从App_main()开始，Zygote启动过程的函数调用类大致流程如下： zygote进程内加载了preload()方法中的所有资源，当需要fork新进程时，采用copy on write技术，如下： 大概也可以按照这个思路来理解zygote进程吧。 zygote进程启动时，将在内部启动Dalvik虚拟机，注册JNI函数，继而加载一些必要的系统资源和必要类等，然后进入到监听状态。 在后续的运作中，当其它系统模块希望创建新进程时，只需向zygote进程发出请求。zygote进程监听到该请求后，会相应地“分裂”出新的进程。 于是新创建出的进程，从一开始就具有了自己的Dalvik虚拟机以及一些必要的系统资源。这将减少每个进程启动消耗的时间。进一步来说，由于fork的copy-on-write策略，zygote的这种分裂方式还有可能减少系统整体内存的占用。 Zygote的总结1Zygote是创建Android系统中Java世界的盘古，它创建了第一个Java虚拟机，同时它又是女娲，它成功地繁殖了framework的核心system_server进程。做为Java语言的受益者，我们理应回顾一下Zygote创建Java世界的步骤： 第一天：创建AppRuntime对象，并调用它的start。此后的活动则由AppRuntime来控制。 第二天：调用startVm创建Java虚拟机，然后调用startReg来注册JNI函数。 第三天：通过JNI调用com.android.internal.os.ZygoteInit类的main函数，从此进入了Java世界。然而在这个世界刚开创的时候，什么东西都没有。 第四天：调用registerZygoteSocket。通过这个函数，它可以响应子孙后代的请求。同时Zygote调用preloadClasses和preloadResources，为Java世界添砖加瓦。 第五天：Zygote觉得自己工作压力太大，便通过调用startSystemServer分裂一个子进程system_server来为Java世界服务。 第六天：Zygote完成了Java世界的初创工作，它已经很满足了。下一步该做的就是调用runSelectLoopMode后，便沉沉地睡去了。 以后的日子：Zygote随时守护在我们的周围，当接收到子孙后代的请求时，它会随时醒来，为它们工作。如果支持中文编码的话，我一定要为Zygote取名为盘古_女娲。 Zygote总结2Zygote启动过程的调用流程图: 解析init.zygote.rc中的参数，创建AppRuntime并调用AppRuntime.start()方法； 调用AndroidRuntime的startVM()方法创建虚拟机，再调用startReg()注册JNI函数； 通过JNI方式调用ZygoteInit.main()，第一次进入Java世界； registerZygoteSocket()建立socket通道，zygote作为通信的服务端，用于响应客户端请求； preload()预加载通用类、drawable和color资源、openGL以及共享库以及WebView，用于提高app启动效率； zygote完毕大部分工作，接下来再通过startSystemServer()，fork得力帮手system_server进程，也是上层framework的运行载体。 zygote功成身退，调用runSelectLoop()，随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
        <tag>Zygote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Init]]></title>
    <url>%2F2018%2F06%2F08%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Init%2F</url>
    <content type="text"><![CDATA[深入理解 Init https://www.jianshu.com/p/88e3a64d3a3e http://blog.csdn.net/gaugamela/article/details/52133186 总结init是一个进程，确切地说，它是Linux系统中用户空间的第一个进程。由于Android是基于Linux内核的，所以init也是Android系统中用户空间的第一个进程，它的进程号是1。作为天字第一号的进程，init被赋予了很多极其重要的工作职责，本章将关注其中两个比较重要的职责： init进程负责创建系统中的几个关键进程，尤其是下一章要介绍的Zygote，它更是Java世界的开创者。那么，init进程是如何创建Zygote的呢？ Android系统有很多属性，于是init就提供了一个property service（属性服务）来管理它们。那么这个属性服务是怎么工作的呢？ 两方面： init进程负责创建系统中的几个关键进程，尤其是Zygote，它更是Java世界的开创者。 Android系统有很多属性，于是init就提供了一个propertyService（属性服务）来管理它们。 init的工作流程精简为以下四点： 解析两个配置文件，其中，将分析对init.rc文件的解析。 执行各个阶段的动作，创建Zygote的工作就是在其中的某个阶段完成的。 调用property_init初始化属性相关的资源，并且通过property_start_service启动属性服务。 init进入一个无限循环，并且等待一些事情的发生。重点关注init如何处理来自socket和来自属性服务器相关的事情。 服务重启：]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>读书笔记</tag>
        <tag>Init</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PopupWindow和Dialog区别]]></title>
    <url>%2F2018%2F06%2F08%2FPopupWindow%E5%92%8CDialog%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[从底部弹出的选择框 使用popupWindow完成:定义popupWindow类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788/** * 选择照片的PopupWindow * Created by chenlijin on 2016/4/12. */public class SelectPicPopupWindow extends PopupWindow implements View.OnTouchListener, View.OnKeyListener &#123; private Context mContext; private View rootView; public SelectPicPopupWindow(Context context) &#123; mContext = context; LayoutInflater inflater = LayoutInflater.from(context); rootView = inflater.inflate(R.layout.popupwindow_selectpic, null); setContentView(rootView); ButterKnife.bind(this, rootView); //设置高度和宽度。 this.setHeight(ViewGroup.LayoutParams.WRAP_CONTENT); this.setWidth(ViewGroup.LayoutParams.MATCH_PARENT); this.setFocusable(true); //设置动画效果 this.setAnimationStyle(R.style.mypopwindow_anim_style); //当单击Back键或者其他地方使其消失、需要设置这个属性。 rootView.setOnTouchListener(this); rootView.setOnKeyListener(this); rootView.setFocusable(true); rootView.setFocusableInTouchMode(true); //实例化一个ColorDrawable颜色为半透明 ColorDrawable dw = new ColorDrawable(0xb0000000); //设置SelectPicPopupWindow弹出窗体的背景 this.setBackgroundDrawable(dw); &#125; //点击外部popup消失 @Override public boolean onTouch(View v, MotionEvent event) &#123; int height = rootView.findViewById(R.id.linearlayout_window).getTop(); int y = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_UP) &#123; if (y &lt; height) &#123; dismiss(); &#125; &#125; return true; &#125; //点back键消失 @Override public boolean onKey(View v, int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK &amp;&amp; this.isShowing()) &#123; this.dismiss(); return true; &#125; return false; &#125; @OnClick(&#123;R.id.button_take_photo, R.id.button_select_pic, R.id.button_cancal&#125;) public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button_take_photo: listener.onClickTakePhoto(); this.dismiss(); break; case R.id.button_select_pic: listener.onClickSelectPic(); this.dismiss(); break; case R.id.button_cancal: this.dismiss(); break; &#125; &#125; private OnWindowItemClickListener listener; public void setOnWindowItemClickListener(OnWindowItemClickListener listener) &#123; this.listener = listener; &#125; public interface OnWindowItemClickListener &#123; void onClickTakePhoto(); void onClickSelectPic(); &#125;&#125; 自定义Style1234567&lt;style name="MyPopup" parent="android:style/Theme.Dialog"&gt; &lt;item name="android:windowFrame"&gt;@null&lt;/item&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;item name="android:windowBackground"&gt;@color/popup&lt;/item&gt; &lt;item name="android:windowIsFloating"&gt;true&lt;/item&gt; &lt;item name="android:windowContentOverlay"&gt;@null&lt;/item&gt; &lt;/style&gt; 定义进入和退出的动画:1234567891011121314151617181920212223进入:&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="200" android:fromYDelta="100.0%" android:toYDelta="0.0"/&gt;&lt;/set&gt;退出&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;translate android:duration="200" android:fromYDelta="0.0" android:toYDelta="100.0%"/&gt;&lt;/set&gt;动画的style&lt;style name="mypopwindow_anim_style"&gt; &lt;item name="android:windowEnterAnimation"&gt;@anim/popup_in&lt;/item&gt; &lt;!-- 指定显示的动画xml --&gt; &lt;item name="android:windowExitAnimation"&gt;@anim/popup_out&lt;/item&gt; &lt;!-- 指定消失的动画xml --&gt; &lt;/style&gt; 在指定的位置显示 12//显示窗口 window.showAtLocation(MainActivity.this.findViewById(R.id.main), Gravity.BOTTOM|Gravity.CENTER_HORIZONTAL, 0, 0); //设置layout在PopupWindow中显示的位置 使用Dialog完成:定义style123456789101112&lt;!--自定义布局的dialog--&gt; &lt;style name="MyDialog" parent="android:style/Theme.Dialog"&gt; &lt;!-- 背景颜色及透明程度 --&gt; &lt;item name="android:windowBackground"&gt;@android:color/transparent&lt;/item&gt; &lt;!-- 是否有标题 --&gt; &lt;item name="android:windowNoTitle"&gt;true&lt;/item&gt; &lt;!-- 是否浮现在activity之上,会造成macth_parent失效--&gt; &lt;item name="android:windowIsFloating"&gt;false&lt;/item&gt; &lt;!-- 是否模糊 --&gt; &lt;item name="android:backgroundDimEnabled"&gt;true&lt;/item&gt; &lt;item name="android:windowFrame"&gt;@null&lt;/item&gt; &lt;/style&gt; 动画: 和popupwindow一致自定义Dialog:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 选择图片对话框 * Created by chenlijin on 2016/4/12. */public class SelectPicDialog extends Dialog &#123; public SelectPicDialog(Context context, int themeResId) &#123; super(context, themeResId); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.dialog_select_pic); ButterKnife.bind(this); &#125; @OnClick(&#123;R.id.linearlayout_out,R.id.textview_take_photo, R.id.textview_select_photo, R.id.textview_cancal&#125;) public void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.textview_take_photo: if(listener!=null)&#123; listener.onClickTakePhoto(); &#125; this.cancel(); break; case R.id.textview_select_photo: if(listener!=null)&#123; listener.onClickSelectPic(); &#125; this.cancel(); break; case R.id.linearlayout_out: case R.id.textview_cancal: this.cancel(); break; &#125; &#125; private OnWindowItemClickListener listener; public void setOnWindowItemClickListener(OnWindowItemClickListener listener) &#123; this.listener = listener; &#125; public interface OnWindowItemClickListener &#123; void onClickTakePhoto(); void onClickSelectPic(); &#125;&#125; 在Activity中调用:1234567891011121314151617SelectPicDialog dialog = new SelectPicDialog(mContext,R.style.MyDialog); Window window = dialog.getWindow(); window.setGravity(Gravity.BOTTOM); //此处可以设置dialog显示的位置 window.setWindowAnimations(R.style.mypopwindow_anim_style); //添加动画 dialog.show(); dialog.setOnWindowItemClickListener(new SelectPicDialog.OnWindowItemClickListener()&#123; @Override public void onClickTakePhoto() &#123; startActivityForResult(createCameraIntent(), CREATE_CAMERA); //选择拍照 &#125; @Override public void onClickSelectPic() &#123; startActivityForResult(createPickIntent(), CREATE_PICK); //选择启用系统的选择图片 &#125; &#125;); 详细的区别（1）Popupwindow在显示之前一定要设置宽高，Dialog无此限制。 （2）Popupwindow默认不会响应物理键盘的back，除非显示设置了popup.setFocusable(true);而在点击back的时候，Dialog会消失。 （3）Popupwindow不会给页面其他的部分添加蒙层，而Dialog会。 （4）Popupwindow没有标题，Dialog默认有标题，可以通过dialog.requestWindowFeature(Window.FEATURE_NO_TITLE);取消标题 （5）二者显示的时候都要设置Gravity。如果不设置，Dialog默认是Gravity.CENTER。 （6）二者都有默认的背景，都可以通过setBackgroundDrawable(new ColorDrawable(android.R.color.transparent));去掉。 其中最本质的差别就是：AlertDialog是非阻塞式对话框：AlertDialog弹出时，后台还可以做事情；而PopupWindow是阻塞式对话框：PopupWindow弹出时，程序会等待，在PopupWindow退出前，程序一直等待，只有当我们调用了dismiss方法的后，PopupWindow退出，程序才会向下执行。这两种区别的表现是：AlertDialog弹出时，背景是黑色的，但是当我们点击背景，AlertDialog会消失，证明程序不仅响应AlertDialog的操作，还响应其他操作，其他程序没有被阻塞，这说明了AlertDialog是非阻塞式对话框；PopupWindow弹出时，背景没有什么变化，但是当我们点击背景的时候，程序没有响应，只允许我们操作PopupWindow，其他操作被阻塞。 注意： 这里讲的阻塞并非线程阻塞，而是阻塞了其他UI操作，详情见：PopupWindow的”阻塞”问题]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>PopupWindow</tag>
        <tag>Dialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk安装过程]]></title>
    <url>%2F2018%2F06%2F08%2FApk%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Apk安装的主要步骤:为了学习这个过程,真的是陷入了pms的源码很久,也看了很多前人的博文,才算是有了些思路,所以此处先把主要步骤列出来,后面再慢慢分析细节。 将apk文件复制到data/app目录 解析apk信息 dexopt操作 更新权限信息 完成安装,发送Intent.ACTION_PACKAGE_ADDED广播 下面将具体步骤列张图出来: 由图可见安装过程中流转的步骤还是比较多的,下面具体分析 1. 将apk文件copy至data/app目录1.1 installPackageAsUser123456789101112131415161718192021222324252627282930313233mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null); final int callingUid = Binder.getCallingUid(); ... ... if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) &#123; installFlags |= PackageManager.INSTALL_FROM_ADB; &#125; else &#123; // Caller holds INSTALL_PACKAGES permission, so we're less strict // about installerPackageName. installFlags &amp;= ~PackageManager.INSTALL_FROM_ADB; installFlags &amp;= ~PackageManager.INSTALL_ALL_USERS; &#125; UserHandle user; if ((installFlags &amp; PackageManager.INSTALL_ALL_USERS) != 0) &#123; user = UserHandle.ALL; &#125; else &#123; user = new UserHandle(userId); &#125; verificationParams.setInstallerUid(callingUid); final File originFile = new File(originPath); final OriginInfo origin = OriginInfo.fromUntrustedFile(originFile); final Message msg = mHandler.obtainMessage(INIT_COPY); msg.obj = new InstallParams(origin, observer, installFlags, installerPackageName, verificationParams, user, packageAbiOverride); mHandler.sendMessage(msg); 这个方法主要是判断安装来源,包括adb,shell,all_user,然后向PMS的mHandler发送INIT_COPY的消息,这个mHandler运行在一个HandlerThread中。 1.2 handleMessage(INIT_COPY)&amp;handleMessage(MCS_BOUND)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455case INIT_COPY:&#123; HandlerParams params = (HandlerParams) msg.obj; int idx = mPendingInstalls.size(); if (DEBUG_INSTALL) Slog.i(TAG, "init_copy idx=" + idx + ": " + params); // If a bind was already initiated we dont really // need to do anything. The pending install // will be processed later on. if (!mBound) &#123; // If this is the only one pending we might // have to bind to the service again. if (!connectToService()) &#123; Slog.e(TAG, "Failed to bind to media container service"); params.serviceError(); return; &#125; else &#123; // Once we bind to the service, the first // pending request will be processed. mPendingInstalls.add(idx, params); &#125; &#125; else &#123; mPendingInstalls.add(idx, params); // Already bound to the service. Just make // sure we trigger off processing the first request. if (idx == 0) &#123; mHandler.sendEmptyMessage(MCS_BOUND); &#125; &#125;&#125;case MCS_BOUND:&#123;...... HandlerParams params = mPendingInstalls.get(0); if (params != null) &#123; if (params.startCopy()) &#123; // We are done... look for more work or to // go idle. if (DEBUG_SD_INSTALL) Log.i(TAG, "Checking for more work or unbind..."); // Delete pending install if (mPendingInstalls.size() &gt; 0) &#123; mPendingInstalls.remove(0); &#125; if (mPendingInstalls.size() == 0) &#123; if (mBound) &#123; if (DEBUG_SD_INSTALL) Log.i(TAG, "Posting delayed MCS_UNBIND"); removeMessages(MCS_UNBIND); Message ubmsg = obtainMessage(MCS_UNBIND); // Unbind after a little delay, to avoid // continual thrashing. sendMessageDelayed(ubmsg, 10000); &#125;......&#125; INIT_COPY主要是确保DefaultContainerService已bound,DefaultContainerService是一个应用服务，具体负责实现APK等相关资源文件在内部或外部存储器上的存储工作。而MCS_BOUND中则执行了params.startCopy()这句,也是最关键的开始copy文件。 1.3 HandlerParams.startCopy12345678910111213141516171819202122final boolean startCopy() &#123; boolean res; try &#123; if (DEBUG_INSTALL) Slog.i(TAG, "startCopy " + mUser + ": " + this); if (++mRetries &gt; MAX_RETRIES) &#123; Slog.w(TAG, "Failed to invoke remote methods on default container service. Giving up"); mHandler.sendEmptyMessage(MCS_GIVE_UP); handleServiceError(); return false; &#125; else &#123; handleStartCopy(); res = true; &#125; &#125; catch (RemoteException e) &#123; if (DEBUG_INSTALL) Slog.i(TAG, "Posting install MCS_RECONNECT"); mHandler.sendEmptyMessage(MCS_RECONNECT); res = false; &#125; handleReturnCode(); return res; &#125; 该方法中除了检查重试次数外只是简单的调用了handleStartCopy()及handleReturnCode()方法. 1.4 handleStartCopy()这个方法内容非常多,下面只列出些核心部分 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public void handleStartCopy() throws RemoteException &#123; int ret = PackageManager.INSTALL_SUCCEEDED; ... ... final boolean onSd = (installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0; final boolean onInt = (installFlags &amp; PackageManager.INSTALL_INTERNAL) != 0; PackageInfoLite pkgLite = null; if (onInt &amp;&amp; onSd) &#123; // Check if both bits are set. Slog.w(TAG, "Conflicting flags specified for installing on both internal and external"); ret = PackageManager.INSTALL_FAILED_INVALID_INSTALL_LOCATION; &#125; else &#123; pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags, packageAbiOverride); /* * If we have too little free space, try to free cache * before giving up. */ if (!origin.staged &amp;&amp; pkgLite.recommendedInstallLocation == PackageHelper.RECOMMEND_FAILED_INSUFFICIENT_STORAGE) &#123; final StorageManager storage = StorageManager.from(mContext); final long lowThreshold = storage.getStorageLowBytes( Environment.getDataDirectory()); final long sizeBytes = mContainerService.calculateInstalledSize( origin.resolvedPath, isForwardLocked(), packageAbiOverride); if (mInstaller.freeCache(sizeBytes + lowThreshold) &gt;= 0) &#123; pkgLite = mContainerService.getMinimalPackageInfo(origin.resolvedPath, installFlags, packageAbiOverride); &#125; &#125; &#125; ... ... * No package verification is enabled, so immediately start * the remote call to initiate copy using temporary file. */ ret = args.copyApk(mContainerService, true); &#125; mRet = ret; &#125; handleStartCopy的核心就是copyApk,其他的都是些存储空间检查,权限检查等等安全校验 2 .解析apk信息完成apk copy到data/app目录的操作后,下一步就到了 handleReturnCode,这个方法又跳转到processPendingInstall()方法,下面先来看看processPendingInstall()方法: 2.1 processPendingInstall()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123; // Queue up an async operation since the package installation may take a little while. mHandler.post(new Runnable() &#123; public void run() &#123; mHandler.removeCallbacks(this); // Result object to be returned PackageInstalledInfo res = new PackageInstalledInfo(); res.returnCode = currentStatus; res.uid = -1; res.pkg = null; res.removedInfo = new PackageRemovedInfo(); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; args.doPreInstall(res.returnCode); synchronized (mInstallLock) &#123; installPackageLI(args, res); //1.安装 &#125; args.doPostInstall(res.returnCode, res.uid); &#125; // A restore should be performed at this point if (a) the install // succeeded, (b) the operation is not an update, and (c) the new // package has not opted out of backup participation. final boolean update = res.removedInfo.removedPackage != null; final int flags = (res.pkg == null) ? 0 : res.pkg.applicationInfo.flags; boolean doRestore = !update &amp;&amp; ((flags &amp; ApplicationInfo.FLAG_ALLOW_BACKUP) != 0); // Set up the post-install work request bookkeeping. This will be used // and cleaned up by the post-install event handling regardless of whether // there's a restore pass performed. Token values are &gt;= 1. int token; if (mNextInstallToken &lt; 0) mNextInstallToken = 1; token = mNextInstallToken++; PostInstallData data = new PostInstallData(args, res); mRunningInstalls.put(token, data); if (DEBUG_INSTALL) Log.v(TAG, "+ starting restore round-trip " + token); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123; // Pass responsibility to the Backup Manager. It will perform a // restore if appropriate, then pass responsibility back to the // Package Manager to run the post-install observer callbacks // and broadcasts. IBackupManager bm = IBackupManager.Stub.asInterface( ServiceManager.getService(Context.BACKUP_SERVICE)); if (bm != null) &#123; if (DEBUG_INSTALL) Log.v(TAG, "token " + token + " to BM for possible restore"); try &#123; bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token); //2.调用backup服务 &#125; catch (RemoteException e) &#123; // can't happen; the backup manager is local &#125; catch (Exception e) &#123; Slog.e(TAG, "Exception trying to enqueue restore", e); doRestore = false; &#125; &#125; else &#123; Slog.e(TAG, "Backup Manager not found!"); doRestore = false; &#125; &#125; if (!doRestore) &#123; // No restore possible, or the Backup Manager was mysteriously not // available -- just fire the post-install work request directly. if (DEBUG_INSTALL) Log.v(TAG, "No restore - queue post-install for " + token); Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0); mHandler.sendMessage(msg); &#125; &#125; &#125;);&#125; 这个方法有几个关键步骤,一是installPackageLI(args, res);,这个方法具体执行了解析package和后续操作,而再installPackageLI(args, res);执行完毕后会走到bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token);,会调用backupservice的restoreAtInstall方法,而restoreAtInstall方法最终又会调用PMS的finishPackageInstall()方法,完成安装。 2.2 installPackageLI(args, res)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171private void installPackageLI(InstallArgs args, PackageInstalledInfo res) &#123; final int installFlags = args.installFlags; String installerPackageName = args.installerPackageName; File tmpPackageFile = new File(args.getCodePath()); boolean forwardLocked = ((installFlags &amp; PackageManager.INSTALL_FORWARD_LOCK) != 0); boolean onSd = ((installFlags &amp; PackageManager.INSTALL_EXTERNAL) != 0); boolean replace = false; final int scanFlags = SCAN_NEW_INSTALL | SCAN_FORCE_DEX | SCAN_UPDATE_SIGNATURE; // Result object to be returned res.returnCode = PackageManager.INSTALL_SUCCEEDED; if (DEBUG_INSTALL) Slog.d(TAG, "installPackageLI: path=" + tmpPackageFile); // Retrieve PackageSettings and parse package final int parseFlags = mDefParseFlags | PackageParser.PARSE_CHATTY | (forwardLocked ? PackageParser.PARSE_FORWARD_LOCK : 0) | (onSd ? PackageParser.PARSE_ON_SDCARD : 0); PackageParser pp = new PackageParser(); pp.setSeparateProcesses(mSeparateProcesses); pp.setDisplayMetrics(mMetrics); final PackageParser.Package pkg; try &#123; pkg = pp.parsePackage(tmpPackageFile, parseFlags); &#125; catch (PackageParserException e) &#123; res.setError("Failed parse during installPackageLI", e); return; &#125; // Mark that we have an install time CPU ABI override. pkg.cpuAbiOverride = args.abiOverride; String pkgName = res.name = pkg.packageName; if ((pkg.applicationInfo.flags&amp;ApplicationInfo.FLAG_TEST_ONLY) != 0) &#123; if ((installFlags &amp; PackageManager.INSTALL_ALLOW_TEST) == 0) &#123; res.setError(INSTALL_FAILED_TEST_ONLY, "installPackageLI"); return; &#125; &#125; try &#123; pp.collectCertificates(pkg, parseFlags); pp.collectManifestDigest(pkg); &#125; catch (PackageParserException e) &#123; res.setError("Failed collect during installPackageLI", e); return; &#125; /* If the installer passed in a manifest digest, compare it now. */ if (args.manifestDigest != null) &#123; if (DEBUG_INSTALL) &#123; final String parsedManifest = pkg.manifestDigest == null ? "null" : pkg.manifestDigest.toString(); Slog.d(TAG, "Comparing manifests: " + args.manifestDigest.toString() + " vs. " + parsedManifest); &#125; if (!args.manifestDigest.equals(pkg.manifestDigest)) &#123; res.setError(INSTALL_FAILED_PACKAGE_CHANGED, "Manifest digest changed"); return; &#125; &#125; else if (DEBUG_INSTALL) &#123; final String parsedManifest = pkg.manifestDigest == null ? "null" : pkg.manifestDigest.toString(); Slog.d(TAG, "manifestDigest was not present, but parser got: " + parsedManifest); &#125; // Get rid of all references to package scan path via parser. pp = null; String oldCodePath = null; boolean systemApp = false; synchronized (mPackages) &#123; // Check whether the newly-scanned package wants to define an already-defined perm int N = pkg.permissions.size(); for (int i = N-1; i &gt;= 0; i--) &#123; PackageParser.Permission perm = pkg.permissions.get(i); BasePermission bp = mSettings.mPermissions.get(perm.info.name); if (bp != null) &#123; // If the defining package is signed with our cert, it's okay. This // also includes the "updating the same package" case, of course. // "updating same package" could also involve key-rotation. final boolean sigsOk; if (!bp.sourcePackage.equals(pkg.packageName) || !(bp.packageSetting instanceof PackageSetting) || !bp.packageSetting.keySetData.isUsingUpgradeKeySets() || ((PackageSetting) bp.packageSetting).sharedUser != null) &#123; sigsOk = compareSignatures(bp.packageSetting.signatures.mSignatures, pkg.mSignatures) == PackageManager.SIGNATURE_MATCH; &#125; else &#123; sigsOk = checkUpgradeKeySetLP((PackageSetting) bp.packageSetting, pkg); &#125; if (!sigsOk) &#123; // If the owning package is the system itself, we log but allow // install to proceed; we fail the install on all other permission // redefinitions. if (!bp.sourcePackage.equals("android")) &#123; res.setError(INSTALL_FAILED_DUPLICATE_PERMISSION, "Package " + pkg.packageName + " attempting to redeclare permission " + perm.info.name + " already owned by " + bp.sourcePackage); res.origPermission = perm.info.name; res.origPackage = bp.sourcePackage; return; &#125; else &#123; Slog.w(TAG, "Package " + pkg.packageName + " attempting to redeclare system permission " + perm.info.name + "; ignoring new declaration"); pkg.permissions.remove(i); &#125; &#125; &#125; &#125; // Check if installing already existing package if ((installFlags &amp; PackageManager.INSTALL_REPLACE_EXISTING) != 0) &#123; String oldName = mSettings.mRenamedPackages.get(pkgName); if (pkg.mOriginalPackages != null &amp;&amp; pkg.mOriginalPackages.contains(oldName) &amp;&amp; mPackages.containsKey(oldName)) &#123; // This package is derived from an original package, // and this device has been updating from that original // name. We must continue using the original name, so // rename the new package here. pkg.setPackageName(oldName); pkgName = pkg.packageName; replace = true; if (DEBUG_INSTALL) Slog.d(TAG, "Replacing existing renamed package: oldName=" + oldName + " pkgName=" + pkgName); &#125; else if (mPackages.containsKey(pkgName)) &#123; // This package, under its official name, already exists // on the device; we should replace it. replace = true; if (DEBUG_INSTALL) Slog.d(TAG, "Replace existing pacakge: " + pkgName); &#125; &#125; PackageSetting ps = mSettings.mPackages.get(pkgName); if (ps != null) &#123; if (DEBUG_INSTALL) Slog.d(TAG, "Existing package: " + ps); oldCodePath = mSettings.mPackages.get(pkgName).codePathString; if (ps.pkg != null &amp;&amp; ps.pkg.applicationInfo != null) &#123; systemApp = (ps.pkg.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0; &#125; res.origUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true); &#125; &#125; if (systemApp &amp;&amp; onSd) &#123; // Disable updates to system apps on sdcard res.setError(INSTALL_FAILED_INVALID_INSTALL_LOCATION, "Cannot install updates to system apps on sdcard"); return; &#125; if (!args.doRename(res.returnCode, pkg, oldCodePath)) &#123; res.setError(INSTALL_FAILED_INSUFFICIENT_STORAGE, "Failed rename"); return; &#125; if (replace) &#123; replacePackageLI(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res); &#125; else &#123; installNewPackageLI(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, res); &#125; synchronized (mPackages) &#123; final PackageSetting ps = mSettings.mPackages.get(pkgName); if (ps != null) &#123; res.newUsers = ps.queryInstalledUsers(sUserManager.getUserIds(), true); &#125; &#125; &#125; 这个方法先是解析了package包,然后做了大量签名和权限校验的工作,最终会走到 1234567if (replace) &#123; replacePackageLI(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user, installerPackageName, res); &#125; else &#123; installNewPackageLI(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES, args.user, installerPackageName, res); &#125; 这两个方法分别是覆盖安装和安装新应用对应的具体执行.我们来看看installNewPackageLI() 2.3 installNewPackageLI()123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private void installNewPackageLI(PackageParser.Package pkg, int parseFlags, int scanFlags, UserHandle user, String installerPackageName, PackageInstalledInfo res) &#123; // Remember this for later, in case we need to rollback this install String pkgName = pkg.packageName; if (DEBUG_INSTALL) Slog.d(TAG, "installNewPackageLI: " + pkg); boolean dataDirExists = getDataPathForPackage(pkg.packageName, 0).exists(); synchronized(mPackages) &#123; if (mSettings.mRenamedPackages.containsKey(pkgName)) &#123; // A package with the same name is already installed, though // it has been renamed to an older name. The package we // are trying to install should be installed as an update to // the existing one, but that has not been requested, so bail. res.setError(INSTALL_FAILED_ALREADY_EXISTS, "Attempt to re-install " + pkgName + " without first uninstalling package running as " + mSettings.mRenamedPackages.get(pkgName)); return; &#125; if (mPackages.containsKey(pkgName)) &#123; // Don't allow installation over an existing package with the same name. res.setError(INSTALL_FAILED_ALREADY_EXISTS, "Attempt to re-install " + pkgName + " without first uninstalling."); return; &#125; &#125; try &#123; PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanFlags, System.currentTimeMillis(), user); updateSettingsLI(newPackage, installerPackageName, null, null, res); // delete the partially installed application. the data directory will have to be // restored if it was already existing if (res.returnCode != PackageManager.INSTALL_SUCCEEDED) &#123; // remove package from internal structures. Note that we want deletePackageX to // delete the package data and cache directories that it created in // scanPackageLocked, unless those directories existed before we even tried to // install. deletePackageLI(pkgName, UserHandle.ALL, false, null, null, dataDirExists ? PackageManager.DELETE_KEEP_DATA : 0, res.removedInfo, true); &#125; &#125; catch (PackageManagerException e) &#123; res.setError("Package couldn't be installed in " + pkg.codePath, e); &#125;&#125; 这个方法核心的步骤有两个: PackageParser.Package newPackage = scanPackageLI(pkg, parseFlags, scanFlags,System.currentTimeMillis(), user); updateSettingsLI(newPackage, installerPackageName, null, null, res); scanPackageLI负责安装,而updateSettingLI则是完成安装后的设置信息更新 2.4 scanPackageLI()scanPackageLI()方法主要逻辑是由scanPackageDirtyLI()实现的,scanPackageDirtyLI()实在太长了,此处就不列出了,主要说下,这个方法实现了以下操作: 设置系统App的一些参数 校验签名 解析app的provider,校验是否与已有的provider冲突 32/64位abi的一些设置 四大组件的解析，注册 scanPackageDirtyLI()里面的操作确实是太多了，并不止这几点。如需更详细的信息还请查看源码。 另一方面，这个方法里,会调用到performDexOptLI(),其会去执行dexopt操作。 3. dexopt操作Apk文件其实只是一个归档zip压缩包,而我们编写的代码最终都编译成了.dex文件,但为了提高运行性能,android系统并不会直接执行.dex,而是会在安装过程中执行dexopt操作来优化.dex文件,最终android系统执行的时优化后的’odex’文件(注意:这个odex文件的后缀也是.dex,其路径在data/dalvik-cache)。对于dalvik虚拟机,dexopt就是优化操作,而对于art虚拟机,dexopt执行的则是dex2oat操作,既将.dex文件翻译成oat文件。关于art和dex2oat的更多信息请看后文。 这里我们先来看看PMS的dexopt操作: 3.1 performDexOptLI()这个方法的核心是 1final int ret = mInstaller.dexopt(path, sharedGid, !isForwardLocked(pkg), pkg.packageName, dexCodeInstructionSet, vmSafeMode); 其作用就是调用PMS的mInstaller成员变量的dexopt操作。 3.2 Installer.dexoptInstaller类的dexopt方法又调用InstallerConnection类的dexopt方法,来看看这个方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public int dexopt(String apkPath, int uid, boolean isPublic, String pkgName, String instructionSet, boolean vmSafeMode) &#123; StringBuilder builder = new StringBuilder("dexopt"); builder.append(' '); builder.append(apkPath); builder.append(' '); builder.append(uid); builder.append(isPublic ? " 1" : " 0"); builder.append(' '); builder.append(pkgName); builder.append(' '); builder.append(instructionSet); builder.append(' '); builder.append(vmSafeMode ? " 1" : " 0"); return execute(builder.toString()); &#125; public synchronized String transact(String cmd) &#123; if (!connect()) &#123; Slog.e(TAG, "connection failed"); return "-1"; &#125; if (!writeCommand(cmd)) &#123; /* * If installd died and restarted in the background (unlikely but * possible) we'll fail on the next write (this one). Try to * reconnect and write the command one more time before giving up. */ Slog.e(TAG, "write command failed? reconnect!"); if (!connect() || !writeCommand(cmd)) &#123; return "-1"; &#125; &#125; if (LOCAL_DEBUG) &#123; Slog.i(TAG, "send: '" + cmd + "'"); &#125; final int replyLength = readReply(); if (replyLength &gt; 0) &#123; String s = new String(buf, 0, replyLength); if (LOCAL_DEBUG) &#123; Slog.i(TAG, "recv: '" + s + "'"); &#125; return s; &#125; else &#123; if (LOCAL_DEBUG) &#123; Slog.i(TAG, "fail"); &#125; return "-1"; &#125; &#125; public int execute(String cmd) &#123; String res = transact(cmd); try &#123; return Integer.parseInt(res); &#125; catch (NumberFormatException ex) &#123; return -1; &#125; &#125; private boolean connect() &#123; if (mSocket != null) &#123; return true; &#125; Slog.i(TAG, "connecting..."); try &#123; mSocket = new LocalSocket(); LocalSocketAddress address = new LocalSocketAddress("installd", LocalSocketAddress.Namespace.RESERVED); mSocket.connect(address); mIn = mSocket.getInputStream(); mOut = mSocket.getOutputStream(); &#125; catch (IOException ex) &#123; disconnect(); return false; &#125; return true; &#125; 由上面的几个方法可以知道,最终dexopt操作是通过socket的方式来跨进程通知守护进程installd,由其去执行dexopt操作。 3.3 commands::dexopt()最终守护进程installd会调用Commands.c文件(位于/source/framework/native/cmds/installd)的dexopt方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788int dexopt(const char *apk_path, uid_t uid, bool is_public, const char *pkgname, const char *instruction_set, bool vm_safe_mode, bool is_patchoat)&#123; struct utimbuf ut; struct stat input_stat, dex_stat; char out_path[PKG_PATH_MAX]; char persist_sys_dalvik_vm_lib[PROPERTY_VALUE_MAX]; char *end; const char *input_file; char in_odex_path[PKG_PATH_MAX]; int res, input_fd=-1, out_fd=-1; ... ... pid_t pid; pid = fork(); if (pid == 0) &#123; /* child -- drop privileges before continuing */ if (setgid(uid) != 0) &#123; ALOGE("setgid(%d) failed in installd during dexopt\n", uid); exit(64); &#125; if (setuid(uid) != 0) &#123; ALOGE("setuid(%d) failed in installd during dexopt\n", uid); exit(65); &#125; // drop capabilities struct __user_cap_header_struct capheader; struct __user_cap_data_struct capdata[2]; memset(&amp;capheader, 0, sizeof(capheader)); memset(&amp;capdata, 0, sizeof(capdata)); capheader.version = _LINUX_CAPABILITY_VERSION_3; if (capset(&amp;capheader, &amp;capdata[0]) &lt; 0) &#123; ALOGE("capset failed: %s\n", strerror(errno)); exit(66); &#125; if (set_sched_policy(0, SP_BACKGROUND) &lt; 0) &#123; ALOGE("set_sched_policy failed: %s\n", strerror(errno)); exit(70); &#125; if (flock(out_fd, LOCK_EX | LOCK_NB) != 0) &#123; ALOGE("flock(%s) failed: %s\n", out_path, strerror(errno)); exit(67); &#125; if (strncmp(persist_sys_dalvik_vm_lib, "libdvm", 6) == 0) &#123; run_dexopt(input_fd, out_fd, input_file, out_path); &#125; else if (strncmp(persist_sys_dalvik_vm_lib, "libart", 6) == 0) &#123; if (is_patchoat) &#123; run_patchoat(input_fd, out_fd, input_file, out_path, pkgname, instruction_set); &#125; else &#123; run_dex2oat(input_fd, out_fd, input_file, out_path, pkgname, instruction_set, vm_safe_mode); &#125; &#125; else &#123; exit(69); /* Unexpected persist.sys.dalvik.vm.lib value */ &#125; exit(68); /* only get here on exec failure */ &#125; else &#123; res = wait_child(pid); if (res == 0) &#123; ALOGV("DexInv: --- END '%s' (success) ---\n", input_file); &#125; else &#123; ALOGE("DexInv: --- END '%s' --- status=0x%04x, process failed\n", input_file, res); goto fail; &#125; &#125; ut.actime = input_stat.st_atime; ut.modtime = input_stat.st_mtime; utime(out_path, &amp;ut); close(out_fd); close(input_fd); return 0;fail: if (out_fd &gt;= 0) &#123; close(out_fd); unlink(out_path); &#125; if (input_fd &gt;= 0) &#123; close(input_fd); &#125; return -1;&#125; 由上面的代码可以发现,installd在做了些操作后,fork出了一个新的进程,根据虚拟机的类型为libdvm或libart分别执行run_dexopt或run_dex2oat(如果为is_patchoat,则是run_patchoat)操作。 4. 更新权限信息dexopt操作执行完后,installNewPackageLI()方法就会走到updateSettingsLI()来更新设置信息,而更新设置信息主要是权限信息,所以直接来看updatePermissionsLPw(); 4.1 updatePermissionsLPw123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223private void updatePermissionsLPw(String changingPkg, PackageParser.Package pkgInfo, int flags) &#123; // Make sure there are no dangling permission trees. Iterator&lt;BasePermission&gt; it = mSettings.mPermissionTrees.values().iterator(); while (it.hasNext()) &#123; final BasePermission bp = it.next(); if (bp.packageSetting == null) &#123; // We may not yet have parsed the package, so just see if // we still know about its settings. bp.packageSetting = mSettings.mPackages.get(bp.sourcePackage); &#125; if (bp.packageSetting == null) &#123; Slog.w(TAG, "Removing dangling permission tree: " + bp.name + " from package " + bp.sourcePackage); it.remove(); &#125; else if (changingPkg != null &amp;&amp; changingPkg.equals(bp.sourcePackage)) &#123; if (pkgInfo == null || !hasPermission(pkgInfo, bp.name)) &#123; Slog.i(TAG, "Removing old permission tree: " + bp.name + " from package " + bp.sourcePackage); flags |= UPDATE_PERMISSIONS_ALL; it.remove(); &#125; &#125; &#125; // Make sure all dynamic permissions have been assigned to a package, // and make sure there are no dangling permissions. it = mSettings.mPermissions.values().iterator(); while (it.hasNext()) &#123; final BasePermission bp = it.next(); if (bp.type == BasePermission.TYPE_DYNAMIC) &#123; if (DEBUG_SETTINGS) Log.v(TAG, "Dynamic permission: name=" + bp.name + " pkg=" + bp.sourcePackage + " info=" + bp.pendingInfo); if (bp.packageSetting == null &amp;&amp; bp.pendingInfo != null) &#123; final BasePermission tree = findPermissionTreeLP(bp.name); if (tree != null &amp;&amp; tree.perm != null) &#123; bp.packageSetting = tree.packageSetting; bp.perm = new PackageParser.Permission(tree.perm.owner, new PermissionInfo(bp.pendingInfo)); bp.perm.info.packageName = tree.perm.info.packageName; bp.perm.info.name = bp.name; bp.uid = tree.uid; &#125; &#125; &#125; if (bp.packageSetting == null) &#123; // We may not yet have parsed the package, so just see if // we still know about its settings. bp.packageSetting = mSettings.mPackages.get(bp.sourcePackage); &#125; if (bp.packageSetting == null) &#123; Slog.w(TAG, "Removing dangling permission: " + bp.name + " from package " + bp.sourcePackage); it.remove(); &#125; else if (changingPkg != null &amp;&amp; changingPkg.equals(bp.sourcePackage)) &#123; if (pkgInfo == null || !hasPermission(pkgInfo, bp.name)) &#123; Slog.i(TAG, "Removing old permission: " + bp.name + " from package " + bp.sourcePackage); flags |= UPDATE_PERMISSIONS_ALL; it.remove(); &#125; &#125; &#125; // Now update the permissions for all packages, in particular // replace the granted permissions of the system packages. if ((flags&amp;UPDATE_PERMISSIONS_ALL) != 0) &#123; for (PackageParser.Package pkg : mPackages.values()) &#123; if (pkg != pkgInfo) &#123; grantPermissionsLPw(pkg, (flags&amp;UPDATE_PERMISSIONS_REPLACE_ALL) != 0, changingPkg); &#125; &#125; &#125; if (pkgInfo != null) &#123; grantPermissionsLPw(pkgInfo, (flags&amp;UPDATE_PERMISSIONS_REPLACE_PKG) != 0, changingPkg); &#125; &#125; private void grantPermissionsLPw(PackageParser.Package pkg, boolean replace, String packageOfInterest) &#123; final PackageSetting ps = (PackageSetting) pkg.mExtras; if (ps == null) &#123; return; &#125; final GrantedPermissions gp = ps.sharedUser != null ? ps.sharedUser : ps; HashSet&lt;String&gt; origPermissions = gp.grantedPermissions; boolean changedPermission = false; if (replace) &#123; ps.permissionsFixed = false; if (gp == ps) &#123; origPermissions = new HashSet&lt;String&gt;(gp.grantedPermissions); gp.grantedPermissions.clear(); gp.gids = mGlobalGids; &#125; &#125; if (gp.gids == null) &#123; gp.gids = mGlobalGids; &#125; final int N = pkg.requestedPermissions.size(); for (int i=0; i&lt;N; i++) &#123; final String name = pkg.requestedPermissions.get(i); final boolean required = pkg.requestedPermissionsRequired.get(i); final BasePermission bp = mSettings.mPermissions.get(name); if (DEBUG_INSTALL) &#123; if (gp != ps) &#123; Log.i(TAG, "Package " + pkg.packageName + " checking " + name + ": " + bp); &#125; &#125; if (bp == null || bp.packageSetting == null) &#123; if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, "Unknown permission " + name + " in package " + pkg.packageName); &#125; continue; &#125; final String perm = bp.name; boolean allowed; boolean allowedSig = false; if ((bp.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_APPOP) != 0) &#123; // Keep track of app op permissions. ArraySet&lt;String&gt; pkgs = mAppOpPermissionPackages.get(bp.name); if (pkgs == null) &#123; pkgs = new ArraySet&lt;&gt;(); mAppOpPermissionPackages.put(bp.name, pkgs); &#125; pkgs.add(pkg.packageName); &#125; final int level = bp.protectionLevel &amp; PermissionInfo.PROTECTION_MASK_BASE; if (level == PermissionInfo.PROTECTION_NORMAL || level == PermissionInfo.PROTECTION_DANGEROUS) &#123; // We grant a normal or dangerous permission if any of the following // are true: // 1) The permission is required // 2) The permission is optional, but was granted in the past // 3) The permission is optional, but was requested by an // app in /system (not /data) // // Otherwise, reject the permission. allowed = (required || origPermissions.contains(perm) || (isSystemApp(ps) &amp;&amp; !isUpdatedSystemApp(ps))); &#125; else if (bp.packageSetting == null) &#123; // This permission is invalid; skip it. allowed = false; &#125; else if (level == PermissionInfo.PROTECTION_SIGNATURE) &#123; allowed = grantSignaturePermission(perm, pkg, bp, origPermissions); if (allowed) &#123; allowedSig = true; &#125; &#125; else &#123; allowed = false; &#125; if (DEBUG_INSTALL) &#123; if (gp != ps) &#123; Log.i(TAG, "Package " + pkg.packageName + " granting " + perm); &#125; &#125; if (allowed) &#123; if (!isSystemApp(ps) &amp;&amp; ps.permissionsFixed) &#123; // If this is an existing, non-system package, then // we can't add any new permissions to it. if (!allowedSig &amp;&amp; !gp.grantedPermissions.contains(perm)) &#123; // Except... if this is a permission that was added // to the platform (note: need to only do this when // updating the platform). allowed = isNewPlatformPermissionForPackage(perm, pkg); &#125; &#125; if (allowed) &#123; if (!gp.grantedPermissions.contains(perm)) &#123; changedPermission = true; gp.grantedPermissions.add(perm); gp.gids = appendInts(gp.gids, bp.gids); &#125; else if (!ps.haveGids) &#123; gp.gids = appendInts(gp.gids, bp.gids); &#125; &#125; else &#123; if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, "Not granting permission " + perm + " to package " + pkg.packageName + " because it was previously installed without"); &#125; &#125; &#125; else &#123; if (gp.grantedPermissions.remove(perm)) &#123; changedPermission = true; gp.gids = removeInts(gp.gids, bp.gids); Slog.i(TAG, "Un-granting permission " + perm + " from package " + pkg.packageName + " (protectionLevel=" + bp.protectionLevel + " flags=0x" + Integer.toHexString(pkg.applicationInfo.flags) + ")"); &#125; else if ((bp.protectionLevel&amp;PermissionInfo.PROTECTION_FLAG_APPOP) == 0) &#123; // Don't print warning for app op permissions, since it is fine for them // not to be granted, there is a UI for the user to decide. if (packageOfInterest == null || packageOfInterest.equals(pkg.packageName)) &#123; Slog.w(TAG, "Not granting permission " + perm + " to package " + pkg.packageName + " (protectionLevel=" + bp.protectionLevel + " flags=0x" + Integer.toHexString(pkg.applicationInfo.flags) + ")"); &#125; &#125; &#125; &#125; if ((changedPermission || replace) &amp;&amp; !ps.permissionsFixed &amp;&amp; !isSystemApp(ps) || isUpdatedSystemApp(ps))&#123; // This is the first that we have heard about this package, so the // permissions we have now selected are fixed until explicitly // changed. ps.permissionsFixed = true; &#125; ps.haveGids = true; &#125; 由上面两个方法可以看到,在apk的安装时PMS会将该app的所有权限都记录下来并更新到PMS的mAppOpPermissionPackages成员变量里面,并判定是否授予该app请求的权限。 4.2 完成安装还记得前面说过的在processPendingInstall方法在执行installPackageLi后会执行以下语句 1234567891011121314151617181920212223if (res.returnCode == PackageManager.INSTALL_SUCCEEDED &amp;&amp; doRestore) &#123; // Pass responsibility to the Backup Manager. It will perform a // restore if appropriate, then pass responsibility back to the // Package Manager to run the post-install observer callbacks // and broadcasts. IBackupManager bm = IBackupManager.Stub.asInterface( ServiceManager.getService(Context.BACKUP_SERVICE)); if (bm != null) &#123; if (DEBUG_INSTALL) Log.v(TAG, "token " + token + " to BM for possible restore"); try &#123; bm.restoreAtInstall(res.pkg.applicationInfo.packageName, token); &#125; catch (RemoteException e) &#123; // can't happen; the backup manager is local &#125; catch (Exception e) &#123; Slog.e(TAG, "Exception trying to enqueue restore", e); doRestore = false; &#125; &#125; else &#123; Slog.e(TAG, "Backup Manager not found!"); doRestore = false; &#125; &#125; 我也不是很清楚为什么系统会调用IBackupManager的restoreAtInstall方法,不过发现在BackupManagerService的restoreAtInstall方法中会有以下代码: 12345678910... if (skip) &#123; // Auto-restore disabled or no way to attempt a restore; just tell the Package // Manager to proceed with the post-install handling for this package. if (DEBUG) Slog.v(TAG, "Finishing install immediately"); try &#123; mPackageManagerBinder.finishPackageInstall(token); &#125; catch (RemoteException e) &#123; /* can't happen */ &#125; &#125;... 最终restoreAtInstall方法又会调用PMS的finishPackageInstall方法,而此方法最终会发送Intent.ACTION_PACKAGE_ADDED广播，apk的安装就到到此结束了。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualApk解析]]></title>
    <url>%2F2018%2F06%2F07%2FVirtualApk%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、概述之前一直没有写过插件化相关的博客，刚好最近滴滴和360分别开源了自家的插件化方案，赶紧学习下，写两篇博客，第一篇是滴滴的方案： https://github.com/didi/VirtualAPK 那么其中的难点很明显是对四大组件支持，因为大家都清楚，四大组件都是需要在AndroidManifest中注册的，而插件apk中的组件是不可能预先知晓名字，提前注册中宿主apk中的，所以现在基本都采用一些hack方案类解决，VirtualAPK大体方案如下： Activity：在宿主apk中提前占几个坑，然后通过“欺上瞒下”（这个词好像是360之前的ppt中提到）的方式，启动插件apk的Activity；因为要支持不同的launchMode以及一些特殊的属性，需要占多个坑。 Service：通过代理Service的方式去分发；主进程和其他进程，VirtualAPK使用了两个代理Service。 BroadcastReceiver：静态转动态 ContentProvider：通过一个代理Provider进行分发。 这些占坑的数量并不是固定的，比如Activity想支持某个属性，该属性不能动态设置，只能在Manifest中设置，那就需要去占坑支持。所以占坑数量这些，可以根据自己的需求进行调整。 下面就逐一去分析代码啦~ 注：本篇博客涉及到的framework逻辑，为API 22.分期版本为 com.didi.virtualapk:core:0.9.0 二、Activity的支持这里就不按照某个流程一行行代码往下读了，针对性的讲一些关键流程，可能更好阅读一些。 首先看一段启动插件Activity的代码： 12345678910final String pkg = "com.didi.virtualapk.demo";if (PluginManager.getInstance(this).getLoadedPlugin(pkg) == null) &#123; Toast.makeText(this, "plugin [com.didi.virtualapk.demo] not loaded", Toast.LENGTH_SHORT).show(); return;&#125;// test Activity and ServiceIntent intent = new Intent();intent.setClassName(pkg, "com.didi.virtualapk.demo.aidl.BookManagerActivity");startActivity(intent); 可以看到优先根据包名判断该插件是否已经加载，所以在插件使用前其实还需要调用 1pluginManager.loadPlugin(apk); 加载插件。 这里就不赘述源码了，大致为调用PackageParser.parsePackage解析apk，获得该apk对应的PackageInfo，资源相关（AssetManager，Resources），DexClassLoader（加载类），四大组件相关集合（mActivityInfos，mServiceInfos，mReceiverInfos，mProviderInfos），针对Plugin的PluginContext等一堆信息，封装为LoadedPlugin对象。 详细可以参考com.didi.virtualapk.internal.LoadedPlugin类。 ok，如果该插件以及加载过，则直接通过startActivity去启动插件中目标Activity。 （1）替换Activity这里大家肯定会有疑惑，该Activity必然没有在Manifest中注册，这么启动不会报错吗？ 正常肯定会报错呀，所以我们看看它是怎么做的吧。 跟进startActivity的调用流程，会发现其最终会进入Instrumentation的execStartActivity方法，然后再通过ActivityManagerProxy与AMS进行交互。 而Activity是否存在的校验是发生在AMS端，所以我们在于AMS交互前，提前将Activity的ComponentName进行替换为占坑的名字不就好了么？ 这里可以选择hook Instrumentation，或者ActivityManagerProxy都可以达到目标，VirtualAPK选择了hook Instrumentation. 打开PluginManager可以看到如下方法： 1234567891011121314151617private void hookInstrumentationAndHandler() &#123; try &#123; Instrumentation baseInstrumentation = ReflectUtil.getInstrumentation(this.mContext); if (baseInstrumentation.getClass().getName().contains("lbe")) &#123; // reject executing in paralell space, for example, lbe. System.exit(0); &#125; final VAInstrumentation instrumentation = new VAInstrumentation(this, baseInstrumentation); Object activityThread = ReflectUtil.getActivityThread(this.mContext); ReflectUtil.setInstrumentation(activityThread, instrumentation); ReflectUtil.setHandlerCallback(this.mContext, instrumentation); this.mInstrumentation = instrumentation; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 可以看到首先通过反射拿到了原本的Instrumentation对象，拿的过程是首先拿到ActivityThread，由于ActivityThread可以通过静态变量sCurrentActivityThread或者静态方法currentActivityThread()获取，所以拿到其对象相当轻松。拿到ActivityThread对象后，调用其getInstrumentation()方法，即可获取当前的Instrumentation对象。 然后自己创建了一个VAInstrumentation对象，接下来就直接反射将VAInstrumentation对象设置给ActivityThread对象即可。 这样就完成了hook Instrumentation,之后调用Instrumentation的任何方法，都可以在VAInstrumentation进行拦截并做一些修改。 这里还hook了ActivityThread的mH类的Callback，暂不赘述。 刚才说了，可以通过Instrumentation的execStartActivity方法进行偷梁换柱，所以我们直接看对应的方法： 123456789101112131415161718public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) &#123; mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent); // null component is an implicitly intent if (intent.getComponent() != null) &#123; Log.i(TAG, String.format("execStartActivity[%s : %s]", intent.getComponent().getPackageName(), intent.getComponent().getClassName())); // resolve intent with Stub Activity if needed this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent); &#125; ActivityResult result = realExecStartActivity(who, contextThread, token, target, intent, requestCode, options); return result;&#125; 首先调用transformIntentToExplicitAsNeeded，这个主要是当component为null时，根据启动Activity时，配置的action，data,category等去已加载的plugin中匹配到确定的Activity的。 本例我们的写法ComponentName肯定不为null，所以直接看markIntentIfNeeded()方法： 12345678910111213141516public void markIntentIfNeeded(Intent intent) &#123; if (intent.getComponent() == null) &#123; return; &#125; String targetPackageName = intent.getComponent().getPackageName(); String targetClassName = intent.getComponent().getClassName(); // search map and return specific launchmode stub activity if (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != null) &#123; intent.putExtra(Constants.KEY_IS_PLUGIN, true); intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName); intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName); dispatchStubActivity(intent); &#125;&#125; 在该方法中判断如果启动的是插件中类，则将启动的包名和Activity类名存到了intent中，可以看到这里存储明显是为了后面恢复用的。 然后调用了dispatchStubActivity(intent) 123456789101112131415private void dispatchStubActivity(Intent intent) &#123; ComponentName component = intent.getComponent(); String targetClassName = intent.getComponent().getClassName(); LoadedPlugin loadedPlugin = mPluginManager.getLoadedPlugin(intent); ActivityInfo info = loadedPlugin.getActivityInfo(component); if (info == null) &#123; throw new RuntimeException("can not find " + component); &#125; int launchMode = info.launchMode; Resources.Theme themeObj = loadedPlugin.getResources().newTheme(); themeObj.applyStyle(info.theme, true); String stubActivity = mStubActivityInfo.getStubActivity(targetClassName, launchMode, themeObj); Log.i(TAG, String.format("dispatchStubActivity,[%s -&gt; %s]", targetClassName, stubActivity)); intent.setClassName(mContext, stubActivity);&#125; 可以直接看最后一行，intent通过setClassName替换启动的目标Activity了！这个stubActivity是由mStubActivityInfo.getStubActivity(targetClassName, launchMode, themeObj)返回。 很明显，传入的参数launchMode、themeObj都是决定选择哪一个占坑类用的。 123456789101112131415161718192021222324252627282930313233343536public String getStubActivity(String className, int launchMode, Theme theme) &#123; String stubActivity= mCachedStubActivity.get(className); if (stubActivity != null) &#123; return stubActivity; &#125; TypedArray array = theme.obtainStyledAttributes(new int[]&#123; android.R.attr.windowIsTranslucent, android.R.attr.windowBackground &#125;); boolean windowIsTranslucent = array.getBoolean(0, false); array.recycle(); if (Constants.DEBUG) &#123; Log.d("StubActivityInfo", "getStubActivity, is transparent theme ? " + windowIsTranslucent); &#125; stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity); switch (launchMode) &#123; case ActivityInfo.LAUNCH_MULTIPLE: &#123; stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity); if (windowIsTranslucent) &#123; stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, 2); &#125; break; &#125; case ActivityInfo.LAUNCH_SINGLE_TOP: &#123; usedSingleTopStubActivity = usedSingleTopStubActivity % MAX_COUNT_SINGLETOP + 1; stubActivity = String.format(STUB_ACTIVITY_SINGLETOP, corePackage, usedSingleTopStubActivity); break; &#125; // 省略LAUNCH_SINGLE_TASK，LAUNCH_SINGLE_INSTANCE &#125; mCachedStubActivity.put(className, stubActivity); return stubActivity;&#125; 可以看到主要就是根据launchMode去选择不同的占坑类。例如： 1stubActivity = String.format(STUB_ACTIVITY_STANDARD, corePackage, usedStandardStubActivity); STUB_ACTIVITY_STANDARD值为：&quot;%s.A$%d&quot;, corePackage值为com.didi.virtualapk.core，usedStandardStubActivity为数字值。 所以最终类名格式为：com.didi.virtualapk.core.A$1 再看一眼，CoreLibrary下的AndroidManifest中： 123456789&lt;activity android:name=".A$1" android:launchMode="standard"/&gt;&lt;activity android:name=".A$2" android:launchMode="standard" android:theme="@android:style/Theme.Translucent" /&gt;&lt;!-- Stub Activities --&gt;&lt;activity android:name=".B$1" android:launchMode="singleTop"/&gt;&lt;activity android:name=".B$2" android:launchMode="singleTop"/&gt;&lt;activity android:name=".B$3" android:launchMode="singleTop"/&gt;// 省略很多... 123456789123456789 就完全明白了。 到这里就可以看到，替换我们启动的Activity为占坑Activity，将我们原本启动的包名，类名存储到了Intent中。 这样做只完成了一半，为什么这么说呢？ (2) 还原Activity因为欺骗过了AMS，AMS执行完成后，最终要启动的不可能是占坑Activity，还应该是我们的启动的目标Activity呀。 这里需要知道Activity的启动流程： AMS在处理完启动Activity后，会调用：app.thread.scheduleLaunchActivity，这里的thread对应的server端未我们ActivityThread中的ApplicationThread对象(binder可以理解有一个client端和一个server端)，所以会调用ApplicationThread.scheduleLaunchActivity方法，在其内部会调用mH类的sendMessage方法，传递的标识为H.LAUNCH_ACTIVITY，进入调用到ActivityThread的handleLaunchActivity方法-&gt;ActivityThread#handleLaunchActivity-&gt;mInstrumentation.newActivity()。 ps:这里流程不清楚没关系，暂时理解为最终会回调到Instrumentation的newActivity方法即可，细节可以自己去查看结合老罗的blog理解。 关键的来了，最终又到了Instrumentation的newActivity方法，还记得这个类我们已经改为VAInstrumentation啦： 直接看其newActivity方法： 12345678910111213141516171819@Overridepublic Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException &#123; try &#123; cl.loadClass(className); &#125; catch (ClassNotFoundException e) &#123; LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent); String targetClassName = PluginUtil.getTargetActivity(intent); if (targetClassName != null) &#123; Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent); activity.setIntent(intent); // 省略兼容性处理代码 return activity; &#125; &#125; return mBase.newActivity(cl, className, intent);&#125; 核心就是首先从intent中取出我们的目标Activity，然后通过plugin的ClassLoader去加载（还记得在加载插件时，会生成一个LoadedPlugin对象，其中会对应其初始化一个DexClassLoader）。 这样就完成了Activity的“偷梁换柱”。 还没完，接下来在callActivityOnCreate方法中： 12345678910111213141516171819202122232425 @Overridepublic void callActivityOnCreate(Activity activity, Bundle icicle) &#123; final Intent intent = activity.getIntent(); if (PluginUtil.isIntentFromPlugin(intent)) &#123; Context base = activity.getBaseContext(); try &#123; LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent); ReflectUtil.setField(base.getClass(), base, "mResources", plugin.getResources()); ReflectUtil.setField(ContextWrapper.class, activity, "mBase", plugin.getPluginContext()); ReflectUtil.setField(Activity.class, activity, "mApplication", plugin.getApplication()); ReflectUtil.setFieldNoException(ContextThemeWrapper.class, activity, "mBase", plugin.getPluginContext()); // set screenOrientation ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent)); if (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) &#123; activity.setRequestedOrientation(activityInfo.screenOrientation); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; mBase.callActivityOnCreate(activity, icicle);&#125; 设置了修改了mResources、mBase（Context）、mApplication对象。以及设置一些可动态设置的属性，这里仅设置了屏幕方向。 这里提一下，将mBase替换为PluginContext，可以修改Resources、AssetManager以及拦截相当多的操作。 看一眼代码就清楚了： 原本Activity的部分get操作 123456789101112131415161718192021# ContextWrapper@Overridepublic AssetManager getAssets() &#123; return mBase.getAssets();&#125;@Overridepublic Resources getResources()&#123; return mBase.getResources();&#125;@Overridepublic PackageManager getPackageManager() &#123; return mBase.getPackageManager();&#125;@Overridepublic ContentResolver getContentResolver() &#123; return mBase.getContentResolver();&#125; 直接替换为： 12345678910111213141516# PluginContext@Overridepublic Resources getResources() &#123; return this.mPlugin.getResources();&#125;@Overridepublic AssetManager getAssets() &#123; return this.mPlugin.getAssets();&#125;@Overridepublic ContentResolver getContentResolver() &#123; return new PluginContentResolver(getHostContext());&#125; 看得出来还是非常巧妙的。可以做的事情也非常多，后面对ContentProvider的描述也会提现出来。 好了，到此Activity就可以正常启动了。 下面看Service。 三、Service的支持Service和Activity有点不同，显而易见的首先我们也会将要启动的Service类替换为占坑的Service类，但是有一点不同，在Standard模式下多次启动同一个占坑Activity会创建多个对象来对象我们的目标类。而Service多次启动只会调用onStartCommond方法，甚至常规多次调用bindService，seviceConn对象不变，甚至都不会多次回调bindService方法（多次调用可以通过给Intent设置不同Action解决）。 还有一点，最明显的差异是，Activity的生命周期是由用户交互决定的，而Service的声明周期是我们主动通过代码调用的。 也就是说，start、stop、bind、unbind都是我们显示调用的，所以我们可以拦截这几个方法，做一些事情。 Virtual Apk的做法，即将所有的操作进行拦截，都改为startService，然后统一在onStartCommond中分发。 下面看详细代码： (1) hook IActivityManager再次来到PluginManager，发下如下方法： 123456789101112131415private void hookSystemServices() &#123; try &#123; Singleton&lt;IActivityManager&gt; defaultSingleton = (Singleton&lt;IActivityManager&gt;) ReflectUtil.getField(ActivityManagerNative.class, null, "gDefault"); IActivityManager activityManagerProxy = ActivityManagerProxy.newInstance(this, defaultSingleton.get()); // Hook IActivityManager from ActivityManagerNative ReflectUtil.setField(defaultSingleton.getClass().getSuperclass(), defaultSingleton, "mInstance", activityManagerProxy); if (defaultSingleton.get() == activityManagerProxy) &#123; this.mActivityManager = activityManagerProxy; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 首先拿到ActivityManagerNative中的gDefault对象，该对象返回的是一个Singleton&lt;IActivityManager&gt;,然后拿到其mInstance对象，即IActivityManager对象（可以理解为和AMS交互的binder的client对象）对象。 然后通过动态代理的方式，替换为了一个代理对象。 那么重点看对应的InvocationHandler对象即可，该代理对象调用的方法都会辗转到其invoke方法： 1234567891011121314151617181920212223@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if ("startService".equals(method.getName())) &#123; try &#123; return startService(proxy, method, args); &#125; catch (Throwable e) &#123; Log.e(TAG, "Start service error", e); &#125; &#125; else if ("stopService".equals(method.getName())) &#123; try &#123; return stopService(proxy, method, args); &#125; catch (Throwable e) &#123; Log.e(TAG, "Stop Service error", e); &#125; &#125; else if ("stopServiceToken".equals(method.getName())) &#123; try &#123; return stopServiceToken(proxy, method, args); &#125; catch (Throwable e) &#123; Log.e(TAG, "Stop service token error", e); &#125; &#125; // 省略bindService，unbindService等方法&#125; 当我们调用startService时，跟进代码，可以发现调用流程为： 1startService-&gt;startServiceCommon-&gt;ActivityManagerNative.getDefault().startService 这个getDefault刚被我们hook，所以会被上述方法拦截，然后调用：startService(proxy, method, args) 1234567891011private Object startService(Object proxy, Method method, Object[] args) throws Throwable &#123; IApplicationThread appThread = (IApplicationThread) args[0]; Intent target = (Intent) args[1]; ResolveInfo resolveInfo = this.mPluginManager.resolveService(target, 0); if (null == resolveInfo || null == resolveInfo.serviceInfo) &#123; // is host service return method.invoke(this.mActivityManager, args); &#125; return startDelegateServiceForTarget(target, resolveInfo.serviceInfo, null, RemoteService.EXTRA_COMMAND_START_SERVICE);&#125; 先不看代码，考虑下我们这里唯一要做的就是通过Intent保存关键数据，替换启动的Service类为占坑类。 所以直接看最后的方法： 123456private ComponentName startDelegateServiceForTarget(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123; Intent wrapperIntent = wrapperTargetIntent(target, serviceInfo, extras, command); return mPluginManager.getHostContext().startService(wrapperIntent);&#125; 最后一行就是启动了，那么替换的操作应该在wrapperTargetIntent中完成： 12345678910111213141516171819private Intent wrapperTargetIntent(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) &#123; // fill in service with ComponentName target.setComponent(new ComponentName(serviceInfo.packageName, serviceInfo.name)); String pluginLocation = mPluginManager.getLoadedPlugin(target.getComponent()).getLocation(); // start delegate service to run plugin service inside boolean local = PluginUtil.isLocalService(serviceInfo); Class&lt;? extends Service&gt; delegate = local ? LocalService.class : RemoteService.class; Intent intent = new Intent(); intent.setClass(mPluginManager.getHostContext(), delegate); intent.putExtra(RemoteService.EXTRA_TARGET, target); intent.putExtra(RemoteService.EXTRA_COMMAND, command); intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation); if (extras != null) &#123; intent.putExtras(extras); &#125; return intent;&#125; 果不其然，重新初始化了Intent，设置了目标类为LocalService（多进程时设置为RemoteService），然后将原本的Intent存储到EXTRA_TARGET，携带command为EXTRA_COMMAND_START_SERVICE，以及插件apk路径。 （2）代理分发那么接下来代码就到了LocalService的onStartCommond中啦： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic int onStartCommand(Intent intent, int flags, int startId) &#123; // 省略一些代码... Intent target = intent.getParcelableExtra(EXTRA_TARGET); int command = intent.getIntExtra(EXTRA_COMMAND, 0); if (null == target || command &lt;= 0) &#123; return START_STICKY; &#125; ComponentName component = target.getComponent(); LoadedPlugin plugin = mPluginManager.getLoadedPlugin(component); switch (command) &#123; case EXTRA_COMMAND_START_SERVICE: &#123; ActivityThread mainThread = (ActivityThread)ReflectUtil.getActivityThread(getBaseContext()); IApplicationThread appThread = mainThread.getApplicationThread(); Service service; if (this.mPluginManager.getComponentsHandler().isServiceAvailable(component)) &#123; service = this.mPluginManager.getComponentsHandler().getService(component); &#125; else &#123; try &#123; service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance(); Application app = plugin.getApplication(); IBinder token = appThread.asBinder(); Method attach = service.getClass().getMethod("attach", Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class); IActivityManager am = mPluginManager.getActivityManager(); attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am); service.onCreate(); this.mPluginManager.getComponentsHandler().rememberService(component, service); &#125; catch (Throwable t) &#123; return START_STICKY; &#125; &#125; service.onStartCommand(target, 0, this.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement()); break; &#125; // 省略下面的代码 case EXTRA_COMMAND_BIND_SERVICE:break; case EXTRA_COMMAND_STOP_SERVICE:break; case EXTRA_COMMAND_UNBIND_SERVICE:break;&#125; 这里代码很简单了，根据command类型，比如EXTRA_COMMAND_START_SERVICE，直接通过plugin的ClassLoader去load目标Service的class，然后反射创建实例。比较重要的是，Service创建好后，需要调用它的attach方法，这里凑够参数，然后反射调用即可，最后调用onCreate、onStartCommand收工。然后将其保存起来，stop的时候取出来调用其onDestroy即可。 bind、unbind以及stop的代码与上述基本一致，不在赘述。 唯一提醒的就是，刚才看到还hook了一个方法叫做：stopServiceToken，该方法是什么时候用的呢？ 主要有一些特殊的Service，比如IntentService，其stopSelf是由自身调用的，最终会调用mActivityManager.stopServiceToken方法，同样的中转为STOP操作即可。 四、BroadcastReceiver的支持这个比较简单，直接解析Manifest后，静态转动态即可。 相关代码在LoadedPlugin的构造方法中： 123456789101112for (PackageParser.Activity receiver : this.mPackage.receivers) &#123; receivers.put(receiver.getComponentName(), receiver.info); try &#123; BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance()); for (PackageParser.ActivityIntentInfo aii : receiver.intents) &#123; this.mHostContext.registerReceiver(br, aii); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 可以看到解析到receiver信息后，直接通过pluginClassloader去loadClass拿到receiver对象，然后调用this.mHostContext.registerReceiver即可。 开心，最后一个了~ 五、ContentProvider的支持（1）hook IContentProviderContentProvider的支持依然是通过代理分发。 看一段CP使用的代码： 1Cursor bookCursor = getContentResolver().query(bookUri, new String[]&#123;"_id", "name"&#125;, null, null, null); 这里用到了PluginContext，在生成Activity、Service的时候，为其设置的Context都为PluginContext对象。 所以当你调用getContentResolver时，调用的为PluginContext的getContentResolver。 1234@Overridepublic ContentResolver getContentResolver() &#123; return new PluginContentResolver(getHostContext());&#125; 返回的是一个PluginContentResolver对象，当我们调用query方法时，会辗转调用到ContentResolver.acquireUnstableProvider方法。该方法被PluginContentResolver中复写: 12345678910111213protected IContentProvider acquireUnstableProvider(Context context, String auth) &#123; try &#123; if (mPluginManager.resolveContentProvider(auth, 0) != null) &#123; return mPluginManager.getIContentProvider(); &#125; return (IContentProvider) sAcquireUnstableProvider.invoke(mBase, context, auth); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null;&#125; 如果调用的auth为插件apk中的provider，则直接返回mPluginManager.getIContentProvider()。 1234567public synchronized IContentProvider getIContentProvider() &#123; if (mIContentProvider == null) &#123; hookIContentProviderAsNeeded(); &#125; return mIContentProvider;&#125; 咦，又看到一个hook方法： 123456789101112131415161718192021222324252627282930313233343536373839private void hookIContentProviderAsNeeded() &#123; Uri uri = Uri.parse(PluginContentResolver.getUri(mContext)); mContext.getContentResolver().call(uri, "wakeup", null, null); try &#123; Field authority = null; Field mProvider = null; ActivityThread activityThread = (ActivityThread) ReflectUtil.getActivityThread(mContext); Map mProviderMap = (Map) ReflectUtil.getField(activityThread.getClass(), activityThread, "mProviderMap"); Iterator iter = mProviderMap.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); String auth; if (key instanceof String) &#123; auth = (String) key; &#125; else &#123; if (authority == null) &#123; authority = key.getClass().getDeclaredField("authority"); authority.setAccessible(true); &#125; auth = (String) authority.get(key); &#125; if (auth.equals(PluginContentResolver.getAuthority(mContext))) &#123; if (mProvider == null) &#123; mProvider = val.getClass().getDeclaredField("mProvider"); mProvider.setAccessible(true); &#125; IContentProvider rawProvider = (IContentProvider) mProvider.get(val); IContentProvider proxy = IContentProviderProxy.newInstance(mContext, rawProvider); mIContentProvider = proxy; Log.d(TAG, "hookIContentProvider succeed : " + mIContentProvider); break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 前两行比较重要，第一行是拿到了占坑的provider的uri，然后主动调用了其call方法。如果你跟进去，会发现，其会调用acquireProvider-&gt;mMainThread.acquireProvider-&gt;ActivityManagerNative.getDefault().getContentProvider-&gt;installProvider。简单来说，其首先调用已经注册provider，得到返回的IContentProvider对象。 这个IContentProvider对象是在ActivityThread.installProvider方法中加入到mProviderMap中。 而ActivityThread对象又容易获取，mProviderMap又是它成员变量，那么也容易获取，所以上面的一大坨（除了前两行）代码，就为了拿到占坑的provider对应的IContentProvider对象。 然后通过动态代理的方式，进行了hook，关注InvocationHandler的实例IContentProviderProxy。 IContentProvider能干吗呢？其实就能拦截我们正常的query、insert、update、delete等操作。 拦截这些方法干嘛？ 当然是修改uri啦，把用户调用的uri，替换为占坑provider的uri，再把原本的uri作为参数拼接在占坑provider的uri后面即可。 好了，直接看invoke方法： 1234567891011@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Log.v(TAG, method.toGenericString() + " : " + Arrays.toString(args)); wrapperUri(method, args); try &#123; return method.invoke(mBase, args); &#125; catch (InvocationTargetException e) &#123; throw e.getTargetException(); &#125;&#125; 直接看wrapperUri 123456789101112131415161718192021222324252627282930313233private void wrapperUri(Method method, Object[] args) &#123; Uri uri = null; int index = 0; if (args != null) &#123; for (int i = 0; i &lt; args.length; i++) &#123; if (args[i] instanceof Uri) &#123; uri = (Uri) args[i]; index = i; break; &#125; &#125; &#125; // 省略部分代码 PluginManager pluginManager = PluginManager.getInstance(mContext); ProviderInfo info = pluginManager.resolveContentProvider(uri.getAuthority(), 0); if (info != null) &#123; String pkg = info.packageName; LoadedPlugin plugin = pluginManager.getLoadedPlugin(pkg); String pluginUri = Uri.encode(uri.toString()); StringBuilder builder = new StringBuilder(PluginContentResolver.getUri(mContext)); builder.append("/?plugin=" + plugin.getLocation()); builder.append("&amp;pkg=" + pkg); builder.append("&amp;uri=" + pluginUri); Uri wrapperUri = Uri.parse(builder.toString()); if (method.getName().equals("call")) &#123; bundleInCallMethod.putString(KEY_WRAPPER_URI, wrapperUri.toString()); &#125; else &#123; args[index] = wrapperUri; &#125; &#125;&#125; 从参数中找到uri，往下看，搞了个StringBuilder首先加入占坑provider的uri，然后将目标uri，pkg,plugin等参数等拼接上去，替换到args中的uri，然后继续走原本的流程。 假设是query方法，应该就到达我们占坑provider的query方法啦。 （2）代理分发占坑如下： 1234&lt;provider android:name="com.didi.virtualapk.delegate.RemoteContentProvider" android:authorities="$&#123;applicationId&#125;.VirtualAPK.Provider" android:process=":daemon" /&gt; 打开RemoteContentProvider，直接看query方法： 123456789101112@Overridepublic Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; ContentProvider provider = getContentProvider(uri); Uri pluginUri = Uri.parse(uri.getQueryParameter(KEY_URI)); if (provider != null) &#123; return provider.query(pluginUri, projection, selection, selectionArgs, sortOrder); &#125; return null;&#125; 可以看到通过传入的生成了一个新的provider,然后拿到目标uri，在直接调用provider.query传入目标uri即可。 那么这个provider实际上是这个代理类帮我们生成的： 123456789101112131415161718192021222324252627282930313233private ContentProvider getContentProvider(final Uri uri) &#123; final PluginManager pluginManager = PluginManager.getInstance(getContext()); Uri pluginUri = Uri.parse(uri.getQueryParameter(KEY_URI)); final String auth = pluginUri.getAuthority(); // 省略了缓存管理 LoadedPlugin plugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG)); if (plugin == null) &#123; try &#123; pluginManager.loadPlugin(new File(uri.getQueryParameter(KEY_PLUGIN))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; final ProviderInfo providerInfo = pluginManager.resolveContentProvider(auth, 0); if (providerInfo != null) &#123; RunUtil.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; try &#123; LoadedPlugin loadedPlugin = pluginManager.getLoadedPlugin(uri.getQueryParameter(KEY_PKG)); ContentProvider contentProvider = (ContentProvider) Class.forName(providerInfo.name).newInstance(); contentProvider.attachInfo(loadedPlugin.getPluginContext(), providerInfo); sCachedProviders.put(auth, contentProvider); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;, true); return sCachedProviders.get(auth); &#125; return null;&#125; 很简单，取出原本的uri，拿到auth，在通过加载plugin得到providerInfo，反射生成provider对象，在调用其attachInfo方法即可。 其他的几个方法：insert、update、delete、call逻辑基本相同，就不赘述了。 感觉这里其实通过hook AMS的getContentProvider方法也能完成上述流程，感觉好像可以更彻底，不需要依赖PluginContext了。 六、总结总结下，其实就是文初的内容，可以看到VritualApk大体方案如下： Activity：在宿主apk中提前占几个坑，然后通过“欺上瞒下”（这个词好像是360之前的ppt中提到）的方式，启动插件apk的Activity；因为要支持不同的launchMode以及一些特殊的属性，需要占多个坑。 Service：通过代理Service的方式去分发；主进程和其他进程，VirtualAPK使用了两个代理Service。 BroadcastReceiver：静态转动态。 ContentProvider：通过一个代理Provider进行分发。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APP的启动过程]]></title>
    <url>%2F2018%2F06%2F07%2FAPP%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、流程概述 启动流程：①点击桌面App图标，Launcher进程采用Binder IPC向system_server进程发起startActivity请求； ②system_server进程接收到请求后，向zygote进程发送创建进程的请求； ③Zygote进程fork出新的子进程，即App进程； ④App进程，通过Binder IPC向sytem_server进程发起attachApplication请求； ⑤system_server进程在收到请求后，进行一系列准备工作后，再通过binder IPC向App进程发送scheduleLaunchActivity请求； ⑥App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送LAUNCH_ACTIVITY消息； ⑦主线程在收到Message后，通过发射机制创建目标Activity，并回调Activity.onCreate()等方法。 ⑧到此，App便正式启动，开始进入Activity生命周期，执行完onCreate/onStart/onResume方法，UI渲染结束后便可以看到App的主界面。 上面的一些列步骤简单介绍了一个APP启动到主页面显示的过程，可能这些流程中的一些术语看的有些懵，什么是Launcher，什么是zygote，什么是applicationThread….. 下面我们一一介绍。 二、理论基础1.zygotezygote意为“受精卵“。Android是基于Linux系统的，而在Linux中，所有的进程都是由init进程直接或者是间接fork出来的，zygote进程也不例外。 在Android系统里面，zygote是一个进程的名字。Android是基于Linux System的，当你的手机开机的时候，Linux的内核加载完成之后就会启动一个叫“init“的进程。在Linux System里面，所有的进程都是由init进程fork出来的，我们的zygote进程也不例外。 我们都知道，每一个App其实都是 ● 一个单独的dalvik虚拟机 ● 一个单独的进程 所以当系统里面的第一个zygote进程运行之后，在这之后再开启App，就相当于开启一个新的进程。而为了实现资源共用和更快的启动速度，Android系统开启新进程的方式，是通过fork第一个zygote进程实现的。所以说，除了第一个zygote进程，其他应用所在的进程都是zygote的子进程，这下你明白为什么这个进程叫“受精卵”了吧？因为就像是一个受精卵一样，它能快速的分裂，并且产生遗传物质一样的细胞！ 2.system_serverSystemServer也是一个进程，而且是由zygote进程fork出来的。 知道了SystemServer的本质，我们对它就不算太陌生了，这个进程是Android Framework里面两大非常重要的进程之一——另外一个进程就是上面的zygote进程。 为什么说SystemServer非常重要呢？因为系统里面重要的服务都是在这个进程里面开启的，比如ActivityManagerService、PackageManagerService、WindowManagerService等等。 3.ActivityManagerServiceActivityManagerService，简称AMS，服务端对象，负责系统中所有Activity的生命周期。 ActivityManagerService进行初始化的时机很明确，就是在SystemServer进程开启的时候，就会初始化ActivityManagerService。 下面介绍下Android系统里面的服务器和客户端的概念。其实服务器客户端的概念不仅仅存在于Web开发中，在Android的框架设计中，使用的也是这一种模式。服务器端指的就是所有App共用的系统服务，比如我们这里提到的ActivityManagerService，和前面提到的PackageManagerService、WindowManagerService等等，这些基础的系统服务是被所有的App公用的，当某个App想实现某个操作的时候，要告诉这些系统服务，比如你想打开一个App，那么我们知道了包名和MainActivity类名之后就可以打开 12345Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER); ComponentName cn = new ComponentName(packageName, className); intent.setComponent(cn); startActivity(intent); 但是，我们的App通过调用startActivity()并不能直接打开另外一个App，这个方法会通过一系列的调用，最后还是告诉AMS说：“我要打开这个App，我知道他的住址和名字，你帮我打开吧！”所以是AMS来通知zygote进程来fork一个新进程，来开启我们的目标App的。这就像是浏览器想要打开一个超链接一样，浏览器把网页地址发送给服务器，然后还是服务器把需要的资源文件发送给客户端的。 知道了Android Framework的客户端服务器架构之后，我们还需要了解一件事情，那就是我们的App和AMS(SystemServer进程)还有zygote进程分属于三个独立的进程，他们之间如何通信呢？ App与AMS通过Binder进行IPC通信，AMS(SystemServer进程)与zygote通过Socket进行IPC通信。后面具体介绍。 那么AMS有什么用呢？在前面我们知道了，如果想打开一个App的话，需要AMS去通知zygote进程，除此之外，其实所有的Activity的开启、暂停、关闭都需要AMS来控制，所以我们说，AMS负责系统中所有Activity的生命周期。 在Android系统中，任何一个Activity的启动都是由AMS和应用程序进程（主要是ActivityThread）相互配合来完成的。AMS服务统一调度系统中所有进程的Activity启动，而每个Activity的启动过程则由其所属的进程具体来完成。 4.Launcher当我们点击手机桌面上的图标的时候，App就由Launcher开始启动了。但是，你有没有思考过Launcher到底是一个什么东西？ Launcher本质上也是一个应用程序，和我们的App一样，也是继承自Activity packages/apps/Launcher2/src/com/android/launcher2/Launcher.java 1234public final class Launcher extends Activity implements View.OnClickListener, OnLongClickListener, LauncherModel.Callbacks, View.OnTouchListener &#123; &#125; Launcher实现了点击、长按等回调接口，来接收用户的输入。既然是普通的App，那么我们的开发经验在这里就仍然适用，比如，我们点击图标的时候，是怎么开启的应用呢？捕捉图标点击事件，然后startActivity()发送对应的Intent请求呗！是的，Launcher也是这么做的，就是这么easy！ 5.Instrumentation和ActivityThread每个Activity都持有Instrumentation对象的一个引用，但是整个进程只会存在一个Instrumentation对象。Instrumentation这个类里面的方法大多数和Application和Activity有关，这个类就是完成对Application和Activity初始化和生命周期的工具类。Instrumentation这个类很重要，对Activity生命周期方法的调用根本就离不开他，他可以说是一个大管家。 ActivityThread，依赖于UI线程。App和AMS是通过Binder传递信息的，那么ActivityThread就是专门与AMS的外交工作的。 6.ApplicationThread前面我们已经知道了App的启动以及Activity的显示都需要AMS的控制，那么我们便需要和服务端的沟通，而这个沟通是双向的。 客户端–&gt;服务端 而且由于继承了同样的公共接口类，ActivityManagerProxy提供了与ActivityManagerService一样的函数原型，使用户感觉不出Server是运行在本地还是远端，从而可以更加方便的调用这些重要的系统服务。 服务端–&gt;客户端 还是通过Binder通信，不过是换了另外一对，换成了ApplicationThread和ApplicationThreadProxy。 他们也都实现了相同的接口IApplicationThread 12345private class ApplicationThread extends ApplicationThreadNative &#123;&#125;public abstract class ApplicationThreadNative extends Binder implements IApplicationThread&#123;&#125;class ApplicationThreadProxy implements IApplicationThread &#123;&#125; 好了，前面罗里吧嗦的一大堆，介绍了一堆名词，可能不太清楚，没关系，下面结合流程图介绍。 三、启动流程1.创建进程①先从Launcher的startActivity()方法，通过Binder通信，调用ActivityManagerService的startActivity方法。 ②一系列折腾，最后调用startProcessLocked()方法来创建新的进程。 ③该方法会通过前面讲到的socket通道传递参数给Zygote进程。Zygote孵化自身。调用ZygoteInit.main()方法来实例化ActivityThread对象并最终返回新进程的pid。 ④调用ActivityThread.main()方法，ActivityThread随后依次调用Looper.prepareLoop()和Looper.loop()来开启消息循环。 方法调用流程图如下: 更直白的流程解释： ①App发起进程：当从桌面启动应用，则发起进程便是Launcher所在进程；当从某App内启动远程进程，则发送进程便是该App所在进程。发起进程先通过binder发送消息给system_server进程； ②system_server进程：调用Process.start()方法，通过socket向zygote进程发送创建新进程的请求； ③zygote进程：在执行ZygoteInit.main()后便进入runSelectLoop()循环体内，当有客户端连接时便会执行ZygoteConnection.runOnce()方法，再经过层层调用后fork出新的应用进程； ④新进程：执行handleChildProc方法，最后调用ActivityThread.main()方法。 2.绑定Application上面创建进程后，执行ActivityThread.main()方法，随后调用attach()方法。 将进程和指定的Application绑定起来。这个是通过上节的ActivityThread对象中调用bindApplication()方法完成的。该方法发送一个BIND_APPLICATION的消息到消息队列中, 最终通过handleBindApplication()方法处理该消息. 然后调用makeApplication()方法来加载App的classes到内存中。 方法调用流程图如下： 更直白的流程解释： （如果看不懂AMS,ATP等名词，后面有解释） 3.显示Activity界面经过前两个步骤之后, 系统已经拥有了该application的进程。 后面的调用顺序就是普通的从一个已经存在的进程中启动一个新进程的activity了。 实际调用方法是realStartActivity(), 它会调用application线程对象中的scheduleLaunchActivity()发送一个LAUNCH_ACTIVITY消息到消息队列中, 通过 handleLaunchActivity()来处理该消息。在 handleLaunchActivity()通过performLaunchActiivty()方法回调Activity的onCreate()方法和onStart()方法，然后通过handleResumeActivity()方法，回调Activity的onResume()方法，最终显示Activity界面。 更直白的流程解释： 四、Binder通信 简称:ATP: ApplicationThreadProxy AT: ApplicationThread AMP: ActivityManagerProxy AMS: ActivityManagerService 图解:①system_server进程中调用startProcessLocked方法,该方法最终通过socket方式,将需要创建新进程的消息告知Zygote进程,并阻塞等待Socket返回新创建进程的pid; ②Zygote进程接收到system_server发送过来的消息, 则通过fork的方法，将zygote自身进程复制生成新的进程，并将ActivityThread相关的资源加载到新进程app process,这个进程可能是用于承载activity等组件; ③ 在新进程app process向servicemanager查询system_server进程中binder服务端AMS, 获取相对应的Client端,也就是AMP. 有了这一对binder c/s对, 那么app process便可以通过binder向跨进程system_server发送请求,即attachApplication() ④system_server进程接收到相应binder操作后,经过多次调用,利用ATP向app process发送binder请求, 即bindApplication.system_server拥有ATP/AMS, 每一个新创建的进程都会有一个相应的AT/AMP,从而可以跨进程 进行相互通信. 这便是进程创建过程的完整生态链。 以上大概介绍了一个APP从启动到主页面显示经历的流程，主要从宏观角度介绍了其过程，具体可结合源码理解。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parcelable和Serializable的区别]]></title>
    <url>%2F2018%2F06%2F07%2FParcelable%E5%92%8CSerializable%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[本文主要介绍Parcelable和Serializable的作用、效率、区别及选择。 1、作用 Serializable的作用是为了保存对象的属性到本地文件、数据库、网络流、rmi以方便数据传输，当然这种传输可以是程序内的也可以是两个程序间的。而Android的Parcelable的设计初衷是因为Serializable效率过慢，为了在程序内不同组件间以及不同Android程序间(AIDL)高效的传输数据而设计，这些数据仅在内存中存在，Parcelable是通过IBinder通信的消息的载体。 从上面的设计上我们就可以看出优劣了。 2、效率及选择 Parcelable的性能比Serializable好，在内存开销方面较小，所以在内存间数据传输时推荐使用Parcelable，如activity间传输数据，而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable，因为android不同版本Parcelable可能不同，所以不推荐使用Parcelable进行数据持久化 3、编程实现 对于Serializable，类只需要实现Serializable接口，并提供一个序列化版本id(serialVersionUID)即可。而Parcelable则需要实现writeToParcel、describeContents函数以及静态的CREATOR变量，实际上就是将如何打包和解包的工作自己来定义，而序列化的这些操作完全由底层实现。 Parcelable的一个实现例子如下 1234567891011121314151617181920212223242526272829303132public class MyParcelable implements Parcelable &#123; private int mData; private String mStr; public int describeContents() &#123; return 0; &#125; // 写数据进行保存 public void writeToParcel(Parcel out, int flags) &#123; out.writeInt(mData); out.writeString(mStr); &#125; // 用来创建自定义的Parcelable的对象 public static final Parcelable.Creator&lt;MyParcelable&gt; CREATOR = new Parcelable.Creator&lt;MyParcelable&gt;() &#123; public MyParcelable createFromParcel(Parcel in) &#123; return new MyParcelable(in); &#125; public MyParcelable[] newArray(int size) &#123; return new MyParcelable[size]; &#125; &#125;; // 读数据进行恢复 private MyParcelable(Parcel in) &#123; mData = in.readInt(); mStr = in.readString(); &#125; &#125; 从上面我们可以看出Parcel的写入和读出顺序是一致的。如果元素是list读出时需要先new一个ArrayList传入，否则会报空指针异常。如下： 12list = new ArrayList&lt;String&gt;();in.readStringList(list); PS: 在自己使用时，read数据时误将前面int数据当作long读出，结果后面的顺序错乱，报如下异常，当类字段较多时务必保持写入和读取的类型及顺序一致。 111-21 20:14:10.317: E/AndroidRuntime(21114): Caused by: java.lang.RuntimeException: Parcel android.os.Parcel@4126ed60: Unmarshalling unknown type code 3014773 at offset 164 4、高级功能上 Serializable序列化不保存静态变量，可以使用Transient关键字对部分字段不进行序列化，也可以覆盖writeObject、readObject方法以实现序列化过程自定义]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Parcelable</tag>
        <tag>Serializable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Binder机制及AIDL使用]]></title>
    <url>%2F2018%2F06%2F07%2FBinder%E6%9C%BA%E5%88%B6%E5%8F%8AAIDL%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Binder原理1、概述Android系统中，涉及到多进程间的通信底层都是依赖于Binder IPC机制。例如当进程A中的Activity要向进程B中的Service通信，这便需要依赖于Binder IPC。不仅于此，整个Android系统架构中，大量采用了Binder机制作为IPC（进程间通信）方案。 当然也存在部分其他的IPC方式，如管道、SystemV、Socket等。那么Android为什么不使用这些原有的技术，而是要使开发一种新的叫Binder的进程间通信机制呢？ 为什么要使用Binder？性能方面 在移动设备上（性能受限制的设备，比如要省电），广泛地使用跨进程通信对通信机制的性能有严格的要求，Binder相对出传统的Socket方式，更加高效。Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，共享内存方式一次内存拷贝都不需要，但实现方式又比较复杂。 安全方面 传统的进程通信方式对于通信双方的身份并没有做出严格的验证，比如Socket通信ip地址是客户端手动填入，很容易进行伪造，而Binder机制从协议本身就支持对通信双方做身份校检，因而大大提升了安全性。 2、 BinderIPC原理从进程角度来看IPC机制 每个Android的进程，只能运行在自己进程所拥有的虚拟地址空间。对应一个4GB的虚拟地址空间，其中3GB是用户空间，1GB是内核空间，当然内核空间的大小是可以通过参数配置调整的。对于用户空间，不同进程之间彼此是不能共享的，而内核空间却是可共享的。Client进程向Server进程通信，恰恰是利用进程间可共享的内核内存空间来完成底层通信工作的，Client端与Server端进程往往采用ioctl等方法跟内核空间的驱动进行交互。 Binder原理Binder通信采用C/S架构，从组件视角来说，包含Client、Server、ServiceManager以及binder驱动，其中ServiceManager用于管理系统中的各种服务。架构图如下所示： Binder通信的四个角色 Client进程：使用服务的进程。 Server进程：提供服务的进程。 ServiceManager进程：ServiceManager的作用是将字符形式的Binder名字转化成Client中对该Binder的引用，使得Client能够通过Binder名字获得对Server中Binder实体的引用。 Binder驱动：驱动负责进程之间Binder通信的建立，Binder在进程之间的传递，Binder引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。 Binder运行机制 图中Client/Server/ServiceManage之间的相互通信都是基于Binder机制。既然基于Binder机制通信，那么同样也是C/S架构，则图中的3大步骤都有相应的Client端与Server端。 注册服务(addService)：Server进程要先注册Service到ServiceManager。该过程：Server是客户端，ServiceManager是服务端。 获取服务(getService)：Client进程使用某个Service前，须先向ServiceManager中获取相应的Service。该过程：Client是客户端，ServiceManager是服务端。 使用服务：Client根据得到的Service信息建立与Service所在的Server进程通信的通路，然后就可以直接与Service交互。该过程：client是客户端，server是服务端。 图中的Client,Server,Service Manager之间交互都是虚线表示，是由于它们彼此之间不是直接交互的，而是都通过与Binder驱动进行交互的，从而实现IPC通信方式。其中Binder驱动位于内核空间，Client,Server,Service Manager位于用户空间。Binder驱动和Service Manager可以看做是Android平台的基础架构，而Client和Server是Android的应用层，开发人员只需自定义实现client、Server端，借助Android的基本平台架构便可以直接进行IPC通信。 Binder运行的实例解释 首先我们看看我们的程序跨进程调用系统服务的简单示例，实现浮动窗口部分代码： 123456//获取WindowManager服务引用WindowManager wm = (WindowManager)getSystemService(getApplication().WINDOW_SERVICE); //布局参数layoutParams相关设置略...View view=LayoutInflater.from(getApplication()).inflate(R.layout.float_layout, null); //添加viewwm.addView(view, layoutParams); 注册服务(addService)：在Android开机启动过程中，Android会初始化系统的各种Service，并将这些Service向ServiceManager注册（即让ServiceManager管理）。这一步是系统自动完成的。 获取服务(getService)：客户端想要得到具体的Service直接向ServiceManager要即可。客户端首先向ServiceManager查询得到具体的Service引用，通常是Service引用的代理对象，对数据进行一些处理操作。即第2行代码中，得到的wm是WindowManager对象的引用。 使用服务：通过这个引用向具体的服务端发送请求，服务端执行完成后就返回。即第6行调用WindowManager的addView函数，将触发远程调用，调用的是运行在systemServer进程中的WindowManager的addView函数。 使用服务的具体执行过程 client通过获得一个server的代理接口，对server进行调用。 代理接口中定义的方法与server中定义的方法是一一对应的。 client调用某个代理接口中的方法时，代理接口的方法会将client传递的参数打包成Parcel对象。 代理接口将Parcel发送给内核中的binder driver。 server会读取binder driver中的请求数据，如果是发送给自己的，解包Parcel对象，处理并将结果返回。 整个的调用过程是一个同步过程，在server处理的时候，client会block住。因此client调用过程不应在主线程。 AIDL的使用1.AIDL的简介AIDL (Android Interface Definition Language) 是一种接口定义语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数，来完成进程间通信。 简言之，AIDL能够实现进程间通信，其内部是通过Binder机制来实现的，后面会具体介绍，现在先介绍AIDL的使用。 2.AIDL的具体使用AIDL的实现一共分为三部分，一部分是客户端，调用远程服务。一部分是服务端，提供服务。最后一部分，也是最关键的是AIDL接口，用来传递的参数，提供进程间通信。 先在服务端创建AIDL部分代码。 AIDL文件通过如下方式新建一个AIDL文件 默认生成格式 12345678interface IBookManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString);&#125; 默认如下格式，由于本例要操作Book类，实现两个方法，添加书本和返回书本列表。 定义一个Book类，实现Parcelable接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Book implements Parcelable &#123; public int bookId; public String bookName; public Book() &#123; &#125; public Book(int bookId, String bookName) &#123; this.bookId = bookId; this.bookName = bookName; &#125; public int getBookId() &#123; return bookId; &#125; public void setBookId(int bookId) &#123; this.bookId = bookId; &#125; public String getBookName() &#123; return bookName; &#125; public void setBookName(String bookName) &#123; this.bookName = bookName; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeInt(this.bookId); dest.writeString(this.bookName); &#125; protected Book(Parcel in) &#123; this.bookId = in.readInt(); this.bookName = in.readString(); &#125; public static final Parcelable.Creator&lt;Book&gt; CREATOR = new Parcelable.Creator&lt;Book&gt;() &#123; @Override public Book createFromParcel(Parcel source) &#123; return new Book(source); &#125; @Override public Book[] newArray(int size) &#123; return new Book[size]; &#125; &#125;;&#125; 由于AIDL只支持数据类型:基本类型（int,long,char,boolean等）,String,CharSequence,List,Map，其他类型必须使用import导入，即使它们可能在同一个包里，比如上面的Book。 最终IBookManager.aidl 的实现 12345678910111213141516// Declare any non-default types here with import statementsimport com.lvr.aidldemo.Book;interface IBookManager &#123; /** * Demonstrates some basic types that you can use as parameters * and return values in AIDL. */ void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString); void addBook(in Book book); List&lt;Book&gt; getBookList();&#125; 注意：如果自定义的Parcelable对象，必须创建一个和它同名的AIDL文件，并在其中声明它为parcelable类型。 Book.aidl 1234// Book.aidlpackage com.lvr.aidldemo;parcelable Book; 以上就是AIDL部分的实现，一共三个文件。 然后Make Project ，SDK为自动为我们生成对应的Binder类。 在如下路径下： 其中该接口中有个重要的内部类Stub ，继承了Binder 类，同时实现了IBookManager接口。这个内部类是接下来的关键内容。 1public static abstract class Stub extends android.os.Binder implements com.lvr.aidldemo.IBookManager&#123;&#125; 服务端服务端首先要创建一个Service用来监听客户端的连接请求。然后在Service中实现Stub 类，并定义接口中方法的具体实现。 1234567891011121314151617181920//实现了AIDL的抽象函数 private IBookManager.Stub mbinder = new IBookManager.Stub() &#123; @Override public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123; //什么也不做 &#125; @Override public void addBook(Book book) throws RemoteException &#123; //添加书本 if(!mBookList.contains(book))&#123; mBookList.add(book); &#125; &#125; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; &#125;; 当客户端连接服务端，服务端就会调用如下方法： 123public IBinder onBind(Intent intent) &#123; return mbinder; &#125; 就会把Stub实现对象返回给客户端，该对象是个Binder对象，可以实现进程间通信。本例就不真实模拟两个应用之间的通信，而是让Service另外开启一个进程来模拟进程间通信。 12345678&lt;service android:name=".MyService" android:process=":remote"&gt; &lt;intent-filter&gt; &lt;category android:name="android.intent.category.DEFAULT"/&gt; &lt;action android:name="com.lvr.aidldemo.MyService"/&gt; &lt;/intent-filter&gt; &lt;/service&gt; android:process=&quot;:remote&quot;设置为另一个进程。&lt;action android:name=&quot;com.lvr.aidldemo.MyService&quot;/&gt;是为了能让其他apk隐式bindService。通过隐式调用的方式来连接service，需要把category设为default，这是因为，隐式调用的时候，intent中的category默认会被设置为default。 客户端 首先将服务端工程中的aidl文件夹下的内容整个拷贝到客户端工程的对应位置下，由于本例的使用在一个应用中，就不需要拷贝了，其他情况一定不要忘记这一步。 客户端需要做的事情比较简单，首先需要绑定服务端的Service。 123456Intent intentService = new Intent();intentService.setAction("com.lvr.aidldemo.MyService");intentService.setPackage(getPackageName());intentService.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);MyClient.this.bindService(intentService, mServiceConnection, BIND_AUTO_CREATE);Toast.makeText(getApplicationContext(),"绑定了服务",Toast.LENGTH_SHORT).show(); 将服务端返回的Binder对象转换成AIDL接口所属的类型，接着就可以调用AIDL中的方法了。 12345678if(mIBookManager!=null)&#123; try &#123; mIBookManager.addBook(new Book(18,"新添加的书")); Toast.makeText(getApplicationContext(),mIBookManager.getBookList().size()+"",Toast.LENGTH_SHORT).show(); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; 3.AIDL的工作原理Binder机制的运行主要包括三个部分：注册服务、获取服务和使用服务。其中注册服务和获取服务的流程涉及C的内容，由于个人能力有限，就不予介绍了。 本篇文章主要介绍使用服务时,AIDL的工作原理。 ①.Binder对象的获取Binder是实现跨进程通信的基础，那么Binder对象在服务端和客户端是共享的，是同一个Binder对象。在客户端通过Binder对象获取实现了IInterface接口的对象来调用远程服务，然后通过Binder来实现参数传递。 那么如何维护实现了IInterface接口的对象和获取Binder对象呢？ 服务端获取Binder对象并保存IInterface接口对象Binder中两个关键方法： 12345 public class Binder implement IBinder&#123; void attachInterface(IInterface plus, String descriptor) IInterface queryLocalInterface(Stringdescriptor) //从IBinder中继承而来 ..........................&#125; Binder具有被跨进程传输的能力是因为它实现了IBinder接口。系统会为每个实现了该接口的对象提供跨进程传输，这是系统给我们的一个很大的福利。 Binder具有的完成特定任务的能力是通过它的IInterface的对象获得的，我们可以简单理解attachInterface方法会将（descriptor，plus）作为（key,value）对存入Binder对象中的一个Map对象中，Binder对象可通过attachInterface方法持有一个IInterface对象（即plus）的引用，并依靠它获得完成特定任务的能力。queryLocalInterface方法可以认为是根据key值（即参数 descriptor）查找相应的IInterface对象。 在服务端进程，通过实现private IBookManager.Stub mbinder = new IBookManager.Stub() {}抽象类，获得Binder对象。并保存了IInterface对象。 1234public Stub()&#123;this.attachInterface(this, DESCRIPTOR);&#125; 客户端获取Binder对象并获取IInterface接口对象 通过bindService获得Binder对象 1MyClient.this.bindService(intentService, mServiceConnection, BIND_AUTO_CREATE); 然后通过Binder对象获得IInterface对象。 123456789101112private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder binder) &#123; //通过服务端onBind方法返回的binder对象得到IBookManager的实例，得到实例就可以调用它的方法了 mIBookManager = IBookManager.Stub.asInterface(binder); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mIBookManager = null; &#125; &#125;; 其中asInterface(binder)方法如下： 1234567891011public static com.lvr.aidldemo.IBookManager asInterface(android.os.IBinder obj)&#123;if ((obj==null)) &#123;return null;&#125;android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);if (((iin!=null)&amp;&amp;(iin instanceof com.lvr.aidldemo.IBookManager))) &#123;return ((com.lvr.aidldemo.IBookManager)iin);&#125;return new com.lvr.aidldemo.IBookManager.Stub.Proxy(obj);&#125; 先通过queryLocalInterface(DESCRIPTOR);查找到对应的IInterface对象，然后判断对象的类型，如果是同一个进程调用则返回IBookManager对象，由于是跨进程调用则返回Proxy对象，即Binder类的代理对象。 ②.调用服务端方法获得了Binder类的代理对象，并且通过代理对象获得了IInterface对象，那么就可以调用接口的具体实现方法了，来实现调用服务端方法的目的。 以addBook方法为例，调用该方法后，客户端线程挂起，等待唤醒： 123456789101112@Override public void addBook(com.lvr.aidldemo.Book book) throws android.os.RemoteException&#123;..........//第一个参数：识别调用哪一个方法的ID//第二个参数：Book的序列化传入数据//第三个参数：调用方法后返回的数据//最后一个不用管mRemote.transact(Stub.TRANSACTION_addBook, _data, _reply, 0);_reply.readException();&#125;..........&#125; 省略部分主要完成对添加的Book对象进行序列化工作，然后调用transact方法。 Proxy对象中的transact调用发生后，会引起系统的注意，系统意识到Proxy对象想找它的真身Binder对象（系统其实一直存着Binder和Proxy的对应关系）。于是系统将这个请求中的数据转发给Binder对象，Binder对象将会在onTransact中收到Proxy对象传来的数据，于是它从data中取出客户端进程传来的数据，又根据第一个参数确定想让它执行添加书本操作，于是它就执行了响应操作，并把结果写回reply。代码概略如下： 123456789101112131415case TRANSACTION_addBook:&#123;data.enforceInterface(DESCRIPTOR);com.lvr.aidldemo.Book _arg0;if ((0!=data.readInt())) &#123;_arg0 = com.lvr.aidldemo.Book.CREATOR.createFromParcel(data);&#125;else &#123;_arg0 = null;&#125;//这里调用服务端实现的addBook方法this.addBook(_arg0);reply.writeNoException();return true;&#125; 然后在transact方法获得_reply并返回结果，本例中的addList方法没有返回值。 客户端线程被唤醒。因此调用服务端方法时，应开启子线程，防止UI线程堵塞，导致ANR。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Binder</tag>
        <tag>AIDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android布局优化之include、merge、ViewStub的使用]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%E4%B9%8Binclude%E3%80%81merge%E3%80%81ViewStub%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、&lt;include/&gt;标签在布局优化中是使用最多的一个标签了，它就是为了解决重复定义布局的问题。标签就相当于C、C++中的include头文件一样，把一些常用的底层的API封装起来，需要的时候引入即可。在一些开源的J2EE中许多XML配置文件也都会使用标签，将多个配置文件组合成为一个更为复杂的配置文件，如最常见的S2SH。 在以前Android开发中，由于ActionBar设计上的不统一以及兼容性问题，所以很多应用都自定义了一套自己的标题栏titlebar。标题栏我们知道在应用的每个界面几乎都会用到，在这里可以作为一个很好的示例来解释标签的使用。 下面是一个自定义的titlebar文件： 123456789&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@color/titlebar_bg"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:src="@drawable/gafricalogo" /&gt;&lt;/FrameLayout&gt; 在应用中使用titlebar布局文件，我们通过标签,布局文件如下： 1234567891011121314151617&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@color/app_bg" android:gravity="center_horizontal"&gt; &lt;include layout="@layout/titlebar"/&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="wrap_content" android:text="@string/hello" android:padding="10dp" /&gt; ... &lt;/LinearLayout&gt; 在标签中可以覆盖导入的布局文件root布局的布局属性（如layout_*属性）。 布局示例如下： 1234&lt;include android:id="@+id/news_title" android:layout_width="match_parent" android:layout_height="match_parent" layout="@layout/title"/&gt; 如果想使用标签覆盖嵌入布局root布局属性，必须同时覆盖layout_height和layout_width属性，否则会直接报编译时语法错误。 Layout parameter layout_height ignored unless layout_width is also specified on tag 如果标签已经定义了id，而嵌入布局文件的root布局文件也定义了id，标签的id会覆盖掉嵌入布局文件root的id，如果include标签没有定义id则会使用嵌入文件root的id。 二、&lt;merge/&gt;标签都是与标签组合使用的，它的作用就是可以有效减少View树的层次来优化布局。 下面通过一个简单的示例探讨一下标签的使用，下面是嵌套布局的layout_text.xml文件： 12345678910&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;TextView android:id="@+id/textView" android:layout_width="match_parent" android:text="Hello World!" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 一个线性布局中嵌套一个文本视图，主布局如下： 12345678910111213&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/layout_wrap" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;include android:id="@+id/layout_import" android:layout_width="match_parent" android:layout_height="match_parent" layout="@layout/layout_text" /&gt; &lt;/LinearLayout&gt; 通过hierarchyviewer我们可以看到主布局View树的部分层级结构如下图： 现在讲嵌套布局跟布局标签更改为，merge_text.xml布局文件如下： 123456789&lt;merge xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;TextView android:id="@+id/textView" android:layout_width="match_parent" android:layout_height="match_parent" android:text="Hello World!"/&gt; &lt;/merge&gt; 然后将主布局标签中的layout更改为merge_text.xml，运行后重新截图如下: 对比截图就可以发现上面的四层结构，现在已经是三层结构了。当我们使用标签的时候，系统会自动忽略merge层级，而把TextView直接放置与平级。 标签在使用的时候需要特别注意布局的类型，例如我的标签中包含的是一个LinearLayout布局视图，布局中的元素是线性排列的，如果嵌套进主布局时，include标签父布局时FrameLayout，这种方式嵌套肯定会出问题的，merge中元素会按照FrameLayout布局方式显示。所以在使用的时候，标签虽然可以减少布局层级，但是它的限制也不可小觑。 只能作为XML布局的根标签使用。当Inflate以开头的布局文件时，必须指定一个父ViewGroup，并且必须设定attachToRoot为true。 View android.view.LayoutInflater.inflate(int resource, ViewGroup root, boolean attachToRoot) root不可少，attachToRoot必须为true。 三、ViewStub在开发过程中，经常会遇到这样一种情况，有些布局很复杂但是却很少使用。例如条目详情、进度条标识或者未读消息等，这些情况如果在一开始初始化，虽然设置可见性View.GONE,但是在Inflate的时候View仍然会被Inflate，仍然会创建对象，由于这些布局又想到复杂，所以会很消耗系统资源。 ViewStub就是为了解决上面问题的，ViewStub是一个轻量级的View，它一个看不见的，不占布局位置，占用资源非常小的控件。 定义ViewStub布局文件下面是一个ViewStub布局文件： 123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/layout_wrap" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" &gt; &lt;ViewStub android:id="@+id/stub_image" android:layout_width="match_parent" android:layout_height="wrap_content" android:inflatedId="@+id/image_import" android:layout="@layout/layout_image" /&gt; &lt;ViewStub android:id="@+id/stub_text" android:layout_width="match_parent" android:layout_height="wrap_content" android:inflatedId="@+id/text_import" android:layout="@layout/layout_text" /&gt; &lt;/LinearLayout&gt; layout_image.xml文件如下（layout_text.xml类似）： 1234567891011&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/layout_image"&gt; &lt;ImageView android:id="@+id/imageView" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; &lt;/LinearLayout&gt; 加载ViewStub布局文件动态加载ViewStub所包含的布局文件有两种方式，方式一使用使用inflate()方法，方式二就是使用setVisibility(View.VISIBLE)。 示例java代码如下： 1234567891011private ViewStub viewStub; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.layout_main2); viewStub = (ViewStub) findViewById(R.id.stub_image); //viewStub.inflate();//方式一 viewStub.setVisibility(View.VISIBLE);//方式二 ImageView imageView = (ImageView) findViewById(R.id.imageView); imageView.setImageResource(R.drawable.image);&#125; 示例View层级截图如下： ViewStub一旦visible/inflated,它自己就不在是View试图层级的一部分了。所以后面无法再使用ViewStub来控制布局，填充布局root布局如果有id，则会默认被android:inflatedId所设置的id取代，如果没有设置android:inflatedId，则会直接使用填充布局id。 由于ViewStub这种使用后即可就置空的策略，所以当需要在运行时不止一次的显示和隐藏某个布局，那么ViewStub是做不到的。这时就只能使用View的可见性来控制了。 layout_*相关属性与include标签相似，如果使用应该在ViewStub上面使用，否则使用在嵌套进来布局root上面无效。 ViewStub的另一个缺点就是目前还不支持merge标签。 四、小结Android布局优化基本上就设计上面include、merge、ViewStub三个标签的使用。在平常开发中布局推荐使用RelativeLayout，它也可以有效减少布局层级嵌套。最后了将merge和include源码附上，ViewStub就是一个View，就不贴出来了。 Include源码12345678910/** * Exercise &lt;include /&gt; tag in XML files. */public class Include extends Activity &#123; @Override protected void onCreate(Bundle icicle) &#123; super.onCreate(icicle); setContentView(R.layout.include_tag); &#125;&#125; Merge源码123456789101112131415161718192021/** * Exercise &lt;merge /&gt; tag in XML files. */public class Merge extends Activity &#123; private LinearLayout mLayout; @Override protected void onCreate(Bundle icicle) &#123; super.onCreate(icicle); mLayout = new LinearLayout(this); mLayout.setOrientation(LinearLayout.VERTICAL); LayoutInflater.from(this).inflate(R.layout.merge_tag, mLayout); setContentView(mLayout); &#125; public ViewGroup getLayout() &#123; return mLayout; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android内存泄漏总结]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Android 内存泄漏总结内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收 我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。 篇幅有些长，大家可以分几节来看！ Java 内存分配策略Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。 栈区 ：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。 栈与堆的区别：在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。 堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。 举个例子: 1234567891011public class Sample() &#123; int s1 = 0; Sample mSample1 = new Sample(); public void method() &#123; int s2 = 1; Sample mSample2 = new Sample(); &#125;&#125;Sample mSample3 = new Sample(); Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。 结论： 局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。 成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。 了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。 Java是如何管理内存Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。 监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。 为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。 Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。 什么是Java中的内存泄露在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。 在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。 通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。 因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。 对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。 同样给出一个 Java 内存泄漏的典型例子， 123456Vector v = new Vector(10);for (int i = 1; i &lt; 100; i++) &#123; Object o = new Object(); v.add(o); o = null; &#125; 在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。 Android中常见的内存泄漏汇总 集合类泄漏 集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。 单例造成的内存泄漏 由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子， 12345678910111213public class AppManager &#123; private static AppManager instance; private Context context; private AppManager(Context context) &#123; this.context = context; &#125; public static AppManager getInstance(Context context) &#123; if (instance == null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： 1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。 2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。 正确的方式应该改为下面这种方式： 12345678910111213public class AppManager &#123; private static AppManager instance; private Context context; private AppManager(Context context) &#123; this.context = context.getApplicationContext();// 使用Application 的context &#125; public static AppManager getInstance(Context context) &#123; if (instance == null) &#123; instance = new AppManager(context); &#125; return instance; &#125;&#125; 或者这样写，连 Context 都不用传进来了： 12345678910111213141516171819202122232425262728在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context，...context = getApplicationContext();... /** * 获取全局的context * @return 返回全局context对象 */ public static Context getContext()&#123; return context; &#125;public class AppManager &#123; private static AppManager instance; private Context context; private AppManager() &#123; this.context = MyApplication.getContext();// 使用Application 的context &#125; public static AppManager getInstance() &#123; if (instance == null) &#123; instance = new AppManager(); &#125; return instance; &#125;&#125; 匿名内部类/非静态内部类和异步线程 非静态内部类创建静态实例造成的内存泄漏 有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法： 123456789101112131415public class MainActivity extends AppCompatActivity &#123; private static TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mManager == null)&#123; mManager = new TestResource(); &#125; //... &#125; class TestResource &#123; //... &#125;&#125; 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为： 将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下： 其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建 匿名内部类 android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露 1234567891011public class MainActivity extends Activity &#123; ... Runnable ref1 = new MyRunable(); Runnable ref2 = new Runnable() &#123; @Override public void run() &#123; &#125; &#125;; ...&#125; ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存： 可以看到，ref1没什么特别的。但ref2这个匿名类的实现对象里面多了一个引用：this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。 Handler 造成的内存泄漏 Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。 举个例子： 1234567891011121314151617181920212223public class SampleActivity extends Activity &#123; private final Handler mLeakyHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; // ... &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mLeakyHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; 在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。 修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class SampleActivity extends Activity &#123; /** * Instances of static inner classes do not hold an implicit * reference to their outer class. */ private static class MyHandler extends Handler &#123; private final WeakReference&lt;SampleActivity&gt; mActivity; public MyHandler(SampleActivity activity) &#123; mActivity = new WeakReference&lt;SampleActivity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; SampleActivity activity = mActivity.get(); if (activity != null) &#123; // ... &#125; &#125; &#125; private final MyHandler mHandler = new MyHandler(this); /** * Instances of anonymous classes do not hold an implicit * reference to their outer class when they are "static". */ private static final Runnable sRunnable = new Runnable() &#123; @Override public void run() &#123; /* ... */ &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mHandler.postDelayed(sRunnable, 1000 * 60 * 10); // Go back to the previous Activity. finish(); &#125;&#125; 综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。 前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。 Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。 在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。 假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形： 首先定义一个HashMap，保存软引用对象。 1private Map &lt;String, SoftReference&lt;Bitmap&gt;&gt; imageCache = new HashMap &lt;String, SoftReference&lt;Bitmap&gt;&gt; (); 再来定义一个方法，保存Bitmap的软引用到HashMap。 使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。 如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。 下面几个方法都可以移除 Message： 123456789public final void removeCallbacks(Runnable r);public final void removeCallbacks(Runnable r, Object token);public final void removeCallbacksAndMessages(Object token);public final void removeMessages(int what);public final void removeMessages(int what, Object object); 尽量避免使用 static 成员变量 如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。 这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，因为如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。这里修复的方法是： 不要在类初始时初始化静态成员。可以考虑lazy初始化。架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。 避免 override finalize() 1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是： 虚拟机调用GC的时间不确定 Finalize daemon线程被调度到的时间不确定 2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是： 含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。 3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。 详情见这里 深入分析过dalvik的代码 资源未关闭造成的内存泄漏 对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。 一些不良代码造成的内存压力 有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。 比如： 构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。 工具分析Java 内存泄漏的分析工具有很多，但众所周知的要数 MAT(Memory Analysis Tools) 和 YourKit 了。由于篇幅问题，我这里就只对 MAT 的使用做一下介绍。–&gt; MAT 的安装 MAT分析heap的总内存占用大小来初步判断是否存在泄露 打开 DDMS 工具，在左边 Devices 视图页面选中“Update Heap”图标，然后在右边切换到 Heap 视图，点击 Heap 视图中的“Cause GC”按钮，到此为止需检测的进程就可以被监视。 Heap视图中部有一个Type叫做data object，即数据对象，也就是我们的程序中大量存在的类类型的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。可以这样判断： 进入某应用，不断的操作该应用，同时注意观察data object的Total Size值，正常情况下Total Size值都会稳定在一个有限的范围内，也就是说由于程序中的的代码良好，没有造成对象不被垃圾回收的情况。 所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平；反之如果代码中存在没有释放对象引用的情况，则data object的Total Size值在每次GC后不会有明显的回落。随着操作次数的增多Total Size的值会越来越大，直到到达一个上限后导致进程被杀掉。 MAT分析hprof来定位内存泄露的原因所在 这是出现内存泄露后使用MAT进行问题定位的有效手段。 A)Dump出内存泄露当时的内存镜像hprof，分析怀疑泄露的类： B)分析持有此类对象引用的外部对象 C)分析这些持有引用的对象的GC路径 D)逐个分析每个对象的GC路径是否正常 从这个路径可以看出是一个antiRadiationUtil工具类对象持有了MainActivity的引用导致MainActivity无法释放。此时就要进入代码分析此时antiRadiationUtil的引用持有是否合理（如果antiRadiationUtil持有了MainActivity的context导致节目退出后MainActivity无法销毁，那一般都属于内存泄露了）。 MAT对比操作前后的hprof来定位内存泄露的根因所在 为查找内存泄漏，通常需要两个 Dump结果作对比，打开 Navigator History面板，将两个表的 Histogram结果都添加到 Compare Basket中去 A） 第一个HPROF 文件(usingFile &gt; Open Heap Dump ). B）打开Histogram view. C）在NavigationHistory view里 (如果看不到就从Window &gt;show view&gt;MAT- Navigation History ), 右击histogram然后选择Add to Compare Basket . D）打开第二个HPROF 文件然后重做步骤2和3. E）切换到Compare Basket view, 然后点击Compare the Results (视图右上角的红色”!”图标)。 F）分析对比结果 可以看出两个hprof的数据对象对比结果。 通过这种方式可以快速定位到操作前后所持有的对象增量，从而进一步定位出当前操作导致内存泄露的具体原因是泄露了什么数据对象。 注意： 如果是用 MAT Eclipse 插件获取的 Dump文件，不需要经过转换则可在MAT中打开，Adt会自动进行转换。 而手机SDk Dump 出的文件要经过转换才能被 MAT识别，Android SDK提供了这个工具 hprof-conv (位于 sdk/tools下) 首先，要通过控制台进入到你的 android sdk tools 目录下执行以下命令： ./hprof-conv xxx-a.hprof xxx-b.hprof 例如 hprof-conv input.hprof out.hprof 此时才能将out.hprof放在eclipse的MAT中打开。 Ok，下面将给大家介绍一个屌炸天的工具 – LeakCanary 。 使用 LeakCanary 检测 Android 的内存泄漏什么是 LeakCanary 呢？为什么选择它来检测 Android 的内存泄漏呢？ 别急，让我来慢慢告诉大家！ LeakCanary 是国外一位大神 Pierre-Yves Ricau 开发的一个用于检测内存泄露的开源类库。一般情况下，在对战内存泄露中，我们都会经过以下几个关键步骤： 1、了解 OutOfMemoryError 情况。 2、重现问题。 3、在发生内存泄露的时候，把内存 Dump 出来。 4、在发生内存泄露的时候，把内存 Dump 出来。 5、计算这个对象到 GC roots 的最短强引用路径。 6、确定引用路径中的哪个引用是不该有的，然后修复问题。 很复杂对吧？ 如果有一个类库能在发生 OOM 之前把这些事情全部都搞定，然后你只要修复这些问题就好了。LeakCanary 做的就是这件事情。你可以在 debug 包中轻松检测内存泄露。 一起来看这个例子（摘自 LeakCanary 中文使用说明，下面会附上所有的参考文档链接）： 12345678910111213141516171819class Cat &#123;&#125;class Box &#123; Cat hiddenCat;&#125;class Docker &#123; // 静态变量，将不会被回收，除非加载 Docker 类的 ClassLoader 被回收。 static Box container;&#125;// ...Box box = new Box();// 薛定谔之猫Cat schrodingerCat = new Cat();box.hiddenCat = schrodingerCat;Docker.container = box; 创建一个RefWatcher，监控对象引用情况。 12// 我们期待薛定谔之猫很快就会消失（或者不消失），我们监控一下refWatcher.watch(schrodingerCat); 当发现有内存泄露的时候，你会看到一个很漂亮的 leak trace 报告: GC ROOT static Docker.container references Box.hiddenCat leaks Cat instance 我们知道，你很忙，每天都有一大堆需求。所以我们把这个事情弄得很简单，你只需要添加一行代码就行了。然后 LeakCanary 就会自动侦测 activity 的内存泄露了。 123456public class ExampleApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); LeakCanary.install(this); &#125;&#125; 然后你会在通知栏看到这样很漂亮的一个界面: 以很直白的方式将内存泄露展现在我们的面前。 Demo一个非常简单的 LeakCanary demo: 一个非常简单的 LeakCanary demo: https://github.com/liaohuqiu/leakcanary-demo 接入在 build.gradle 中加入引用，不同的编译使用不同的引用： 1234dependencies &#123; debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3'&#125; 如何使用使用 RefWatcher 监控那些本该被回收的对象。 1234RefWatcher refWatcher = &#123;...&#125;;// 监控refWatcher.watch(schrodingerCat); LeakCanary.install() 会返回一个预定义的 RefWatcher，同时也会启用一个 ActivityRefWatcher，用于自动监控调用 Activity.onDestroy() 之后泄露的 activity。 在Application中进行配置 ： 1234567891011121314public class ExampleApplication extends Application &#123; public static RefWatcher getRefWatcher(Context context) &#123; ExampleApplication application = (ExampleApplication) context.getApplicationContext(); return application.refWatcher; &#125; private RefWatcher refWatcher; @Override public void onCreate() &#123; super.onCreate(); refWatcher = LeakCanary.install(this); &#125;&#125; 使用 RefWatcher 监控 Fragment： 12345678public abstract class BaseFragment extends Fragment &#123; @Override public void onDestroy() &#123; super.onDestroy(); RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity()); refWatcher.watch(this); &#125;&#125; 使用 RefWatcher 监控 Activity： 123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123; ...... @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //在自己的应用初始Activity中加入如下两行代码 RefWatcher refWatcher = ExampleApplication.getRefWatcher(this); refWatcher.watch(this); textView = (TextView) findViewById(R.id.tv); textView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startAsyncTask(); &#125; &#125;); &#125; private void async() &#123; startAsyncTask(); &#125; private void startAsyncTask() &#123; // This async task is an anonymous class and therefore has a hidden reference to the outer // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation), // the activity instance will leak. new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... params) &#123; // Do some slow work in background SystemClock.sleep(20000); return null; &#125; &#125;.execute(); &#125;&#125; 工作机制1.RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。 2.然后在后台线程检查引用是否被清除，如果没有，调用GC。 3.如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。 4.在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。 5.得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。 6.HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。 7.引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。 ok,这里就不再深入了，想要了解更多就到 作者 github 主页 这去哈。 总结 对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。 尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。 对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏： 将内部类改为静态内部类 静态内部类中使用弱引用来引用外部类的成员变量 Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable. 在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。 正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。 保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>内存泄漏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android性能优化总结]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、Android性能优化的方面针对Android的性能优化，主要有以下几个有效的优化方法： 1.布局优化 2.绘制优化 3.内存泄漏优化 4.响应速度优化 5.ListView/RecycleView及Bitmap优化 6.线程优化 7.其他性能优化的建议 下面我们具体来介绍关于以上这几个方面优化的具体思路及解决方案。 二、布局优化关于布局优化的思想很简单，就是尽量减少布局文件的层级。这个道理很浅显，布局中的层级少了，就意味着Android绘制时的工作量少了，那么程序的性能自然就提高了。 如何进行布局优化？①删除布局中无用的控件和层次，其次有选择地使用性能比较低的ViewGroup。 关于有选择地使用性能比较低的ViewGroup,这就需要我们开发就实际灵活选择了。 例如：如果布局中既可以使用LinearLayout也可以使用RelativeLayout，那么就采用LinearLayout，这是因为RelativeLayout的功能比较复杂，它的布局过程需要花费更多的CPU时间。FrameLayout和LinearLayout一样都是一种简单高效的ViewGroup，因此可以考虑使用它们，但是很多时候单纯通过一个LinearLayout或者FrameLayout无法实现产品效果，需要通过嵌套的方式来完成。这种情况下还是建议采用RelativeLayout,因为ViewGroup的嵌套就相当于增加了布局的层级，同样会降低程序的性能。 ②采用标签,标签,ViewStub。 标签主要用于布局重用。 标签一般和配合使用，可以降低减少布局的层级。 ViewStub提供了按需加载的功能，当需要时才会将ViewStub中的布局加载到内存，提高了程序初始化效率。 ③避免多度绘制 过度绘制（Overdraw）描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次重叠的 UI 结构里面，如果不可见的 UI 也在做绘制的操作，会导致某些像素区域被绘制了多次，同时也会浪费大量的 CPU 以及 GPU 资源。 如下所示，有些部分在布局时，会被重复绘制。 关于过度绘制产生的一般场景及解决方案，参考：Android 过度绘制优化 三、绘制优化绘制优化是指View的onDraw方法要避免执行大量的操作，这主要体现在两个方面： ①onDraw中不要创建新的局部对象。 因为onDraw方法可能会被频繁调用，这样就会在一瞬间产生大量的临时对象，这不仅占用了过多的内存而且还会导致系统更加频繁gc，降低了程序的执行效率。 ②onDraw方法中不要做耗时的任务，也不能执行成千上万次的循环操作，尽管每次循环都很轻量级，但是大量的循环仍然十分抢占CPU的时间片，这会造成View的绘制过程不流畅。 按照Google官方给出的性能优化典范中的标准，View的绘制频率保证60fps是最佳的，这就要求每帧绘制时间不超过16ms(16ms = 1000/60)，虽然程序很难保证16ms这个时间，但是尽量降低onDraw方法中的复杂度总是切实有效的。 四、内存泄漏优化内存泄漏是开发过程中的一个需要重视的问题，但是由于内存泄露问题对开发人员的经验和开发意识有较高的要求，因此也是开发人员最容易犯的错误之一。 内存泄露的优化分为两个方面： ①在开发过程中避免写出有内存泄漏的代码 ②通过一些分析工具比如MAT来找出潜在的内存泄露，然后解决。 对应于两种不同情况，一个是了解内存泄漏的可能场景以及如何规避，二是怎么查找内存泄漏。 1.那么我们就先了解什么是内存泄漏?这样我们才能知道如何避免。大家都知道，java是有垃圾回收机制的，这使得java程序员比C++程序员轻松了许多，存储申请了，不用心心念念要加一句释放，java虚拟机会派出一些回收线程兢兢业业不定时地回收那些不再被需要的内存空间（注意回收的不是对象本身，而是对象占据的内存空间）。 Q1：什么叫不再被需要的内存空间？ 答：Java没有指针，全凭引用来和对象进行关联，通过引用来操作对象。如果一个对象没有与任何引用关联，那么这个对象也就不太可能被使用到了，回收器便是把这些“无任何引用的对象”作为目标，回收了它们占据的内存空间。 Q2：如何分辨为对象无引用？ 答：2种方法 引用计数法直接计数，简单高效，Python便是采用该方法。但是如果出现 两个对象相互引用，即使它们都无法被外界访问到，计数器不为0它们也始终不会被回收。为了解决该问题，java采用的是b方法。 可达性分析法这个方法设置了一系列的“GC Roots”对象作为索引起点，如果一个对象 与起点对象之间均无可达路径，那么这个不可达的对象就会成为回收对象。这种方法处理 两个对象相互引用的问题，如果两个对象均没有外部引用，会被判断为不可达对象进而被回收（如下图）。 Q3：有了回收机制，放心大胆用不会有内存泄漏？ 答：答案当然是No！ 虽然垃圾回收器会帮我们干掉大部分无用的内存空间，但是对于还保持着引用，但逻辑上已经不会再用到的对象，垃圾回收器不会回收它们。这些对象积累在内存中，直到程序结束，就是我们所说的“内存泄漏”。当然了，用户对单次的内存泄漏并没有什么感知，但当泄漏积累到内存都被消耗完，就会导致卡顿，崩溃。 下面这张图可以帮助我们更好地理解对象的状态，以及内存泄漏的情况 左边未引用的对象是会被GC回收的，右边被引用的对象不会被GC回收，但是未使用的对象中除了未引用的对象，还包括已被引用的一部分对象，那么内存泄漏久发生这部分已被引用但未使用的对象。 2.Android一般在什么情况下会出现内存泄漏？①集合类泄漏②单例/静态变量造成的内存泄漏③匿名内部类/非静态内部类④资源未关闭造成的内存泄漏 大概可以分为以上几类，还有一些经常会听到的Hanlder,AsyncTask引起内存泄漏，都属于上述③中的情况。 那么上述四种情况是怎么造成的内存泄漏，具体是什么原因，以及Android中一些知名的引起内存泄漏的原因，以及解决方法是怎么样的？ 3.Android怎么分析内存泄漏？上面介绍了内存泄漏的场景，对应的有一些解决方案。 那么在内存泄漏已经发生的情况下，我们该如何解决呢？ 我们可以通过MAT(Memory Analyzer Tool)，或者 LeakCanary来检测Android中的内存泄漏。 五、响应速度优化响应速度优化的核心思想就是避免在主线程中做耗时操作。 如果有耗时操作，可以开启子线程执行，即采用异步的方式来执行耗时操作。 如果在主线程中做太多事情，会导致Activity启动时出现黑屏现象，甚至ANR。 Android规定，Activity如果5秒钟之内无法响应屏幕触摸事件或者键盘输入事件就会出现ANR，而BroadcastReceiver如果10秒钟之内还未执行完操作也会出现ANR。 为了避免ANR，可以开启子线程执行耗时操作，但是子线程不能更新UI，所以需要子线程与主线程进行通信来解决子线程执行耗时任务后，通知主线程更新UI的场景。关于这部分，需要掌握Handler消息机制，AsyncTask，IntentService等内容。 然而，在实际开发中，ANR仍然不可避免的发生了，而且很难从代码上发现，这时候就要用到ANR日志分析。当一个进程发生了ANR之后，系统会在/data/anr目录下创建一个文件traces.txt，通过分析这个文件就能定位出ANR的原因。 六、ListView/RecycleView及Bitmap优化 ListView/RecycleView的优化思想主要从以下几个方面入手： ①使用ViewHolder模式来提高效率 ②异步加载：耗时的操作放在异步线程中 ③ListView/RecycleView的滑动时停止加载和分页加载 具体优化建议及详情，参考：ListView的优化 Bitmap优化 主要是对加载图片进行压缩，避免加载图片多大导致OOM出现。 七、线程优化线程优化的思想就是采用线程池，避免程序中存在大量的Thread。线程池可以重用内部的线程，从而避免了线程的创建和销毁锁带来的性能开销，同时线程池还能有效地控制线程池的最大并法术，避免大量的线程因互相抢占系统资源从而导致阻塞现象的发生。因此在实际开发中，尽量采用线程池，而不是每次都要创建一个Thread对象。 八、其他性能优化建议①避免过度的创建对象 ②不要过度使用枚举，枚举占用的内存空间要比整型大 ③常量请使用static final来修饰 ④使用一些Android特有的数据结构，比如SparseArray和Pair等 ⑤适当采用软引用和弱引用 ⑥采用内存缓存和磁盘缓存 ⑦尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄漏。 以上是关于Android性能优化方面，我们一些入手点。从这些方面，我们可以在平时的开发中注意，避免类似错误，提高Android程序的性能，但是其中一些方面的要求则需要我们不断的学习，以及平时良好的意识与习惯。由于自己开发经验几乎为0，没办法根据实际经验来说明，只能写下这篇文章来提醒自己以后开发的时候需要注意和培养的地方。]]></content>
      <categories>
        <category>Android</category>
        <category>Android高级</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android动画总结]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E5%8A%A8%E7%94%BB%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、Android 动画分类总的来说，Android动画可以分为两类，最初的传统动画和Android3.0 之后出现的属性动画； 传统动画又包括 帧动画（Frame Animation）和补间动画（Tweened Animation）。 二、传统动画帧动画帧动画是最容易实现的一种动画，这种动画更多的依赖于完善的UI资源，他的原理就是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。 如上图中的京东加载动画，代码要做的事情就是把一幅幅的图片按顺序显示，造成动画的视觉效果。 京东动画实现 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:drawable="@drawable/a_0" android:duration="100" /&gt; &lt;item android:drawable="@drawable/a_1" android:duration="100" /&gt; &lt;item android:drawable="@drawable/a_2" android:duration="100" /&gt;&lt;/animation-list&gt; 12345678protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_frame_animation); ImageView animationImg1 = (ImageView) findViewById(R.id.animation1); animationImg1.setImageResource(R.drawable.frame_anim1); AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable(); animationDrawable1.start(); &#125; 可以说，图片资源决定了这种方式可以实现怎样的动画 在有些代码中，我们还会看到android：oneshot=”false” ，这个oneshot 的含义就是动画执行一次（true）还是循环执行多次。 这里其他几个动画实现方式都是一样，无非就是图片资源的差异。 补间动画补间动画又可以分为四种形式，分别是 alpha（淡入淡出），translate（位移），scale（缩放大小），rotate（旋转）。补间动画的实现，一般会采用xml 文件的形式；代码会更容易书写和阅读，同时也更容易复用。 XML 实现首先，在res/anim/ 文件夹下定义如下的动画实现方式 alpha_anim.xml 动画实现 123456&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;alpha xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:fromAlpha="1.0" android:interpolator="@android:anim/accelerate_decelerate_interpolator" android:toAlpha="0.0" /&gt; scale.xml 动画实现 123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:duration="1000" android:fromXScale="0.0" android:fromYScale="0.0" android:pivotX="50%" android:pivotY="50%" android:toXScale="1.0" android:toYScale="1.0"/&gt; 然后，在Activity中 123Animation animation = AnimationUtils.loadAnimation(mContext, R.anim.alpha_anim);img = (ImageView) findViewById(R.id.img);img.startAnimation(animation); 这样就可以实现ImageView alpha 透明变化的动画效果。 也可以使用set 标签将多个动画组合（代码源自Android SDK API） 12345678910111213141516171819202122232425262728&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android" android:interpolator="@[package:]anim/interpolator_resource" android:shareInterpolator=["true" | "false"] &gt; &lt;alpha android:fromAlpha="float" android:toAlpha="float" /&gt; &lt;scale android:fromXScale="float" android:toXScale="float" android:fromYScale="float" android:toYScale="float" android:pivotX="float" android:pivotY="float" /&gt; &lt;translate android:fromXDelta="float" android:toXDelta="float" android:fromYDelta="float" android:toYDelta="float" /&gt; &lt;rotate android:fromDegrees="float" android:toDegrees="float" android:pivotX="float" android:pivotY="float" /&gt; &lt;set&gt; ... &lt;/set&gt;&lt;/set&gt; 可以看到组合动画是可以嵌套使用的。 各个动画属性的含义结合动画自身的特点应该很好理解，就不一一阐述了；这里主要说一下interpolator 和 pivot。 Interpolator 主要作用是可以控制动画的变化速率 ，就是动画进行的快慢节奏。 Android 系统已经为我们提供了一些Interpolator ，比如 accelerate_decelerate_interpolator，accelerate_interpolator等。更多的interpolator 及其含义可以在Android SDK 中查看。同时这个Interpolator也是可以自定义的，这个后面还会提到。 pivot 决定了当前动画执行的参考位置 pivot 这个属性主要是在translate 和 scale 动画中，这两种动画都牵扯到view 的“物理位置“发生变化，所以需要一个参考点。而pivotX和pivotY就共同决定了这个点；它的值可以是float或者是百分比数值。 我们以pivotX为例， pivotX取值 含义 10 距离动画所在view自身左边缘10像素 10% 距离动画所在view自身左边缘 的距离是整个view宽度的10% 10%p 距离动画所在view父控件左边缘的距离是整个view宽度的10% pivotY 也是相同的原理，只不过变成的纵向的位置。如果还是不明白可以参考源码，在Tweened Animation中结合seekbar的滑动观察rotate的变化理解。 Java Code 实现有时候，动画的属性值可能需要动态的调整，这个时候使用xml 就不合适了，需要使用java代码实现 1234567891011121314151617181920212223private void RotateAnimation() &#123; animation = new RotateAnimation(-deValue, deValue, Animation.RELATIVE_TO_SELF, pxValue, Animation.RELATIVE_TO_SELF, pyValue); animation.setDuration(timeValue); if (keep.isChecked()) &#123; animation.setFillAfter(true); &#125; else &#123; animation.setFillAfter(false); &#125; if (loop.isChecked()) &#123; animation.setRepeatCount(-1); &#125; else &#123; animation.setRepeatCount(0); &#125; if (reverse.isChecked()) &#123; animation.setRepeatMode(Animation.REVERSE); &#125; else &#123; animation.setRepeatMode(Animation.RESTART); &#125; img.startAnimation(animation); &#125; 这里animation.setFillAfter决定了动画在播放结束时是否保持最终的状态；animation.setRepeatCount和animation.setRepeatMode 决定了动画的重复次数及重复方式，具体细节可查看源码理解。 好了，传统动画的内容就说到这里了。 三、属性动画属性动画，顾名思义它是对于对象属性的动画。因此，所有补间动画的内容，都可以通过属性动画实现。 属性动画入门首先我们来看看如何用属性动画实现上面补间动画的效果 12345678910111213private void RotateAnimation() &#123; ObjectAnimator anim = ObjectAnimator.ofFloat(myView, "rotation", 0f, 360f); anim.setDuration(1000); anim.start();&#125;private void AlpahAnimation() &#123; ObjectAnimator anim = ObjectAnimator.ofFloat(myView, "alpha", 1.0f, 0.8f, 0.6f, 0.4f, 0.2f, 0.0f); anim.setRepeatCount(-1); anim.setRepeatMode(ObjectAnimator.REVERSE); anim.setDuration(2000); anim.start();&#125; 这两个方法用属性动画的方式分别实现了旋转动画和淡入淡出动画，其中setDuration、setRepeatMode及setRepeatCount和补间动画中的概念是一样的。 可以看到，属性动画貌似强大了许多，实现很方便，同时动画可变化的值也有了更多的选择，动画所能呈现的细节也更多。 当然属性动画也是可以组合实现的 1234567891011 ObjectAnimator alphaAnim = ObjectAnimator.ofFloat(myView, "alpha", 1.0f, 0.5f, 0.8f, 1.0f); ObjectAnimator scaleXAnim = ObjectAnimator.ofFloat(myView, "scaleX", 0.0f, 1.0f); ObjectAnimator scaleYAnim = ObjectAnimator.ofFloat(myView, "scaleY", 0.0f, 2.0f); ObjectAnimator rotateAnim = ObjectAnimator.ofFloat(myView, "rotation", 0, 360); ObjectAnimator transXAnim = ObjectAnimator.ofFloat(myView, "translationX", 100, 400); ObjectAnimator transYAnim = ObjectAnimator.ofFloat(myView, "tranlsationY", 100, 750); AnimatorSet set = new AnimatorSet(); set.playTogether(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim);// set.playSequentially(alphaAnim, scaleXAnim, scaleYAnim, rotateAnim, transXAnim, transYAnim); set.setDuration(3000); set.start(); 可以看到这些动画可以同时播放，或者是按序播放。 属性动画核心原理在上面实现属性动画的时候，我们反复的使用到了ObjectAnimator 这个类，这个类继承自ValueAnimator，使用这个类可以对任意对象的任意属性进行动画操作。而ValueAnimator是整个属性动画机制当中最核心的一个类；这点从下面的图片也可以看出。 属性动画核心原理，此图来自于Android SDK API 文档。 属性动画的运行机制是通过不断地对值进行操作来实现的，而初始值和结束值之间的动画过渡就是由ValueAnimator这个类来负责计算的。它的内部使用一种时间循环的机制来计算值与值之间的动画过渡，我们只需要将初始值和结束值提供给ValueAnimator，并且告诉它动画所需运行的时长，那么ValueAnimator就会自动帮我们完成从初始值平滑地过渡到结束值这样的效果。除此之外，ValueAnimator还负责管理动画的播放次数、播放模式、以及对动画设置监听器等。 从上图我们可以了解到，通过duration、startPropertyValue和endPropertyValue 等值，我们就可以定义动画运行时长，初始值和结束值。然后通过start方法开始动画。那么ValueAnimator 到底是怎样实现从初始值平滑过渡到结束值的呢？这个就是由TypeEvaluator 和TimeInterpolator 共同决定的。 具体来说，TypeEvaluator 决定了动画如何从初始值过渡到结束值。 TimeInterpolator 决定了动画从初始值过渡到结束值的节奏。 说的通俗一点，你每天早晨出门去公司上班，TypeEvaluator决定了你是坐公交、坐地铁还是骑车；而当你决定骑车后，TimeInterpolator决定了你一路上骑行的方式，你可以匀速的一路骑到公司，你也可以前半程骑得飞快，后半程骑得慢悠悠。 如果，还是不理解，那么就看下面的代码吧。首先看一下下面的这两个gif动画，一个小球在屏幕上以 y=sin(x) 的数学函数轨迹运行，同时小球的颜色和半径也发生着变化，可以发现，两幅图动画变化的节奏也是不一样的。 如果不考虑属性动画，这样的一个动画纯粹的使用Canvas+Handler的方式绘制也是有可能实现的。但是会复杂很多，而且加上各种线程，会带来很多意想不到的问题。 这里就通过自定义属性动画的方式看看这个动画是如何实现的。 属性动画自定义实现这个动画最关键的三点就是 运动轨迹、小球半径及颜色的变化；我们就从这三个方面展开。最后我们在结合Interpolator说一下TimeInterpolator的意义。 用TypeEvaluator 确定运动轨迹前面说了，TypeEvaluator决定了动画如何从初始值过渡到结束值。这个TypeEvaluator是个接口，我们可以实现这个接口。 12345678910111213public class PointSinEvaluator implements TypeEvaluator &#123; @Override public Object evaluate(float fraction, Object startValue, Object endValue) &#123; Point startPoint = (Point) startValue; Point endPoint = (Point) endValue; float x = startPoint.getX() + fraction * (endPoint.getX() - startPoint.getX()); float y = (float) (Math.sin(x * Math.PI / 180) * 100) + endPoint.getY() / 2; Point point = new Point(x, y); return point; &#125;&#125; PointSinEvaluator 继承了TypeEvaluator类，并实现了他唯一的方法evaluate；这个方法有三个参数，第一个参数fraction 代表当前动画完成的百分比，这个值是如何变化的后面还会提到；第二个和第三个参数代表动画的初始值和结束值。这里我们的逻辑很简单，x的值随着fraction 不断变化，并最终达到结束值；y的值就是当前x值所对应的sin(x) 值，然后用x 和 y 产生一个新的点（Point对象）返回。 这样我们就可以使用这个PointSinEvaluator 生成属性动画的实例了。 123456789101112Point startP = new Point(RADIUS, RADIUS);//初始值（起点）Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS);//结束值（终点）final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP);valueAnimator.setRepeatCount(-1);valueAnimator.setRepeatMode(ValueAnimator.REVERSE);valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; currentPoint = (Point) animation.getAnimatedValue(); postInvalidate(); &#125;&#125;); 这样我们就完成了动画轨迹的定义，现在只要调用valueAnimator.start() 方法，就会绘制出一个正弦曲线的轨迹。 颜色及半径动画实现之前我们说过，使用ObjectAnimator 可以对任意对象的任意属性进行动画操作，这句话是不太严谨的，这个任意属性还需要有get 和 set 方法。 1234567891011public class PointAnimView extends View &#123; /** * 实现关于color 的属性动画 */ private int color; private float radius = RADIUS; .....&#125; 这里在我们的自定义view中，定义了两个属性color 和 radius，并实现了他们各自的get set 方法，这样我们就可以使用属性动画的特点实现小球颜色变化的动画和半径变化的动画。 12345678910111213141516ObjectAnimator animColor = ObjectAnimator.ofObject(this, "color", new ArgbEvaluator(), Color.GREEN, Color.YELLOW, Color.BLUE, Color.WHITE, Color.RED);animColor.setRepeatCount(-1);animColor.setRepeatMode(ValueAnimator.REVERSE);ValueAnimator animScale = ValueAnimator.ofFloat(20f, 80f, 60f, 10f, 35f,55f,10f);animScale.setRepeatCount(-1);animScale.setRepeatMode(ValueAnimator.REVERSE);animScale.setDuration(5000);animScale.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; radius = (float) animation.getAnimatedValue(); &#125;&#125;); 这里，我们使用ObjectAnimator 实现对color 属性的值按照ArgbEvaluator 这个类的规律在给定的颜色值之间变化，这个ArgbEvaluator 和我们之前定义的PointSinEvaluator一样，都是决定动画如何从初始值过渡到结束值的，只不过这个类是系统自带的，我们直接拿来用就可以，他可以实现各种颜色间的自由过渡。 对radius 这个属性使用了ValueAnimator，使用了其ofFloat方法实现了一系列float值的变化；同时为其添加了动画变化的监听器，在属性值更新的过程中，我们可以将变化的结果赋给radius，这样就实现了半径动态的变化。 这里radius 也可以使用和color相同的方式，只需要把ArgbEvaluator 替换为FloatEvaluator，同时修改动画的变化值即可；使用添加监听器的方式，只是为了介绍监听器的使用方法而已 好了，到这里我们已经定义出了所有需要的动画，前面说过，属性动画也是可以组合使用的。因此，在动画启动的时候，同时播放这三个动画，就可以实现图中的效果了。 12345animSet = new AnimatorSet();animSet.play(valueAnimator).with(animColor).with(animScale);animSet.setDuration(5000);animSet.setInterpolator(interpolatorType);animSet.start(); PointAnimView 源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173public class PointAnimView extends View &#123; public static final float RADIUS = 20f; private Point currentPoint; private Paint mPaint; private Paint linePaint; private AnimatorSet animSet; private TimeInterpolator interpolatorType = new LinearInterpolator(); /** * 实现关于color 的属性动画 */ private int color; private float radius = RADIUS; public PointAnimView(Context context) &#123; super(context); init(); &#125; public PointAnimView(Context context, AttributeSet attrs) &#123; super(context, attrs); init(); &#125; public PointAnimView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); init(); &#125; public int getColor() &#123; return color; &#125; public void setColor(int color) &#123; this.color = color; mPaint.setColor(this.color); &#125; public float getRadius() &#123; return radius; &#125; public void setRadius(float radius) &#123; this.radius = radius; &#125; private void init() &#123; mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.TRANSPARENT); linePaint = new Paint(Paint.ANTI_ALIAS_FLAG); linePaint.setColor(Color.BLACK); linePaint.setStrokeWidth(5); &#125; @Override protected void onDraw(Canvas canvas) &#123; if (currentPoint == null) &#123; currentPoint = new Point(RADIUS, RADIUS); drawCircle(canvas);// StartAnimation(); &#125; else &#123; drawCircle(canvas); &#125; drawLine(canvas); &#125; private void drawLine(Canvas canvas) &#123; canvas.drawLine(10, getHeight() / 2, getWidth(), getHeight() / 2, linePaint); canvas.drawLine(10, getHeight() / 2 - 150, 10, getHeight() / 2 + 150, linePaint); canvas.drawPoint(currentPoint.getX(), currentPoint.getY(), linePaint); &#125; public void StartAnimation() &#123; Point startP = new Point(RADIUS, RADIUS); Point endP = new Point(getWidth() - RADIUS, getHeight() - RADIUS); final ValueAnimator valueAnimator = ValueAnimator.ofObject(new PointSinEvaluator(), startP, endP); valueAnimator.setRepeatCount(-1); valueAnimator.setRepeatMode(ValueAnimator.REVERSE); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; currentPoint = (Point) animation.getAnimatedValue(); postInvalidate(); &#125; &#125;);// ObjectAnimator animColor = ObjectAnimator.ofObject(this, "color", new ArgbEvaluator(), Color.GREEN, Color.YELLOW, Color.BLUE, Color.WHITE, Color.RED); animColor.setRepeatCount(-1); animColor.setRepeatMode(ValueAnimator.REVERSE); ValueAnimator animScale = ValueAnimator.ofFloat(20f, 80f, 60f, 10f, 35f,55f,10f); animScale.setRepeatCount(-1); animScale.setRepeatMode(ValueAnimator.REVERSE); animScale.setDuration(5000); animScale.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() &#123; @Override public void onAnimationUpdate(ValueAnimator animation) &#123; radius = (float) animation.getAnimatedValue(); &#125; &#125;); animSet = new AnimatorSet(); animSet.play(valueAnimator).with(animColor).with(animScale); animSet.setDuration(5000); animSet.setInterpolator(interpolatorType); animSet.start(); &#125; private void drawCircle(Canvas canvas) &#123; float x = currentPoint.getX(); float y = currentPoint.getY(); canvas.drawCircle(x, y, radius, mPaint); &#125; public void setInterpolatorType(int type ) &#123; switch (type) &#123; case 1: interpolatorType = new BounceInterpolator(); break; case 2: interpolatorType = new AccelerateDecelerateInterpolator(); break; case 3: interpolatorType = new DecelerateInterpolator(); break; case 4: interpolatorType = new AnticipateInterpolator(); break; case 5: interpolatorType = new LinearInterpolator(); break; case 6: interpolatorType=new LinearOutSlowInInterpolator(); break; case 7: interpolatorType = new OvershootInterpolator(); default: interpolatorType = new LinearInterpolator(); break; &#125; &#125; @TargetApi(Build.VERSION_CODES.KITKAT) public void pauseAnimation() &#123; if (animSet != null) &#123; animSet.pause(); &#125; &#125; public void stopAnimation() &#123; if (animSet != null) &#123; animSet.cancel(); this.clearAnimation(); &#125; &#125;&#125; TimeInterpolator 介绍Interpolator的概念其实我们并不陌生，在补间动画中我们就使用到了。他就是用来控制动画快慢节奏的；而在属性动画中，TimeInterpolator 也是类似的作用；TimeInterpolator 继承自Interpolator。我们可以继承TimerInterpolator 以自己的方式控制动画变化的节奏，也可以使用Android 系统提供的Interpolator。 下面都是系统帮我们定义好的一些Interpolator，我们可以通过setInterpolator 设置不同的Interpolator。 这里我们使用的Interpolator就决定了 前面我们提到的fraction。变化的节奏决定了动画所执行的百分比。不得不说，这么ValueAnimator的设计的确是很巧妙。 XML 属性动画这里提一下，属性动画当然也可以使用xml文件的方式实现，但是属性动画的属性值一般会牵扯到对象具体的属性，更多是通过代码动态获取，所以xml文件的实现会有些不方便。 123456789101112131415161718&lt;set android:ordering="sequentially"&gt; &lt;set&gt; &lt;objectAnimator android:propertyName="x" android:duration="500" android:valueTo="400" android:valueType="intType"/&gt; &lt;objectAnimator android:propertyName="y" android:duration="500" android:valueTo="300" android:valueType="intType"/&gt; &lt;/set&gt; &lt;objectAnimator android:propertyName="alpha" android:duration="500" android:valueTo="1f"/&gt;&lt;/set&gt; 使用方式： 1234AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext, R.anim.property_animator);set.setTarget(myObject);set.start(); xml 文件中的标签也和属性动画的类相对应。 123ValueAnimator --- &lt;animator&gt; ObjectAnimator --- &lt;objectAnimator&gt; AnimatorSet --- &lt;set&gt; 这些就是属性动画的核心内容。现在使用属性动画的特性自定义动画应该不是难事了。其余便签的含义，结合之前的内容应该不难理解了。 四、传统动画 VS 属性动画相较于传统动画，属性动画有很多优势。那是否意味着属性动画可以完全替代传统动画呢。其实不然，两种动画都有各自的优势，属性动画如此强大，也不是没有缺点。 从上面两幅图比较可以发现，补间动画中，虽然使用translate将图片移动了，但是点击原来的位置，依旧可以发生点击事件，而属性动画却不是。因此我们可以确定，属性动画才是真正的实现了view的移动，补间动画对view的移动更像是在不同地方绘制了一个影子，实际的对象还是处于原来的地方。 当我们把动画的repeatCount设置为无限循环时，如果在Activity退出时没有及时将动画停止，属性动画会导致Activity无法释放而导致内存泄漏，而补间动画却没有问题。因此，使用属性动画时切记在Activity执行 onStop 方法时顺便将动画停止。（对这个怀疑的同学可以自己通过在动画的Update 回调方法打印日志的方式进行验证）。 xml 文件实现的补间动画，复用率极高。在Activity切换，窗口弹出时等情景中有着很好的效果。 使用帧动画时需要注意，不要使用过多特别大的图，容易导致内存不足。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Animator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Context详解]]></title>
    <url>%2F2018%2F06%2F07%2FContext%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Activity mActivity =new Activity() 作为Android开发者，不知道你有没有思考过这个问题，Activity可以new吗？Android的应用程序开发采用JAVA语言，Activity本质上也是一个对象，那上面的写法有什么问题呢？估计很多人说不清道不明。Android程序不像Java程序一样，随便创建一个类，写个main()方法就能运行，Android应用模型是基于组件的应用设计模式，组件的运行要有一个完整的Android工程环境，在这个环境下，Activity、Service等系统组件才能够正常工作，而这些组件并不能采用普通的Java对象创建方式，new一下就能创建实例了，而是要有它们各自的上下文环境，也就是我们这里讨论的Context。可以这样讲，Context是维持Android程序中各组件能够正常工作的一个核心功能类。 Context到底是什么? Context的中文翻译为：语境; 上下文; 背景; 环境，在开发中我们经常说称之为“上下文”，那么这个“上下文”到底是指什么意思呢？在语文中，我们可以理解为语境，在程序中，我们可以理解为当前对象在程序中所处的一个环境，一个与系统交互的过程。比如微信聊天，此时的“环境”是指聊天的界面以及相关的数据请求与传输，Context在加载资源、启动Activity、获取系统服务、创建View等操作都要参与。 那Context到底是什么呢？一个Activity就是一个Context，一个Service也是一个Context。Android程序员把“场景”抽象为Context类，他们认为用户和操作系统的每一次交互都是一个场景，比如打电话、发短信，这些都是一个有界面的场景，还有一些没有界面的场景，比如后台运行的服务（Service）。一个应用程序可以认为是一个工作环境，用户在这个环境中会切换到不同的场景，这就像一个前台秘书，她可能需要接待客人，可能要打印文件，还可能要接听客户电话，而这些就称之为不同的场景，前台秘书可以称之为一个应用程序。 如何生动形象的理解Context?上面的概念中采用了通俗的理解方式，将Context理解为“上下文”或者“场景”，如果你仍然觉得很抽象，不好理解。在这里我给出一个可能不是很恰当的比喻，希望有助于大家的理解：一个Android应用程序，可以理解为一部电影或者一部电视剧，Activity，Service，Broadcast Receiver，Content Provider这四大组件就好比是这部戏里的四个主角：胡歌，霍建华，诗诗，Baby。他们是由剧组（系统）一开始就定好了的，整部戏就是由这四位主演领衔担纲的，所以这四位主角并不是大街上随随便便拉个人（new 一个对象）都能演的。有了演员当然也得有摄像机拍摄啊，他们必须通过镜头（Context）才能将戏传递给观众，这也就正对应说四大组件（四位主角）必须工作在Context环境下（摄像机镜头）。那Button，TextView，LinearLayout这些控件呢，就好比是这部戏里的配角或者说群众演员，他们显然没有这么重用，随便一个路人甲路人乙都能演（可以new一个对象），但是他们也必须要面对镜头（工作在Context环境下），所以Button mButton=new Button（Context）是可以的。虽然不很恰当，但还是很容易理解的，希望有帮助。 源码中的Context 12345678910111213141516171819202122232425262728/** * Interface to global information about an application environment. This is * an abstract class whose implementation is provided by * the Android system. It * allows access to application-specific resources and classes, as well as * up-calls for application-level operations such as launching activities, * broadcasting and receiving intents, etc. */public abstract class Context &#123; /** * File creation mode: the default mode, where the created file can only * be accessed by the calling application (or all applications sharing the * same user ID). * @see #MODE_WORLD_READABLE * @see #MODE_WORLD_WRITEABLE */ public static final int MODE_PRIVATE = 0x0000; public static final int MODE_WORLD_WRITEABLE = 0x0002; public static final int MODE_APPEND = 0x8000; public static final int MODE_MULTI_PROCESS = 0x0004; . . . &#125; 源码中的注释是这么来解释Context的：Context提供了关于应用环境全局信息的接口。它是一个抽象类，它的执行被Android系统所提供。它允许获取以应用为特征的资源和类型，是一个统领一些资源（应用程序环境变量等）的上下文。就是说，它描述一个应用程序环境的信息（即上下文）；是一个抽象类，Android提供了该抽象类的具体实现类；通过它我们可以获取应用程序的资源和类（包括应用级别操作，如启动Activity，发广播，接受Intent等）。既然上面Context是一个抽象类，那么肯定有他的实现类咯，我们在Context的源码中通过IDE可以查看到他的子类最终可以得到如下关系图： Context类本身是一个纯abstract类，它有两个具体的实现子类：ContextImpl和ContextWrapper。其中ContextWrapper类，如其名所言，这只是一个包装而已，ContextWrapper构造函数中必须包含一个真正的Context引用，同时ContextWrapper中提供了attachBaseContext（）用于给ContextWrapper对象中指定真正的Context对象，调用ContextWrapper的方法都会被转向其所包含的真正的Context对象。ContextThemeWrapper类，如其名所言，其内部包含了与主题（Theme）相关的接口，这里所说的主题就是指在AndroidManifest.xml中通过android：theme为Application元素或者Activity元素指定的主题。当然，只有Activity才需要主题，Service是不需要主题的，因为Service是没有界面的后台场景，所以Service直接继承于ContextWrapper，Application同理。而ContextImpl类则真正实现了Context中的所以函数，应用程序中所调用的各种Context类的方法，其实现均来自于该类。一句话总结：Context的两个子类分工明确，其中ContextImpl是Context的具体实现类，ContextWrapper是Context的包装类。Activity，Application，Service虽都继承自ContextWrapper（Activity继承自ContextWrapper的子类ContextThemeWrapper），但它们初始化的过程中都会创建ContextImpl对象，由ContextImpl实现Context中的方法。 一个应用程序有几个Context？其实这个问题本身并没有什么意义，关键还是在于对Context的理解，从上面的关系图我们已经可以得出答案了，在应用程序中Context的具体实现子类就是：Activity，Service，Application。那么Context数量=Activity数量+Service数量+1。当然如果你足够细心，可能会有疑问：我们常说四大组件，这里怎么只有Activity，Service持有Context，那Broadcast Receiver，Content Provider呢？Broadcast Receiver，Content Provider并不是Context的子类，他们所持有的Context都是其他地方传过去的，所以并不计入Context总数。上面的关系图也从另外一个侧面告诉我们Context类在整个Android系统中的地位是多么的崇高，因为很显然Activity，Service，Application都是其子类，其地位和作用不言而喻。 Context能干什么？Context到底可以实现哪些功能呢？这个就实在是太多了，弹出Toast、启动Activity、启动Service、发送广播、操作数据库等等都需要用到Context。 123456789101112131415TextView tv = new TextView(getContext());ListAdapter adapter = new SimpleCursorAdapter(getApplicationContext(), ...);AudioManager am = (AudioManager) getContext().getSystemService(Context.AUDIO_SERVICE);getApplicationContext().getSharedPreferences(name, mode);getApplicationContext().getContentResolver().query(uri, ...);getContext().getResources().getDisplayMetrics().widthPixels * 5 / 8;getContext().startActivity(intent);getContext().startService(intent);getContext().sendBroadcast(intent); Context作用域虽然Context神通广大，但并不是随便拿到一个Context实例就可以为所欲为，它的使用还是有一些规则限制的。由于Context的具体实例是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。 从上图我们可以发现Activity所持有的Context的作用域最广，无所不能。因为Activity继承自ContextThemeWrapper，而Application和Service继承自ContextWrapper，很显然ContextThemeWrapper在ContextWrapper的基础上又做了一些操作使得Activity变得更强大，这里我就不再贴源码给大家分析了，有兴趣的童鞋可以自己查查源码。上图中的YES和NO我也不再做过多的解释了，这里我说一下上图中Application和Service所不推荐的两种使用情况。 如果我们用ApplicationContext去启动一个LaunchMode为standard的Activity的时候会报错android.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want? 这是因为非Activity类型的Context并没有所谓的任务栈，所以待启动的Activity就找不到栈了。解决这个问题的方法就是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就为它创建一个新的任务栈，而此时Activity是以singleTask模式启动的。所有这种用Application启动Activity的方式不推荐使用，Service同Application。 在Application和Service中去layout inflate也是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。所以这种方式也不推荐使用。 一句话总结：凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。 如何获取Context?通常我们想要获取Context对象，主要有以下四种方法 View.getContext,返回当前View对象的Context对象，通常是当前正在展示的Activity对象。 Activity.getApplicationContext,获取当前Activity所在的(应用)进程的Context对象，通常我们使用Context对象时，要优先考虑这个全局的进程Context。 ContextWrapper.getBaseContext():用来获取一个ContextWrapper进行装饰之前的Context，可以使用这个方法，这个方法在实际开发中使用并不多，也不建议使用。 Activity.this 返回当前的Activity实例，如果是UI控件需要使用Activity作为Context对象，但是默认的Toast实际上使用ApplicationContext也可以。 getApplication()和getApplicationContext() 上面说到获取当前Application对象用getApplicationContext，不知道你有没有联想到getApplication()，这两个方法有什么区别？相信这个问题会难倒不少开发者。 程序是不会骗人的，我们通过上面的代码，打印得出两者的内存地址都是相同的，看来它们是同一个对象。其实这个结果也很好理解，因为前面已经说过了，Application本身就是一个Context，所以这里获取getApplicationContext()得到的结果就是Application本身的实例。那么问题来了，既然这两个方法得到的结果都是相同的，那么Android为什么要提供两个功能重复的方法呢？实际上这两个方法在作用域上有比较大的区别。getApplication()方法的语义性非常强，一看就知道是用来获取Application实例的，但是这个方法只有在Activity和Service中才能调用的到。那么也许在绝大多数情况下我们都是在Activity或者Service中使用Application的，但是如果在一些其它的场景，比如BroadcastReceiver中也想获得Application的实例，这时就可以借助getApplicationContext()方法了。 123456public class MyReceiver extends BroadcastReceiver&#123; @Override public void onReceive(Contextcontext,Intentintent)&#123; Application myApp= (Application)context.getApplicationContext(); &#125;&#125; Context引起的内存泄露但Context并不能随便乱用，用的不好有可能会引起内存泄露的问题，下面就示例两种错误的引用方式。 错误的单例模式 123456789101112131415public class Singleton &#123; private static Singleton instance; private Context mContext; private Singleton(Context context) &#123; this.mContext = context; &#125; public static Singleton getInstance(Context context) &#123; if (instance == null) &#123; instance = new Singleton(context); &#125; return instance; &#125;&#125; 这是一个非线程安全的单例模式，instance作为静态对象，其生命周期要长于普通的对象，其中也包含Activity，假如Activity A去getInstance获得instance对象，传入this，常驻内存的Singleton保存了你传入的Activity A对象，并一直持有，即使Activity被销毁掉，但因为它的引用还存在于一个Singleton中，就不可能被GC掉，这样就导致了内存泄漏。 View持有Activity引用 123456789101112public class MainActivity extends Activity &#123; private static Drawable mDrawable; @Override protected void onCreate(Bundle saveInstanceState) &#123; super.onCreate(saveInstanceState); setContentView(R.layout.activity_main); ImageView iv = new ImageView(this); mDrawable = getResources().getDrawable(R.drawable.ic_launcher); iv.setImageDrawable(mDrawable); &#125;&#125; 有一个静态的Drawable对象，当ImageView设置这个Drawable时，ImageView保存了mDrawable的引用，而ImageView传入的this是MainActivity的mContext，因为被static修饰的mDrawable是常驻内存的，MainActivity是它的间接引用，MainActivity被销毁时，也不能被GC掉，所以造成内存泄漏。 正确使用Context 一般Context造成的内存泄漏，几乎都是当Context销毁的时候，却因为被引用导致销毁失败，而Application的Context对象可以理解为随着进程存在的，所以我们总结出使用Context的正确姿势： 当Application的Context能搞定的情况下，并且生命周期长的对象，优先使用Application的Context。 不要让生命周期长于Activity的对象持有到Activity的引用。 尽量不要在Activity中使用非静态内部类，因为非静态内部类会隐式持有外部类实例的引用，如果使用静态内部类，将外部实例引用作为弱引用持有。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Context</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android进程优先级]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E8%BF%9B%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[在安卓系统中：当系统内存不足时，Android系统将根据进程的优先级选择杀死一些不太重要的进程，优先级低的先杀死。进程优先级从高到低如下。 前台进程 处于正在与用户交互的activity 与前台activity绑定的service 调用了startForeground（）方法的service 正在执行oncreate（），onstart（），ondestroy方法的 service。 进程中包含正在执行onReceive（）方法的BroadcastReceiver。 系统中的前台进程并不会很多，而且一般前台进程都不会因为内存不足被杀死。特殊情况除外。当内存低到无法保证所有的前台进程同时运行时，才会选择杀死某个进程。 可视进程 为处于前台，但仍然可见的activity（例如：调用了onpause（）而还没调用onstop（）的activity）。典型情况是：运行activity时，弹出对话框（dialog等），此时的activity虽然不是前台activity，但是仍然可见。 可见activity绑定的service。（处于上诉情况下的activity所绑定的service） 可视进程一般也不会被系统杀死，除非为了保证前台进程的运行不得已而为之。 服务进程 已经启动的service 后台进程 不可见的activity（调用onstop（）之后的activity） 后台进程不会影响用户的体验，为了保证前台进程，可视进程，服务进程的运行，系统随时有可能杀死一个后台进程。当一个正确实现了生命周期的activity处于后台被杀死时，如果用户重新启动，会恢复之前的运行状态。 空进程 任何没有活动的进程 系统会杀死空进程，但这不会造成影响。空进程的存在无非为了一些缓存，以便于下次可以更快的启动。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Process</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bitmap压缩策略]]></title>
    <url>%2F2018%2F06%2F07%2FBitmap%E5%8E%8B%E7%BC%A9%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[一、为什么Bitmap需要高效加载？现在的高清大图，动辄就要好几M，而Android对单个应用所施加的内存限制，只有小几十M，如16M，这导致加载Bitmap的时候很容易出现内存溢出。如下异常信息，便是在开发中经常需要的： java.lang.OutofMemoryError:bitmap size exceeds VM budget 为了解决这个问题，就出现了Bitmap的高效加载策略。其实核心思想很简单。假设通过ImageView来显示图片，很多时候ImageView并没有原始图片的尺寸那么大，这个时候把整个图片加载进来后再设置给ImageView，显然是没有必要的，因为ImageView根本没办法显示原始图片。这时候就可以按一定的采样率来将图片缩小后再加载进来，这样图片既能在ImageView显示出来，又能降低内存占用从而在一定程度上避免OOM，提高了Bitmap加载时的性能。 二、Bitmap高效加载的具体方式1.加载Bitmap的方式Bitmap在Android中指的是一张图片。通过BitmapFactory类提供的四类方法：decodeFile,decodeResource,decodeStream和decodeByteArray,分别从文件系统，资源，输入流和字节数组中加载出一个Bitmap对象，其中decodeFile,decodeResource又间接调用了decodeStream方法，这四类方法最终是在Android的底层实现的，对应着BitmapFactory类的几个native方法。 2.BitmapFactory.Options的参数①inSampleSize参数上述四类方法都支持BitmapFactory.Options参数，而Bitmap的按一定采样率进行缩放就是通过BitmapFactory.Options参数实现的，主要用到了inSampleSize参数，即采样率。通过对inSampleSize的设置，对图片的像素的高和宽进行缩放。 当inSampleSize=1，即采样后的图片大小为图片的原始大小。小于1，也按照1来计算。当inSampleSize&gt;1，即采样后的图片将会缩小，缩放比例为1/(inSampleSize的二次方)。 例如：一张1024 ×1024像素的图片，采用ARGB8888格式存储，那么内存大小1024×1024×4=4M。如果inSampleSize=2，那么采样后的图片内存大小：512×512×4=1M。 注意：官方文档支出，inSampleSize的取值应该总是2的指数，如1，2，4，8等。如果外界传入的inSampleSize的值不为2的指数，那么系统会向下取整并选择一个最接近2的指数来代替。比如3，系统会选择2来代替。当时经验证明并非在所有Android版本上都成立。 关于inSampleSize取值的注意事项：通常是根据图片宽高实际的大小/需要的宽高大小，分别计算出宽和高的缩放比。但应该取其中最小的缩放比，避免缩放图片太小，到达指定控件中不能铺满，需要拉伸从而导致模糊。 例如：ImageView的大小是100×100像素，而图片的原始大小为200×300，那么宽的缩放比是2，高的缩放比是3。如果最终inSampleSize=2，那么缩放后的图片大小100×150，仍然合适ImageView。如果inSampleSize=3，那么缩放后的图片大小小于ImageView所期望的大小，这样图片就会被拉伸而导致模糊。 ②inJustDecodeBounds参数我们需要获取加载的图片的宽高信息，然后交给inSampleSize参数选择缩放比缩放。那么如何能先不加载图片却能获得图片的宽高信息，通过inJustDecodeBounds=true，然后加载图片就可以实现只解析图片的宽高信息，并不会真正的加载图片，所以这个操作是轻量级的。当获取了宽高信息，计算出缩放比后，然后在将inJustDecodeBounds=false,再重新加载图片，就可以加载缩放后的图片。 注意：BitmapFactory获取的图片宽高信息和图片的位置以及程序运行的设备有关，比如同一张图片放在不同的drawable目录下或者程序运行在不同屏幕密度的设备上，都可能导致BitmapFactory获取到不同的结果，和Android的资源加载机制有关。 3.高效加载Bitmap的流程①将BitmapFactory.Options的inJustDecodeBounds参数设为true并加载图片。 ②从BitmapFactory.Options中取出图片的原始宽高信息，它们对应于outWidth和outHeight参数。 ③根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize。 ④将BitmapFactory.Options的inJustDecodeBounds参数设为false，然后重新加载图片。 三、Bitmap高效加载的代码实现12345678910111213141516171819202122232425262728public static Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight)&#123; BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; //加载图片 BitmapFactory.decodeResource(res,resId,options); //计算缩放比 options.inSampleSize = calculateInSampleSize(options,reqHeight,reqWidth); //重新加载图片 options.inJustDecodeBounds =false; return BitmapFactory.decodeResource(res,resId,options); &#125; private static int calculateInSampleSize(BitmapFactory.Options options, int reqHeight, int reqWidth) &#123; int height = options.outHeight; int width = options.outWidth; int inSampleSize = 1; if(height&gt;reqHeight||width&gt;reqWidth)&#123; int halfHeight = height/2; int halfWidth = width/2; //计算缩放比，是2的指数 while((halfHeight/inSampleSize)&gt;=reqHeight&amp;&amp;(halfWidth/inSampleSize)&gt;=reqWidth)&#123; inSampleSize*=2; &#125; &#125; return inSampleSize; &#125; 这个时候就可以通过如下方式高效加载图片： 1mImageView.setImageBitmap(decodeSampledBitmapFromResource(getResources(),R.mipmap.ic_launcher,100,100); 除了BitmapFactory的decodeResource方法，其他方法也可以类似实现。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Bitmap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android进程间通信方式]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Android 中的 IPC 方式一、使用 Intent Activity，Service，Receiver 都支持在 Intent 中传递 Bundle 数据，而 Bundle 实现了 Parcelable 接口，可以在不同的进程间进行传输。 在一个进程中启动了另一个进程的 Activity，Service 和 Receiver ，可以在 Bundle 中附加要传递的数据通过 Intent 发送出去。 二、使用文件共享 Windows 上，一个文件如果被加了排斥锁会导致其他线程无法对其进行访问，包括读和写；而 Android 系统基于 Linux ，使得其并发读取文件没有限制地进行，甚至允许两个线程同时对一个文件进行读写操作，尽管这样可能会出问题。 可以在一个进程中序列化一个对象到文件系统中，在另一个进程中反序列化恢复这个对象（注意：并不是同一个对象，只是内容相同。）。 SharedPreferences 是个特例，系统对它的读 / 写有一定的缓存策略，即内存中会有一份 ShardPreferences 文件的缓存，系统对他的读 / 写就变得不可靠，当面对高并发的读写访问，SharedPreferences 有很多大的几率丢失数据。因此，IPC 不建议采用 SharedPreferences。 三、使用 MessengerMessenger 是一种轻量级的 IPC 方案，它的底层实现是 AIDL ，可以在不同进程中传递 Message 对象，它一次只处理一个请求，在服务端不需要考虑线程同步的问题，服务端不存在并发执行的情形。 服务端进程：服务端创建一个 Service 来处理客户端请求，同时通过一个 Handler 对象来实例化一个 Messenger 对象，然后在 Service 的 onBind 中返回这个 Messenger 对象底层的 Binder 即可。 123456789101112131415161718192021222324252627282930313233343536373839404142public class MessengerService extends Service &#123; private static final String TAG = MessengerService.class.getSimpleName(); private class MessengerHandler extends Handler &#123; /** * @param msg */ @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case Constants.MSG_FROM_CLIENT: Log.d(TAG, "receive msg from client: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]"); Toast.makeText(MessengerService.this, "receive msg from client: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show(); Messenger client = msg.replyTo; Message replyMsg = Message.obtain(null, Constants.MSG_FROM_SERVICE); Bundle bundle = new Bundle(); bundle.putString(Constants.MSG_KEY, "我已经收到你的消息，稍后回复你！"); replyMsg.setData(bundle); try &#123; client.send(replyMsg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; break; default: super.handleMessage(msg); &#125; &#125; &#125; private Messenger mMessenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) &#123; return mMessenger.getBinder(); &#125;&#125; 客户端进程：首先绑定服务端 Service ，绑定成功之后用服务端的 IBinder 对象创建一个 Messenger ，通过这个 Messenger 就可以向服务端发送消息了，消息类型是 Message 。如果需要服务端响应，则需要创建一个 Handler 并通过它来创建一个 Messenger（和服务端一样），并通过 Message 的 replyTo 参数传递给服务端。服务端通过 Message 的 replyTo 参数就可以回应客户端了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class MainActivity extends AppCompatActivity &#123; private static final String TAG = MainActivity.class.getSimpleName(); private Messenger mGetReplyMessenger = new Messenger(new MessageHandler()); private Messenger mService; private class MessageHandler extends Handler &#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case Constants.MSG_FROM_SERVICE: Log.d(TAG, "received msg form service: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]"); Toast.makeText(MainActivity.this, "received msg form service: msg = [" + msg.getData().getString(Constants.MSG_KEY) + "]", Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; public void bindService(View v) &#123; Intent mIntent = new Intent(this, MessengerService.class); bindService(mIntent, mServiceConnection, Context.BIND_AUTO_CREATE); &#125; public void sendMessage(View v) &#123; Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY, "Hello! This is client."); msg.setData(data); msg.replyTo = mGetReplyMessenger; try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy() &#123; unbindService(mServiceConnection); super.onDestroy(); &#125; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; /** * @param name * @param service */ @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mService = new Messenger(service); Message msg = Message.obtain(null,Constants.MSG_FROM_CLIENT); Bundle data = new Bundle(); data.putString(Constants.MSG_KEY, "Hello! This is client."); msg.setData(data); // msg.replyTo = mGetReplyMessenger; try &#123; mService.send(msg); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; /** * @param name */ @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;;&#125; 注意：客户端和服务端是通过拿到对方的 Messenger 来发送 Message 的。只不过客户端通过 bindService onServiceConnected 而服务端通过 message.replyTo 来获得对方的 Messenger 。Messenger 中有一个 Hanlder 以串行的方式处理队列中的消息。不存在并发执行，因此我们不用考虑线程同步的问题。 四、使用 AIDLMessenger 是以串行的方式处理客户端发来的消息，如果大量消息同时发送到服务端，服务端只能一个一个处理，所以大量并发请求就不适合用 Messenger ，而且 Messenger 只适合传递消息，不能跨进程调用服务端的方法。AIDL 可以解决并发和跨进程调用方法的问题，要知道 Messenger 本质上也是 AIDL ，只不过系统做了封装方便上层的调用而已。 AIDL 文件支持的数据类型 基本数据类型； String 和 CharSequence ArrayList ，里面的元素必须能够被 AIDL 支持； HashMap ，里面的元素必须能够被 AIDL 支持； Parcelable ，实现 Parcelable 接口的对象；注意：如果 AIDL 文件中用到了自定义的 Parcelable 对象，必须新建一个和它同名的 AIDL 文件。 AIDL ，AIDL 接口本身也可以在 AIDL 文件中使用。 服务端服务端创建一个 Service 用来监听客户端的连接请求，然后创建一个 AIDL 文件，将暴露给客户端的接口在这个 AIDL 文件中声明，最后在 Service 中实现这个 AIDL 接口即可。 客户端绑定服务端的 Service ，绑定成功后，将服务端返回的 Binder 对象转成 AIDL 接口所属的类型，然后就可以调用 AIDL 中的方法了。客户端调用远程服务的方法，被调用的方法运行在服务端的 Binder 线程池中，同时客户端的线程会被挂起，如果服务端方法执行比较耗时，就会导致客户端线程长时间阻塞，导致 ANR 。客户端的 onServiceConnected 和 onServiceDisconnected 方法都在 UI 线程中。 服务端访问权限管理 使用 Permission 验证，在 manifest 中声明 123&lt;permission android:name="com.jc.ipc.ACCESS_BOOK_SERVICE" android:protectionLevel="normal"/&gt;&lt;uses-permission android:name="com.jc.ipc.ACCESS_BOOK_SERVICE"/&gt; 服务端 onBinder 方法中 123456789public IBinder onBind(Intent intent) &#123; //Permission 权限验证 int check = checkCallingOrSelfPermission("com.jc.ipc.ACCESS_BOOK_SERVICE"); if (check == PackageManager.PERMISSION_DENIED) &#123; return null; &#125; return mBinder;&#125; Pid Uid 验证 详细代码： 1234// Book.aidlpackage com.jc.ipc.aidl;parcelable Book; 123456789101112131415161718192021// IBookManager.aidlpackage com.jc.ipc.aidl;import com.jc.ipc.aidl.Book;import com.jc.ipc.aidl.INewBookArrivedListener;// AIDL 接口中只支持方法，不支持静态常量，区别于传统的接口interface IBookManager &#123; List&lt;Book&gt; getBookList(); // AIDL 中除了基本数据类型，其他数据类型必须标上方向,in,out 或者 inout // in 表示输入型参数 // out 表示输出型参数 // inout 表示输入输出型参数 void addBook(in Book book); void registerListener(INewBookArrivedListener listener); void unregisterListener(INewBookArrivedListener listener);&#125; 123456789// INewBookArrivedListener.aidlpackage com.jc.ipc.aidl;import com.jc.ipc.aidl.Book;// 提醒客户端新书到来interface INewBookArrivedListener &#123; void onNewBookArrived(in Book newBook);&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class BookManagerActivity extends AppCompatActivity &#123; private static final String TAG = BookManagerActivity.class.getSimpleName(); private static final int MSG_NEW_BOOK_ARRIVED = 0x10; private Button getBookListBtn,addBookBtn; private TextView displayTextView; private IBookManager bookManager; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_NEW_BOOK_ARRIVED: Log.d(TAG, "handleMessage: new book arrived " + msg.obj); Toast.makeText(BookManagerActivity.this, "new book arrived " + msg.obj, Toast.LENGTH_SHORT).show(); break; default: super.handleMessage(msg); &#125; &#125; &#125;; private ServiceConnection mServiceConn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; bookManager = IBookManager.Stub.asInterface(service); try &#123; bookManager.registerListener(listener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; private INewBookArrivedListener listener = new INewBookArrivedListener.Stub() &#123; @Override public void onNewBookArrived(Book newBook) throws RemoteException &#123; mHandler.obtainMessage(MSG_NEW_BOOK_ARRIVED, newBook).sendToTarget(); &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.book_manager); displayTextView = (TextView) findViewById(R.id.displayTextView); Intent intent = new Intent(this, BookManagerService.class); bindService(intent, mServiceConn, BIND_AUTO_CREATE); &#125; public void getBookList(View view) &#123; try &#123; List&lt;Book&gt; list = bookManager.getBookList(); Log.d(TAG, "getBookList: " + list.toString()); displayTextView.setText(list.toString()); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; public void addBook(View view) &#123; try &#123; bookManager.addBook(new Book(3, "天龙八部")); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onDestroy() &#123; if (bookManager != null &amp;&amp; bookManager.asBinder().isBinderAlive()) &#123; Log.d(TAG, "unregister listener " + listener); try &#123; bookManager.unregisterListener(listener); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; unbindService(mServiceConn); super.onDestroy(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class BookManagerService extends Service &#123; private static final String TAG = BookManagerService.class.getSimpleName(); // CopyOnWriteArrayList 支持并发读写，实现自动线程同步，他不是继承自 ArrayList private CopyOnWriteArrayList&lt;Book&gt; mBookList = new CopyOnWriteArrayList&lt;Book&gt;(); //对象是不能跨进程传输的，对象的跨进程传输本质都是反序列化的过程，Binder 会把客户端传递过来的对象重新转化生成一个新的对象 //RemoteCallbackList 是系统专门提供的用于删除系统跨进程 listener 的接口，利用底层的 Binder 对象是同一个 //RemoteCallbackList 会在客户端进程终止后，自动溢出客户端注册的 listener ，内部自动实现了线程同步功能。 private RemoteCallbackList&lt;INewBookArrivedListener&gt; mListeners = new RemoteCallbackList&lt;&gt;(); private AtomicBoolean isServiceDestroied = new AtomicBoolean(false); private Binder mBinder = new IBookManager.Stub() &#123; @Override public List&lt;Book&gt; getBookList() throws RemoteException &#123; return mBookList; &#125; @Override public void addBook(Book book) throws RemoteException &#123; Log.d(TAG, "addBook: " + book.toString()); mBookList.add(book); &#125; @Override public void registerListener(INewBookArrivedListener listener) throws RemoteException &#123; mListeners.register(listener); &#125; @Override public void unregisterListener(INewBookArrivedListener listener) throws RemoteException &#123; mListeners.unregister(listener); &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); mBookList.add(new Book(1, "老人与海")); mBookList.add(new Book(2, "哈姆雷特")); new Thread(new ServiceWorker()).start(); &#125; private void onNewBookArrived(Book book) throws RemoteException &#123; mBookList.add(book); int count = mListeners.beginBroadcast(); for (int i = 0; i &lt; count; i++) &#123; INewBookArrivedListener listener = mListeners.getBroadcastItem(i); if (listener != null) &#123; listener.onNewBookArrived(book); &#125; &#125; mListeners.finishBroadcast(); &#125; private class ServiceWorker implements Runnable &#123; @Override public void run() &#123; while (!isServiceDestroied.get()) &#123; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; int bookId = mBookList.size() +1; Book newBook = new Book(bookId, "new book # " + bookId); try &#123; onNewBookArrived(newBook); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; //Permission 权限验证 int check = checkCallingOrSelfPermission("com.jc.ipc.ACCESS_BOOK_SERVICE"); if (check == PackageManager.PERMISSION_DENIED) &#123; return null; &#125; return mBinder; &#125; @Override public void onDestroy() &#123; isServiceDestroied.set(true); super.onDestroy(); &#125;&#125; 五、使用 ContentProvider用于不同应用间数据共享，和 Messenger 底层实现同样是 Binder 和 AIDL，系统做了封装，使用简单。系统预置了许多 ContentProvider ，如通讯录、日程表，需要跨进程访问。使用方法：继承 ContentProvider 类实现 6 个抽象方法，这六个方法均运行在 ContentProvider 进程中，除 onCreate 运行在主线程里，其他五个方法均由外界回调运行在 Binder 线程池中。 ContentProvider 的底层数据，可以是 SQLite 数据库，可以是文件，也可以是内存中的数据。 详见代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public class BookProvider extends ContentProvider &#123; private static final String TAG = "BookProvider"; public static final String AUTHORITY = "com.jc.ipc.Book.Provider"; public static final Uri BOOK_CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/book"); public static final Uri USER_CONTENT_URI = Uri.parse("content://" + AUTHORITY + "/user"); public static final int BOOK_URI_CODE = 0; public static final int USER_URI_CODE = 1; private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); static &#123; sUriMatcher.addURI(AUTHORITY, "book", BOOK_URI_CODE); sUriMatcher.addURI(AUTHORITY, "user", USER_URI_CODE); &#125; private Context mContext; private SQLiteDatabase mDB; @Override public boolean onCreate() &#123; mContext = getContext(); initProviderData(); return true; &#125; private void initProviderData() &#123; //不建议在 UI 线程中执行耗时操作 mDB = new DBOpenHelper(mContext).getWritableDatabase(); mDB.execSQL("delete from " + DBOpenHelper.BOOK_TABLE_NAME); mDB.execSQL("delete from " + DBOpenHelper.USER_TABLE_NAME); mDB.execSQL("insert into book values(3,'Android');"); mDB.execSQL("insert into book values(4,'iOS');"); mDB.execSQL("insert into book values(5,'Html5');"); mDB.execSQL("insert into user values(1,'haohao',1);"); mDB.execSQL("insert into user values(2,'nannan',0);"); &#125; @Nullable @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; Log.d(TAG, "query, current thread"+ Thread.currentThread()); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI" + uri); &#125; return mDB.query(table, projection, selection, selectionArgs, null, null, sortOrder, null); &#125; @Nullable @Override public String getType(Uri uri) &#123; Log.d(TAG, "getType"); return null; &#125; @Nullable @Override public Uri insert(Uri uri, ContentValues values) &#123; Log.d(TAG, "insert"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI" + uri); &#125; mDB.insert(table, null, values); // 通知外界 ContentProvider 中的数据发生变化 mContext.getContentResolver().notifyChange(uri, null); return uri; &#125; @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; Log.d(TAG, "delete"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI" + uri); &#125; int count = mDB.delete(table, selection, selectionArgs); if (count &gt; 0) &#123; mContext.getContentResolver().notifyChange(uri, null); &#125; return count; &#125; @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; Log.d(TAG, "update"); String table = getTableName(uri); if (table == null) &#123; throw new IllegalArgumentException("Unsupported URI" + uri); &#125; int row = mDB.update(table, values, selection, selectionArgs); if (row &gt; 0) &#123; getContext().getContentResolver().notifyChange(uri, null); &#125; return row; &#125; private String getTableName(Uri uri) &#123; String tableName = null; switch (sUriMatcher.match(uri)) &#123; case BOOK_URI_CODE: tableName = DBOpenHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = DBOpenHelper.USER_TABLE_NAME; break; default: break; &#125; return tableName; &#125;&#125; 123456789101112131415161718192021222324252627282930313233public class DBOpenHelper extends SQLiteOpenHelper &#123; private static final String DB_NAME = "book_provider.db"; public static final String BOOK_TABLE_NAME = "book"; public static final String USER_TABLE_NAME = "user"; private static final int DB_VERSION = 1; private String CREATE_BOOK_TABLE = "CREATE TABLE IF NOT EXISTS " + BOOK_TABLE_NAME + "(_id INTEGER PRIMARY KEY," + "name TEXT)"; private String CREATE_USER_TABLE = "CREATE TABLE IF NOT EXISTS " + USER_TABLE_NAME + "(_id INTEGER PRIMARY KEY," + "name TEXT," + "sex INT)"; public DBOpenHelper(Context context) &#123; super(context, DB_NAME, null, DB_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(CREATE_BOOK_TABLE); db.execSQL(CREATE_USER_TABLE); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class ProviderActivity extends AppCompatActivity &#123; private static final String TAG = ProviderActivity.class.getSimpleName(); private TextView displayTextView; private Handler mHandler; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_provider); displayTextView = (TextView) findViewById(R.id.displayTextView); mHandler = new Handler(); getContentResolver().registerContentObserver(BookProvider.BOOK_CONTENT_URI, true, new ContentObserver(mHandler) &#123; @Override public boolean deliverSelfNotifications() &#123; return super.deliverSelfNotifications(); &#125; @Override public void onChange(boolean selfChange) &#123; super.onChange(selfChange); &#125; @Override public void onChange(boolean selfChange, Uri uri) &#123; Toast.makeText(ProviderActivity.this, uri.toString(), Toast.LENGTH_SHORT).show(); super.onChange(selfChange, uri); &#125; &#125;); &#125; public void insert(View v) &#123; ContentValues values = new ContentValues(); values.put("_id",1123); values.put("name", "三国演义"); getContentResolver().insert(BookProvider.BOOK_CONTENT_URI, values); &#125; public void delete(View v) &#123; getContentResolver().delete(BookProvider.BOOK_CONTENT_URI, "_id = 4", null); &#125; public void update(View v) &#123; ContentValues values = new ContentValues(); values.put("_id",1123); values.put("name", "三国演义新版"); getContentResolver().update(BookProvider.BOOK_CONTENT_URI, values , "_id = 1123", null); &#125; public void query(View v) &#123; Cursor bookCursor = getContentResolver().query(BookProvider.BOOK_CONTENT_URI, new String[]&#123;"_id", "name"&#125;, null, null, null); StringBuilder sb = new StringBuilder(); while (bookCursor.moveToNext()) &#123; Book book = new Book(bookCursor.getInt(0),bookCursor.getString(1)); sb.append(book.toString()).append("\n"); &#125; sb.append("--------------------------------").append("\n"); bookCursor.close(); Cursor userCursor = getContentResolver().query(BookProvider.USER_CONTENT_URI, new String[]&#123;"_id", "name", "sex"&#125;, null, null, null); while (userCursor.moveToNext()) &#123; sb.append(userCursor.getInt(0)) .append(userCursor.getString(1)).append(" ,") .append(userCursor.getInt(2)).append(" ,") .append("\n"); &#125; sb.append("--------------------------------"); userCursor.close(); displayTextView.setText(sb.toString()); &#125;&#125; 六、使用 Socket Socket起源于 Unix，而 Unix 基本哲学之一就是“一切皆文件”，都可以用“打开 open –读写 write/read –关闭 close ”模式来操作。Socket 就是该模式的一个实现，网络的 Socket 数据传输是一种特殊的 I/O，Socket 也是一种文件描述符。Socket 也具有一个类似于打开文件的函数调用： Socket()，该函数返回一个整型的Socket 描述符，随后的连接建立、数据传输等操作都是通过该 Socket 实现的。 常用的 Socket 类型有两种：流式 Socket（SOCK_STREAM）和数据报式 Socket（SOCK_DGRAM）。流式是一种面向连接的 Socket，针对于面向连接的 TCP 服务应用；数据报式 Socket 是一种无连接的 Socket ，对应于无连接的 UDP 服务应用。 Socket 本身可以传输任意字节流。 谈到Socket，就必须要说一说 TCP/IP 五层网络模型： 应用层：规定应用程序的数据格式，主要的协议 HTTP，FTP，WebSocket，POP3 等； 传输层：建立“端口到端口” 的通信，主要的协议：TCP，UDP； 网络层：建立”主机到主机”的通信，主要的协议：IP，ARP ，IP 协议的主要作用：一个是为每一台计算机分配 IP 地址，另一个是确定哪些地址在同一子网； 数据链路层：确定电信号的分组方式，主要的协议：以太网协议； 物理层：负责电信号的传输。 Socket 是连接应用层与传输层之间接口（API）。 只实现 TCP Socket 。 Client 端代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class TCPClientActivity extends AppCompatActivity implements View.OnClickListener&#123; private static final String TAG = "TCPClientActivity"; public static final int MSG_RECEIVED = 0x10; public static final int MSG_READY = 0x11; private EditText editText; private TextView textView; private PrintWriter mPrintWriter; private Socket mClientSocket; private Button sendBtn; private StringBuilder stringBuilder; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; switch (msg.what) &#123; case MSG_READY: sendBtn.setEnabled(true); break; case MSG_RECEIVED: stringBuilder.append(msg.obj).append("\n"); textView.setText(stringBuilder.toString()); break; default: super.handleMessage(msg); &#125; &#125; &#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.tcp_client_activity); editText = (EditText) findViewById(R.id.editText); textView = (TextView) findViewById(R.id.displayTextView); sendBtn = (Button) findViewById(R.id.sendBtn); sendBtn.setOnClickListener(this); sendBtn.setEnabled(false); stringBuilder = new StringBuilder(); Intent intent = new Intent(TCPClientActivity.this, TCPServerService.class); startService(intent); new Thread()&#123; @Override public void run() &#123; connectTcpServer(); &#125; &#125;.start(); &#125; private String formatDateTime(long time) &#123; return new SimpleDateFormat("(HH:mm:ss)").format(new Date(time)); &#125; private void connectTcpServer() &#123; Socket socket = null; while (socket == null) &#123; try &#123; socket = new Socket("localhost", 8888); mClientSocket = socket; mPrintWriter = new PrintWriter(new BufferedWriter( new OutputStreamWriter(socket.getOutputStream()) ), true); mHandler.sendEmptyMessage(MSG_READY); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // receive message BufferedReader bufferedReader = null; try &#123; bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream())); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; while (!isFinishing()) &#123; try &#123; String msg = bufferedReader.readLine(); if (msg != null) &#123; String time = formatDateTime(System.currentTimeMillis()); String showedMsg = "server " + time + ":" + msg + "\n"; mHandler.obtainMessage(MSG_RECEIVED, showedMsg).sendToTarget(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void onClick(View v) &#123; if (mPrintWriter != null) &#123; String msg = editText.getText().toString(); mPrintWriter.println(msg); editText.setText(""); String time = formatDateTime(System.currentTimeMillis()); String showedMsg = "self " + time + ":" + msg + "\n"; stringBuilder.append(showedMsg); &#125; &#125; @Override protected void onDestroy() &#123; if (mClientSocket != null) &#123; try &#123; mClientSocket.shutdownInput(); mClientSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; super.onDestroy(); &#125;&#125; Server 端代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class TCPServerService extends Service &#123; private static final String TAG = "TCPServerService"; private boolean isServiceDestroyed = false; private String[] mMessages = new String[]&#123; "Hello! Body!", "用户不在线！请稍后再联系！", "请问你叫什么名字呀？", "厉害了，我的哥！", "Google 不需要科学上网是真的吗？", "扎心了，老铁！！！" &#125;; @Override public void onCreate() &#123; new Thread(new TCPServer()).start(); super.onCreate(); &#125; @Override public void onDestroy() &#123; isServiceDestroyed = true; super.onDestroy(); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; private class TCPServer implements Runnable &#123; @Override public void run() &#123; ServerSocket serverSocket = null; try &#123; serverSocket = new ServerSocket(8888); &#125; catch (IOException e) &#123; e.printStackTrace(); return; &#125; while (!isServiceDestroyed) &#123; // receive request from client try &#123; final Socket client = serverSocket.accept(); Log.d(TAG, "=============== accept =================="); new Thread()&#123; @Override public void run() &#123; try &#123; responseClient(client); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;.start(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; private void responseClient(Socket client) throws IOException &#123; //receive message BufferedReader in = new BufferedReader( new InputStreamReader(client.getInputStream())); //send message PrintWriter out = new PrintWriter( new BufferedWriter( new OutputStreamWriter( client.getOutputStream())),true); out.println("欢迎来到聊天室！"); while (!isServiceDestroyed) &#123; String str = in.readLine(); Log.d(TAG, "message from client: " + str); if (str == null) &#123; return; &#125; Random random = new Random(); int index = random.nextInt(mMessages.length); String msg = mMessages[index]; out.println(msg); Log.d(TAG, "send Message: " + msg); &#125; out.close(); in.close(); client.close(); &#125;&#125; 演示： UDP Socket 可以自己尝试着实现。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android虚拟机及编译过程]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8A%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一、什么是Dalvik虚拟机Dalvik是Google公司自己设计用于Android平台的Java虚拟机，它是Android平台的重要组成部分，支持dex格式（Dalvik Executable）的Java应用程序的运行。dex格式是专门为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Google对其进行了特定的优化，使得Dalvik具有高效、简洁、节省资源的特点。从Android系统架构图知，Dalvik虚拟机运行在Android的运行时库层。 Dalvik作为面向Linux、为嵌入式操作系统设计的虚拟机，主要负责完成对象生命周期管理、堆栈管理、线程管理、安全和异常管理，以及垃圾回收等。另外，Dalvik早期并没有JIT编译器，直到Android2.2才加入了对JIT的技术支持。 二、Dalvik虚拟机的特点体积小，占用内存空间小； 专有的DEX可执行文件格式，体积更小，执行速度更快； 常量池采用32位索引值，寻址类方法名，字段名，常量更快； 基于寄存器架构，并拥有一套完整的指令系统； 提供了对象生命周期管理，堆栈管理，线程管理，安全和异常管理以及垃圾回收等重要功能； 所有的Android程序都运行在Android系统进程里，每个进程对应着一个Dalvik虚拟机实例。 三、Dalvik虚拟机和Java虚拟机的区别Dalvik虚拟机与传统的Java虚拟机有着许多不同点，两者并不兼容，它们显著的不同点主要表现在以下几个方面： Java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码。 传统的Java程序经过编译，生成Java字节码保存在class文件中，Java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX（Dalvik Executable）可执行文件中。Dalvik虚拟机通过解释DEX文件来执行这些字节码。 Dalvik可执行文件体积小。Android SDK中有一个叫dx的工具负责将Java字节码转换为Dalvik字节码。 dx工具对Java类文件重新排列，消除在类文件中出现的所有冗余信息，避免虚拟机在初始化时出现反复的文件加载与解析过程。一般情况下，Java类文件中包含多个不同的方法签名，如果其他的类文件引用该类文件中的方法，方法签名也会被复制到其类文件中，也就是说，多个不同的类会同时包含相同的方法签名，同样地，大量的字符串常量在多个类文件中也被重复使用。这些冗余信息会直接增加文件的体积，同时也会严重影响虚拟机解析文件的效率。消除其中的冗余信息，重新组合形成一个常量池，所有的类文件共享同一个常量池。由于dx工具对常量池的压缩，使得相同的字符串，常量在DEX文件中只出现一次，从而减小了文件的体积。 针对每个Class文件，都由如下格式进行组成： dex格式文件使用共享的、特定类型的常量池机制来节省内存。常量池存储类中的所有字面常量，它包括字符串常量、字段常量等值。 简单来讲，dex格式文件就是将多个class文件中公有的部分统一存放，去除冗余信息。 Java虚拟机与Dalvik虚拟机架构不同。这也是Dalvik与JVM之间最大的区别。 Java虚拟机基于栈架构，程序在运行时虚拟机需要频繁的从栈上读取或写入数据，这个过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构。数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式要快很多。 四、Dalvik虚拟机的结构 一个应用首先经过DX工具将class文件转换成Dalvik虚拟机可以执行的dex文件，然后由类加载器加载原生类和Java类，接着由解释器根据指令集对Dalvik字节码进行解释、执行。最后，根据dvm_arch参数选择编译的目标机体系结构。 五、Android APK 编译打包流程 1.Java编译器对工程本身的java代码进行编译，这些java代码有三个来源：app的源代码，由资源文件生成的R文件(aapt工具)，以及有aidl文件生成的java接口文件(aidl工具)。产出为.class文件。 ①.用AAPT编译R.java文件 ②编译AIDL的java文件 ③把java文件编译成class文件 2..class文件和依赖的三方库文件通过dex工具生成Delvik虚拟机可执行的.dex文件，包含了所有的class信息，包括项目自身的class和依赖的class。产出为.dex文件。 3.apkbuilder工具将.dex文件和编译后的资源文件生成未经签名对齐的apk文件。这里编译后的资源文件包括两部分，一是由aapt编译产生的编译后的资源文件，二是依赖的三方库里的资源文件。产出为未经签名的.apk文件。 4.分别由Jarsigner和zipalign对apk文件进行签名和对齐，生成最终的apk文件。 总结为：编译–&gt;DEX–&gt;打包–&gt;签名和对齐 六、ART虚拟机与Dalvik虚拟机的区别什么是ART:ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time (JIT)编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运 行。ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time (AOT）编译。在移除解释代码这一过程后，应用程序执行将更有效率，启动更快。 ART优点： 系统性能的显著提升。 应用启动更快、运行更快、体验更流畅、触感反馈更及时。 更长的电池续航能力。 支持更低的硬件。 ART缺点： 更大的存储空间占用，可能会增加10%-20%。 更长的应用安装时间。 ART虚拟机相对于Dalvik虚拟机的提升预编译 在dalvik中,如同其他大多数JVM一样,都采用的是JIT来做及时翻译(动态翻译),将dex或odex中并排的dalvik code(或者叫smali指令集)运行态翻译成native code去执行.JIT的引入使得dalvik提升了3~6倍的性能。 而在ART中,完全抛弃了dalvik的JIT,使用了AOT直接在安装时将其完全翻译成native code.这一技术的引入,使得虚拟机执行指令的速度又一重大提升 垃圾回收机制 首先介绍下dalvik的GC的过程.主要有有四个过程: 当gc被触发时候,其会去查找所有活动的对象,这个时候整个程序与虚拟机内部的所有线程就会挂起,这样目的是在较少的堆栈里找到所引用的对象.需要注意的是这个回收动作和应用程序非并发。 gc对符合条件的对象进行标记 gc对标记的对象进行回收 恢复所有线程的执行现场继续运行 dalvik这么做的好处是,当pause了之后,GC势必是相当快速的.但是如果出现GC频繁并且内存吃紧势必会导致UI卡顿,掉帧.操作不流畅等。 后来ART改善了这种GC方式 , 主要的改善点在将其非并发过程改变成了部分并发.还有就是对内存的重新分配管理。 当ART GC发生时: GC将会锁住Java堆,扫描并进行标记 标记完毕释放掉Java堆的锁,并且挂起所有线程 GC对标记的对象进行回收 恢复所有线程的执行现场继续运行 重复2-4直到结束 可以看出整个过程做到了部分并发使得时间缩短.据官方测试数据说gc效率提高2倍 提高内存使用，减少碎片化 Dalvik内存管理特点是:内存碎片化严重，当然这也是Mark and Sweep算法带来的弊端 可以看出每次gc后内存千疮百孔，本来连续分配的内存块变得碎片化严重，之后再分配进入的对象再进行内存寻址变得困难。 ART的解决:在ART中,它将Java分了一块空间命名为Large-Object-Space,这块内存空间的引入用来专门存放large object。同时ART又引入了moving collector的技术,即将不连续的物理内存块进行对齐.对齐了后内存碎片化就得到了很好的解决.Large-Object-Space的引入一是因为moving collector对大块内存的位移时间成本太高,而且提高内存的利用率根官方统计，ART的内存利用率提高10倍了左右。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Dalvik</tag>
        <tag>Art</tag>
        <tag>Jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[View测量、布局及绘制原理]]></title>
    <url>%2F2018%2F06%2F07%2FView%E6%B5%8B%E9%87%8F%E3%80%81%E5%B8%83%E5%B1%80%E5%8F%8A%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[http://blog.csdn.net/singwhatiwanna/article/details/38168103http://blog.csdn.net/singwhatiwanna/article/details/38426471 一、View绘制的流程框架 View的绘制是从上往下一层层迭代下来的。DecorView–&gt;ViewGroup（—&gt;ViewGroup）–&gt;View ，按照这个流程从上往下，依次measure(测量),layout(布局),draw(绘制)。 二、Measure流程顾名思义，就是测量每个控件的大小。 调用measure()方法，进行一些逻辑处理，然后调用onMeasure()方法，在其中调用setMeasuredDimension()设定View的宽高信息，完成View的测量操作。 12public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;&#125; measure()方法中，传入了两个参数 widthMeasureSpec, heightMeasureSpec 表示View的宽高的一些信息。 1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125; 由上述流程来看Measure流程很简单，关键点是在于widthMeasureSpec, heightMeasureSpec这两个参数信息怎么获得？ 如果有了widthMeasureSpec, heightMeasureSpec，通过一定的处理(可以重写，自定义处理步骤)，从中获取View的宽/高，调用setMeasuredDimension()方法，指定View的宽高，完成测量工作。 MeasureSpec的确定先介绍下什么是MeasureSpec？ MeasureSpec由两部分组成，一部分是测量模式，另一部分是测量的尺寸大小。 其中，Mode模式共分为三类 UNSPECIFIED ：不对View进行任何限制，要多大给多大，一般用于系统内部 EXACTLY：对应LayoutParams中的match_parent和具体数值这两种模式。检测到View所需要的精确大小，这时候View的最终大小就是SpecSize所指定的值， AT_MOST ：对应LayoutParams中的wrap_content。View的大小不能大于父容器的大小。 那么MeasureSpec又是如何确定的？ 对于DecorView，其确定是通过屏幕的大小，和自身的布局参数LayoutParams。 这部分很简单，根据LayoutParams的布局格式（match_parent，wrap_content或指定大小），将自身大小，和屏幕大小相比，设置一个不超过屏幕大小的宽高，以及对应模式。 对于其他View（包括ViewGroup），其确定是通过父布局的MeasureSpec和自身的布局参数LayoutParams。 这部分比较复杂。以下列图表表示不同的情况： 当子View的LayoutParams的布局格式是wrap_content，可以看到子View的大小是父View的剩余尺寸，和设置成match_parent时，子View的大小没有区别。为了显示区别，一般在自定义View时，需要重写onMeasure方法，处理wrap_content时的情况，进行特别指定。 从这里看出MeasureSpec的指定也是从顶层布局开始一层层往下去，父布局影响子布局。 可能关于MeasureSpec如何确定View大小还有些模糊，篇幅有限，没详细具体展开介绍，可以看这篇文章 View的测量流程： 三、Layout流程测量完View大小后，就需要将View布局在Window中，View的布局主要通过确定上下左右四个点来确定的。 其中布局也是自上而下，不同的是ViewGroup先在layout()中确定自己的布局，然后在onLayout()方法中再调用子View的layout()方法，让子View布局。在Measure过程中，ViewGroup一般是先测量子View的大小，然后再确定自身的大小。 123456789101112131415161718192021public void layout(int l, int t, int r, int b) &#123; // 当前视图的四个顶点 int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; // setFrame（） / setOpticalFrame（）：确定View自身的位置 // 即初始化四个顶点的值，然后判断当前View大小和位置是否发生了变化并返回 boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); //如果视图的大小和位置发生变化，会调用onLayout（） if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123; // onLayout（）：确定该View所有的子View在父容器的位置 onLayout(changed, l, t, r, b); ...&#125; 上面看出通过 setFrame（） / setOpticalFrame（）：确定View自身的位置，通过onLayout()确定子View的布局。setOpticalFrame（）内部也是调用了setFrame（），所以具体看setFrame（）怎么确定自身的位置布局。 1234567891011protected boolean setFrame(int left, int top, int right, int bottom) &#123; ...// 通过以下赋值语句记录下了视图的位置信息，即确定View的四个顶点// 即确定了视图的位置 mLeft = left; mTop = top; mRight = right; mBottom = bottom; mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);&#125; 确定了自身的位置后，就要通过onLayout()确定子View的布局。onLayout()是一个可继承的空方法。 12protected void onLayout(boolean changed, int left, int top, int right, int bottom) &#123; &#125; 如果当前View就是一个单一的View，那么没有子View，就不需要实现该方法。 如果当前View是一个ViewGroup，就需要实现onLayout方法，该方法的实现个自定义ViewGroup时其特性有关，必须自己实现。 由此便完成了一层层的的布局工作。 View的布局流程： 四、Draw过程View的绘制过程遵循如下几步： ①绘制背景 background.draw(canvas) ②绘制自己（onDraw） ③绘制Children(dispatchDraw) ④绘制装饰（onDrawScrollBars） 从源码中可以清楚地看出绘制的顺序。 123456789101112131415161718192021222324252627282930313233343536public void draw(Canvas canvas) &#123;// 所有的视图最终都是调用 View 的 draw （）绘制视图（ ViewGroup 没有复写此方法）// 在自定义View时，不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制。// 如果自定义的视图确实要复写该方法，那么需要先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制。 ... int saveCount; if (!dirtyOpaque) &#123; // 步骤1： 绘制本身View背景 drawBackground(canvas); &#125; // 如果有必要，就保存图层（还有一个复原图层） // 优化技巧： // 当不需要绘制 Layer 时，“保存图层“和“复原图层“这两步会跳过 // 因此在绘制的时候，节省 layer 可以提高绘制效率 final int viewFlags = mViewFlags; if (!verticalEdges &amp;&amp; !horizontalEdges) &#123; if (!dirtyOpaque) // 步骤2：绘制本身View内容 默认为空实现， 自定义View时需要进行复写 onDraw(canvas); ...... // 步骤3：绘制子View 默认为空实现 单一View中不需要实现，ViewGroup中已经实现该方法 dispatchDraw(canvas); ........ // 步骤4：绘制滑动条和前景色等等 onDrawScrollBars(canvas); .......... return; &#125; ... &#125; 无论是ViewGroup还是单一的View，都需要实现这套流程，不同的是，在ViewGroup中，实现了 dispatchDraw()方法，而在单一子View中不需要实现该方法。自定义View一般要重写onDraw()方法，在其中绘制不同的样式。 View绘制流程： 五、总结从View的测量、布局和绘制原理来看，要实现自定义View，根据自定义View的种类不同，可能分别要自定义实现不同的方法。但是这些方法不外乎：onMeasure()方法，onLayout()方法，onDraw()方法。 onMeasure()方法：单一View，一般重写此方法，针对wrap_content情况，规定View默认的大小值，避免于match_parent情况一致。ViewGroup，若不重写，就会执行和单子View中相同逻辑，不会测量子View。一般会重写onMeasure()方法，循环测量子View。 onLayout()方法:单一View，不需要实现该方法。ViewGroup必须实现，该方法是个抽象方法，实现该方法，来对子View进行布局。 onDraw()方法：无论单一View，或者ViewGroup都需要实现该方法，因其是个空方法]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window、Activity、DecorView以及ViewRoot之间的关系]]></title>
    <url>%2F2018%2F06%2F07%2FWindow%E3%80%81Activity%E3%80%81DecorView%E4%BB%A5%E5%8F%8AViewRoot%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[一、职能简介ActivityActivity并不负责视图控制，它只是控制生命周期和处理事件。真正控制视图的是Window。一个Activity包含了一个Window，Window才是真正代表一个窗口。Activity就像一个控制器，统筹视图的添加与显示，以及通过其他回调方法，来与Window、以及View进行交互。 WindowWindow是视图的承载器，内部持有一个 DecorView，而这个DecorView才是 view 的根布局。Window是一个抽象类，实际在Activity中持有的是其子类PhoneWindow。PhoneWindow中有个内部类DecorView，通过创建DecorView来加载Activity中设置的布局R.layout.activity_main。Window 通过WindowManager将DecorView加载其中，并将DecorView交给ViewRoot，进行视图绘制以及其他交互。 DecorViewDecorView是FrameLayout的子类，它可以被认为是Android视图树的根节点视图。DecorView作为顶级View，一般情况下它内部包含一个竖直方向的LinearLayout，在这个LinearLayout里面有上下三个部分，上面是个ViewStub,延迟加载的视图（应该是设置ActionBar,根据Theme设置），中间的是标题栏(根据Theme设置，有的布局没有)，下面的是内容栏。具体情况和Android版本及主体有关，以其中一个布局为例，如下所示： 1234567891011121314151617181920212223242526272829&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:fitsSystemWindows="true"&gt; &lt;!-- Popout bar for action modes --&gt; &lt;ViewStub android:id="@+id/action_mode_bar_stub" android:inflatedId="@+id/action_mode_bar" android:layout="@layout/action_mode_bar" android:layout_width="match_parent" android:layout_height="wrap_content" android:theme="?attr/actionBarTheme" /&gt; &lt;FrameLayout android:layout_width="match_parent" android:layout_height="?android:attr/windowTitleSize" style="?android:attr/windowTitleBackgroundStyle"&gt; &lt;TextView android:id="@android:id/title" style="?android:attr/windowTitleStyle" android:background="@null" android:fadingEdge="horizontal" android:gravity="center_vertical" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; &lt;/FrameLayout&gt; &lt;FrameLayout android:id="@android:id/content" android:layout_width="match_parent" android:layout_height="0dip" android:layout_weight="1" android:foregroundGravity="fill_horizontal|top" android:foreground="?android:attr/windowContentOverlay" /&gt;&lt;/LinearLayout&gt; 在Activity中通过setContentView所设置的布局文件其实就是被加到内容栏之中的，成为其唯一子View，就是上面的id为content的FrameLayout中，在代码中可以通过content来得到对应加载的布局。 12ViewGroup content = (ViewGroup)findViewById(android.R.id.content);ViewGroup rootView = (ViewGroup) content.getChildAt(0); ViewRootViewRoot可能比较陌生，但是其作用非常重大。所有View的绘制以及事件分发等交互都是通过它来执行或传递的。 ViewRoot对应ViewRootImpl类，它是连接WindowManagerService和DecorView的纽带，View的三大流程(测量（measure），布局（layout），绘制（draw）)均通过ViewRoot来完成。 ViewRoot并不属于View树的一份子。从源码实现上来看，它既非View的子类，也非View的父类，但是，它实现了ViewParent接口，这让它可以作为View的名义上的父视图。RootView继承了Handler类，可以接收事件并分发，Android的所有触屏事件、按键事件、界面刷新等事件都是通过ViewRoot进行分发的。 下面结构图可以清晰的揭示四者之间的关系： 二、DecorView的创建这部分内容主要讲DecorView是怎么一层层嵌套在Actvity，PhoneWindow中的，以及DecorView如何加载内部布局。 setContentView先是从Activity中的setContentView()开始。 1234public void setContentView(@LayoutRes int layoutResID) &#123; getWindow().setContentView(layoutResID); initWindowDecorActionBar(); &#125; 可以看到实际是交给Window装载视图。下面来看看Activity是怎么获得Window对象的？ 12345678910111213141516171819final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) &#123; .................................................................. mWindow = new PhoneWindow(this, window);//创建一个Window对象 mWindow.setWindowControllerCallback(this); mWindow.setCallback(this);//设置回调，向Activity分发点击或状态改变等事件 mWindow.setOnWindowDismissedCallback(this); ................................................................. mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);//给Window设置WindowManager对象.................................................................... &#125; 在Activity中的attach()方法中，生成了PhoneWindow实例。既然有了Window对象，那么我们就可以设置DecorView给Window对象了。 123456789101112public void setContentView(int layoutResID) &#123; if (mContentParent == null) &#123;//mContentParent为空，创建一个DecroView installDecor(); &#125; else &#123; mContentParent.removeAllViews();//mContentParent不为空，删除其中的View &#125; mLayoutInflater.inflate(layoutResID, mContentParent);//为mContentParent添加子View,即Activity中设置的布局文件 final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged();//回调通知，内容改变 &#125; &#125; 看了下来，可能有一个疑惑：mContentParent到底是什么？就是前面布局中@android:id/content所对应的FrameLayout。 通过上面的流程我们大致可以了解先在PhoneWindow中创建了一个DecroView，其中创建的过程中可能根据Theme不同，加载不同的布局格式，例如有没有Title，或有没有ActionBar等，然后再向mContentParent中加入子View,即Activity中设置的布局。到此位置，视图一层层嵌套添加上了。 下面具体来看看installDecor();方法，怎么创建的DecroView，并设置其整体布局？ 123456789101112131415private void installDecor() &#123; if (mDecor == null) &#123; mDecor = generateDecor(); //生成DecorView mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; if (mContentParent == null) &#123; mContentParent = generateLayout(mDecor); // 为DecorView设置布局格式，并返回mContentParent ... &#125; &#125;&#125; 再来看看 generateDecor() 123protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1); &#125; 很简单，创建了一个DecorView。 再看generateLayout 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849protected ViewGroup generateLayout(DecorView decor) &#123; // 从主题文件中获取样式信息 TypedArray a = getWindowStyle(); ................... if (a.getBoolean(R.styleable.Window_windowNoTitle, false)) &#123; requestFeature(FEATURE_NO_TITLE); &#125; else if (a.getBoolean(R.styleable.Window_windowActionBar, false)) &#123; // Don't allow an action bar if there is no title. requestFeature(FEATURE_ACTION_BAR); &#125; ................ // 根据主题样式，加载窗口布局 int layoutResource; int features = getLocalFeatures(); // System.out.println("Features: 0x" + Integer.toHexString(features)); if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; layoutResource = R.layout.screen_swipe_dismiss; &#125; else if(...)&#123; ... &#125; View in = mLayoutInflater.inflate(layoutResource, null); //加载layoutResource //往DecorView中添加子View，即文章开头介绍DecorView时提到的布局格式，那只是一个例子，根据主题样式不同，加载不同的布局。 decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); // 这里获取的就是mContentParent if (contentParent == null) &#123; throw new RuntimeException("Window couldn't find content container view"); &#125; if ((features &amp; (1 &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != 0) &#123; ProgressBar progress = getCircularProgressBar(false); if (progress != null) &#123; progress.setIndeterminate(true); &#125; &#125; if ((features &amp; (1 &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != 0) &#123; registerSwipeCallbacks(); &#125; // Remaining setup -- of background and title -- that only applies // to top-level windows. ... return contentParent; &#125; 虽然比较复杂，但是逻辑还是很清楚的。先从主题中获取样式，然后根据样式，加载对应的布局到DecorView中，然后从中获取mContentParent。获得到之后，可以回到上面的代码，为mContentParent添加View，即Activity中的布局。 以上就是DecorView的创建过程，其实到installDecor()就已经介绍完了，后面只是具体介绍其中的逻辑。 三、DecorView的显示以上仅仅是将DecorView建立起来。通过setContentView()设置的界面，为什么在onResume()之后才对用户可见呢？ 这就要从ActivityThread开始说起。 1234567891011121314151617181920212223private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; //就是在这里调用了Activity.attach()呀，接着调用了Activity.onCreate()和Activity.onStart()生命周期， //但是由于只是初始化了mDecor，添加了布局文件，还没有把 //mDecor添加到负责UI显示的PhoneWindow中，所以这时候对用户来说，是不可见的 Activity a = performLaunchActivity(r, customIntent); ...... if (a != null) &#123; //这里面执行了Activity.onResume() handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); if (!r.activity.mFinished &amp;&amp; r.startsNotResumed) &#123; try &#123; r.activity.mCalled = false; //执行Activity.onPause() mInstrumentation.callActivityOnPause(r.activity); &#125; &#125; &#125;&#125; 重点看下handleResumeActivity(),在这其中，DecorView将会显示出来，同时重要的一个角色：ViewRoot也将登场。 123456789101112131415161718192021222324252627282930313233final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; //这个时候，Activity.onResume()已经调用了，但是现在界面还是不可见的 ActivityClientRecord r = performResumeActivity(token, clearHide); if (r != null) &#123; final Activity a = r.activity; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); //decor对用户不可见 decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; //被添加进WindowManager了，但是这个时候，还是不可见的 wm.addView(decor, l); &#125; if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) &#123; //在这里，执行了重要的操作,使得DecorView可见 if (r.activity.mVisibleFromClient) &#123; r.activity.makeVisible(); &#125; &#125; &#125; 当我们执行了Activity.makeVisible()方法之后，界面才对我们是可见的。 12345678void makeVisible() &#123; if (!mWindowAdded) &#123; ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes());//将DecorView添加到WindowManager mWindowAdded = true; &#125; mDecor.setVisibility(View.VISIBLE);//DecorView可见 &#125; 到此DecorView便可见，显示在屏幕中。但是在这其中,wm.addView(mDecor, getWindow().getAttributes());起到了重要的作用，因为其内部创建了一个ViewRootImpl对象，负责绘制显示各个子View。 具体来看addView()方法，因为WindowManager是个接口，具体是交给WindowManagerImpl来实现的。 12345678public final class WindowManagerImpl implements WindowManager &#123; private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance(); ... @Override public void addView(View view, ViewGroup.LayoutParams params) &#123; mGlobal.addView(view, params, mDisplay, mParentWindow); &#125;&#125; 交给WindowManagerGlobal 的addView()方法去实现 1234567891011121314151617181920212223242526public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) &#123; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params; ...... synchronized (mLock) &#123; ViewRootImpl root; //实例化一个ViewRootImpl对象 root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); &#125; ...... try &#123; //将DecorView交给ViewRootImpl root.setView(view, wparams, panelParentView); &#125;catch (RuntimeException e) &#123; &#125; &#125; &#125; 看到其中实例化了ViewRootImpl对象，然后调用其setView()方法。其中setView()方法经过一些列折腾，最终调用了performTraversals()方法，然后依照下图流程层层调用，完成绘制，最终界面才显示出来。 其实ViewRootImpl的作用不止如此，还有许多功能，如事件分发。 要知道，当用户点击屏幕产生一个触摸行为，这个触摸行为则是通过底层硬件来传递捕获，然后交给ViewRootImpl，接着将事件传递给DecorView，而DecorView再交给PhoneWindow，PhoneWindow再交给Activity，然后接下来就是我们常见的View事件分发了。 硬件 -&gt; ViewRootImpl -&gt; DecorView -&gt; PhoneWindow -&gt; Activity 不详细介绍了，如果感兴趣，可以看这篇文章。 由此可见ViewRootImpl的重要性，是个连接器，负责WindowManagerService与DecorView之间的通信。 四、总结以上通过源码形式介绍了Window、Activity、DecorView以及ViewRoot之间的错综关系，以及如何创建并显示DecorView。 通过以上了解可以知道，Activity就像个控制器，不负责视图部分。Window像个承载器，装着内部视图。DecorView就是个顶层视图，是所有View的最外层布局。ViewRoot像个连接器，负责沟通，通过硬件的感知来通知视图，进行用户之间的交互。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
        <tag>Window</tag>
        <tag>DecorView</tag>
        <tag>ViewRoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LruCache原理解析]]></title>
    <url>%2F2018%2F06%2F07%2FLruCache%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[一、Android中的缓存策略一般来说，缓存策略主要包含缓存的添加、获取和删除这三类操作。如何添加和获取缓存这个比较好理解，那么为什么还要删除缓存呢？这是因为不管是内存缓存还是硬盘缓存，它们的缓存大小都是有限的。当缓存满了之后，再想其添加缓存，这个时候就需要删除一些旧的缓存并添加新的缓存。 因此LRU(Least Recently Used)缓存算法便应运而生，LRU是近期最少使用的算法，它的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。采用LRU算法的缓存有两种：LrhCache和DisLruCache，分别用于实现内存缓存和硬盘缓存，其核心思想都是LRU缓存算法。 二、LruCache的使用LruCache是Android 3.1所提供的一个缓存类，所以在Android中可以直接使用LruCache实现内存缓存。而DisLruCache目前在Android 还不是Android SDK的一部分，但Android官方文档推荐使用该算法来实现硬盘缓存。 1.LruCache的介绍LruCache是个泛型类，主要算法原理是把最近使用的对象用强引用（即我们平常使用的对象引用方式）存储在 LinkedHashMap 中。当缓存满时，把最近最少使用的对象从内存中移除，并提供了get和put方法来完成缓存的获取和添加操作。 2.LruCache的使用LruCache的使用非常简单，我们就已图片缓存为例。 12345678int maxMemory = (int) (Runtime.getRuntime().totalMemory()/1024); int cacheSize = maxMemory/8; mMemoryCache = new LruCache&lt;String,Bitmap&gt;(cacheSize)&#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes()*value.getHeight()/1024; &#125; &#125;; ①设置LruCache缓存的大小，一般为当前进程可用容量的1/8。②重写sizeOf方法，计算出要缓存的每张图片的大小。 注意：缓存的总容量和每个缓存对象的大小所用单位要一致。 三、LruCache的实现原理LruCache的核心思想很好理解，就是要维护一个缓存对象列表，其中对象列表的排列方式是按照访问顺序实现的，即一直没访问的对象，将放在队尾，即将被淘汰。而最近访问的对象将放在队头，最后被淘汰。 如下图所示： 那么这个队列到底是由谁来维护的，前面已经介绍了是由LinkedHashMap来维护。 而LinkedHashMap是由数组+双向链表的数据结构来实现的。其中双向链表的结构可以实现访问顺序和插入顺序，使得LinkedHashMap中的对按照一定顺序排列起来。 通过下面构造函数来指定LinkedHashMap中双向链表的结构是访问顺序还是插入顺序。 123456public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder; &#125; 其中accessOrder设置为true则为访问顺序，为false，则为插入顺序。 以具体例子解释：当设置为true时 1234567891011121314151617public static final void main(String[] args) &#123; LinkedHashMap&lt;Integer, Integer&gt; map = new LinkedHashMap&lt;&gt;(0, 0.75f, true); map.put(0, 0); map.put(1, 1); map.put(2, 2); map.put(3, 3); map.put(4, 4); map.put(5, 5); map.put(6, 6); map.get(1); map.get(2); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println(entry.getKey() + ":" + entry.getValue()); &#125; &#125; 输出结果： 0:03:34:45:56:61:12:2 即最近访问的最后输出，那么这就正好满足的LRU缓存算法的思想。可见LruCache巧妙实现，就是利用了LinkedHashMap的这种数据结构。 下面我们在LruCache源码中具体看看，怎么应用LinkedHashMap来实现缓存的添加，获得和删除的。 1234567public LruCache(int maxSize) &#123; if (maxSize &lt;= 0) &#123; throw new IllegalArgumentException("maxSize &lt;= 0"); &#125; this.maxSize = maxSize; this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true); &#125; 从LruCache的构造函数中可以看到正是用了LinkedHashMap的访问顺序。 put()方法 1234567891011121314151617181920212223242526public final V put(K key, V value) &#123; //不可为空，否则抛出异常 if (key == null || value == null) &#123; throw new NullPointerException("key == null || value == null"); &#125; V previous; synchronized (this) &#123; //插入的缓存对象值加1 putCount++; //增加已有缓存的大小 size += safeSizeOf(key, value); //向map中加入缓存对象 previous = map.put(key, value); //如果已有缓存对象，则缓存大小恢复到之前 if (previous != null) &#123; size -= safeSizeOf(key, previous); &#125; &#125; //entryRemoved()是个空方法，可以自行实现 if (previous != null) &#123; entryRemoved(false, key, previous, value); &#125; //调整缓存大小(关键方法) trimToSize(maxSize); return previous; &#125; 可以看到put()方法并没有什么难点，重要的就是在添加过缓存对象后，调用 trimToSize()方法，来判断缓存是否已满，如果满了就要删除近期最少使用的算法。 trimToSize()方法 123456789101112131415161718192021222324252627public void trimToSize(int maxSize) &#123; //死循环 while (true) &#123; K key; V value; synchronized (this) &#123; //如果map为空并且缓存size不等于0或者缓存size小于0，抛出异常 if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) &#123; throw new IllegalStateException(getClass().getName() + ".sizeOf() is reporting inconsistent results!"); &#125; //如果缓存大小size小于最大缓存，或者map为空，不需要再删除缓存对象，跳出循环 if (size &lt;= maxSize || map.isEmpty()) &#123; break; &#125; //迭代器获取第一个对象，即队尾的元素，近期最少访问的元素 Map.Entry&lt;K, V&gt; toEvict = map.entrySet().iterator().next(); key = toEvict.getKey(); value = toEvict.getValue(); //删除该对象，并更新缓存大小 map.remove(key); size -= safeSizeOf(key, value); evictionCount++; &#125; entryRemoved(true, key, value, null); &#125; &#125; trimToSize()方法不断地删除LinkedHashMap中队尾的元素，即近期最少访问的，直到缓存大小小于最大值。 当调用LruCache的get()方法获取集合中的缓存对象时，就代表访问了一次该元素，将会更新队列，保持整个队列是按照访问顺序排序。这个更新过程就是在LinkedHashMap中的get()方法中完成的。 先看LruCache的get()方法 get()方法 1234567891011121314151617public final V get(K key) &#123; //key为空抛出异常 if (key == null) &#123; throw new NullPointerException("key == null"); &#125; V mapValue; synchronized (this) &#123; //获取对应的缓存对象 //get()方法会实现将访问的元素更新到队列头部的功能 mapValue = map.get(key); if (mapValue != null) &#123; hitCount++; return mapValue; &#125; missCount++; &#125; 其中LinkedHashMap的get()方法如下： 12345678public V get(Object key) &#123; LinkedHashMapEntry&lt;K,V&gt; e = (LinkedHashMapEntry&lt;K,V&gt;)getEntry(key); if (e == null) return null; //实现排序的关键方法 e.recordAccess(this); return e.value; &#125; 调用recordAccess()方法如下： 1234567891011void recordAccess(HashMap&lt;K,V&gt; m) &#123; LinkedHashMap&lt;K,V&gt; lm = (LinkedHashMap&lt;K,V&gt;)m; //判断是否是访问排序 if (lm.accessOrder) &#123; lm.modCount++; //删除此元素 remove(); //将此元素移动到队列的头部 addBefore(lm.header); &#125; &#125; 由此可见LruCache中维护了一个集合LinkedHashMap，该LinkedHashMap是以访问顺序排序的。当调用put()方法时，就会在结合中添加元素，并调用trimToSize()判断缓存是否已满，如果满了就用LinkedHashMap的迭代器删除队尾元素，即近期最少访问的元素。当调用get()方法访问缓存对象时，就会调用LinkedHashMap的get()方法获得对应集合元素，同时会更新该元素到队头。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>LruCache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IntentService详解]]></title>
    <url>%2F2018%2F06%2F07%2FIntentService%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、 定义IntentService是Android里面的一个封装类，继承自四大组件之一的Service。 二、作用处理异步请求，实现多线程 三、 工作流程 注意：若启动IntentService 多次，那么每个耗时操作则以队列的方式在 IntentService的onHandleIntent回调方法中依次执行，执行完自动结束。 四、实现步骤 步骤1：定义IntentService的子类：传入线程名称、复写onHandleIntent()方法 步骤2：在Manifest.xml中注册服务 步骤3：在Activity中开启Service服务 五、具体实例 步骤1：定义IntentService的子类：传入线程名称、复写onHandleIntent()方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.example.carson_ho.demoforintentservice;import android.app.IntentService;import android.content.Intent;import android.util.Log;/** * Created by Carson_Ho on 16/9/28. */public class myIntentService extends IntentService &#123; /*构造函数*/ public myIntentService() &#123; //调用父类的构造函数 //构造函数参数=工作线程的名字 super("myIntentService"); &#125; /*复写onHandleIntent()方法*/ //实现耗时任务的操作 @Override protected void onHandleIntent(Intent intent) &#123; //根据Intent的不同进行不同的事务处理 String taskName = intent.getExtras().getString("taskName"); switch (taskName) &#123; case "task1": Log.i("myIntentService", "do task1"); break; case "task2": Log.i("myIntentService", "do task2"); break; default: break; &#125; &#125; @Override public void onCreate() &#123; Log.i("myIntentService", "onCreate"); super.onCreate(); &#125; /*复写onStartCommand()方法*/ //默认实现将请求的Intent添加到工作队列里 @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i("myIntentService", "onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; Log.i("myIntentService", "onDestroy"); super.onDestroy(); &#125;&#125; 步骤2：在Manifest.xml中注册服务 12345&lt;service android:name=".myIntentService"&gt; &lt;intent-filter &gt; &lt;action android:name="cn.scu.finch"/&gt; &lt;/intent-filter&gt; &lt;/service&gt; 步骤3：在Activity中开启Service服务 12345678910111213141516171819202122232425262728293031package com.example.carson_ho.demoforintentservice;import android.content.Intent;import android.os.Bundle;import android.support.v7.app.AppCompatActivity;public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //同一服务只会开启一个工作线程 //在onHandleIntent函数里依次处理intent请求。 Intent i = new Intent("cn.scu.finch"); Bundle bundle = new Bundle(); bundle.putString("taskName", "task1"); i.putExtras(bundle); startService(i); Intent i2 = new Intent("cn.scu.finch"); Bundle bundle2 = new Bundle(); bundle2.putString("taskName", "task2"); i2.putExtras(bundle2); startService(i2); startService(i); //多次启动 &#125; &#125; 结果 六、源码分析接下来，我们会通过源码分析解决以下问题： IntentService如何单独开启一个新的工作线程； IntentService如何通过onStartCommand()传递给服务intent被依次插入到工作队列中 问题1：IntentService如何单独开启一个新的工作线程 123456789101112131415161718192021222324252627282930313233343536// IntentService源码中的 onCreate() 方法@Overridepublic void onCreate() &#123; super.onCreate(); // HandlerThread继承自Thread，内部封装了 Looper //通过实例化HandlerThread新建线程并启动 //所以使用IntentService时不需要额外新建线程 HandlerThread thread = new HandlerThread("IntentService[" + mName + "]"); thread.start(); //获得工作线程的 Looper，并维护自己的工作队列 mServiceLooper = thread.getLooper(); //将上述获得Looper与新建的mServiceHandler进行绑定 //新建的Handler是属于工作线程的。 mServiceHandler = new ServiceHandler(mServiceLooper);&#125;private final class ServiceHandler extends Handler &#123; public ServiceHandler(Looper looper) &#123; super(looper); &#125;//IntentService的handleMessage方法把接收的消息交给onHandleIntent()处理//onHandleIntent()是一个抽象方法，使用时需要重写的方法 @Override public void handleMessage(Message msg) &#123; // onHandleIntent 方法在工作线程中执行，执行完调用 stopSelf() 结束服务。 onHandleIntent((Intent)msg.obj); //onHandleIntent 处理完成后 IntentService会调用 stopSelf() 自动停止。 stopSelf(msg.arg1); &#125;&#125;////onHandleIntent()是一个抽象方法，使用时需要重写的方法@WorkerThreadprotected abstract void onHandleIntent(Intent intent); 问题2：IntentService如何通过onStartCommand()传递给服务intent被依次插入到工作队列中 12345678910111213141516171819public int onStartCommand(Intent intent, int flags, int startId) &#123; onStart(intent, startId); return mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;&#125;public void onStart(Intent intent, int startId) &#123; Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId;//把 intent 参数包装到 message 的 obj 中，然后发送消息，即添加到消息队列里//这里的Intent 就是启动服务时startService(Intent) 里的 Intent。 msg.obj = intent; mServiceHandler.sendMessage(msg);&#125;//清除消息队列中的消息@Overridepublic void onDestroy() &#123; mServiceLooper.quit();&#125; 总结 ​ 从上面源码可以看出，IntentService本质是采用Handler &amp; HandlerThread方式： 通过HandlerThread单独开启一个名为IntentService的线程 创建一个名叫ServiceHandler的内部Handler 把内部Handler与HandlerThread所对应的子线程进行绑定 通过onStartCommand()传递给服务intent，依次插入到工作队列中，并逐个发送给onHandleIntent() 通过onHandleIntent()来依次处理所有Intent请求对象所对应的任务 因此我们通过复写方法onHandleIntent()，再在里面根据Intent的不同进行不同的线程操作就可以了 注意事项 工作任务队列是顺序执行的。 如果一个任务正在IntentService中执行，此时你再发送一个新的任务请求，这个新的任务会一直等待直到前面一个任务执行完毕才开始执行 原因： 由于onCreate() 方法只会调用一次，所以只会创建一个工作线程； 当多次调用 startService(Intent) 时（onStartCommand也会调用多次）其实并不会创建新的工作线程，只是把消息加入消息队列中等待执行，所以，多次启动 IntentService 会按顺序执行事件 如果服务停止，会清除消息队列中的消息，后续的事件得不到执行。 七、使用场景 线程任务需要按顺序、在后台执行的使用场景 最常见的场景：离线下载 由于所有的任务都在同一个Thread looper里面来做，所以不符合多个数据同时请求的场景。 八、对比8.1 IntentService与Service的区别 从属性 &amp; 作用上来说Service：依赖于应用程序的主线程（不是独立的进程 or 线程） 不建议在Service中编写耗时的逻辑和操作，否则会引起ANR； IntentService：创建一个工作线程来处理多线程任务 Service需要主动调用stopSelft()来结束服务，而IntentService不需要（在所有intent被处理完后，系统会自动关闭服务） 8.2 IntentService与其他线程的区别 IntentService内部采用了HandlerThread实现，作用类似于后台线程； 与后台线程相比， IntentService是一种后台服务 ，优势是：优先级高（不容易被系统杀死），从而保证任务的执行 对于后台线程，若进程中没有活动的四大组件，则该线程的优先级非常低，容易被系统杀死，无法保证任务的执行 #]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>IntentService</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HandlerThread详解]]></title>
    <url>%2F2018%2F06%2F07%2FHandlerThread%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[我们知道在Android系统中，我们执行完耗时操作都要另外开启子线程来执行，执行完线程以后线程会自动销毁。想象一下如果我们在项目中经常要执行耗时操作，如果经常要开启线程，接着又销毁线程，这无疑是很消耗性能的?那有什么解决方法呢？ 使用线程池 使用HandlerThread 本篇文章主要讲解一下问题 HandlerThread的使用场景以及怎样使用HandlerThread？ HandlerThread源码分析 HandlerThread的使用场景以及怎样使用HandlerThread？使用场景HandlerThread是Google帮我们封装好的，可以用来执行多个耗时操作，而不需要多次开启线程，里面是采用handler和Looper实现的 Handy class for starting a new thread that has a looper. The looper can then be used to create handler classes. Note that start() must still be called. 怎样使用HandlerThread？ 创建HandlerThread的实例对象 1HandlerThread handlerThread = new HandlerThread("myHandlerThread"); 该参数表示线程的名字，可以随便选择。 启动我们创建的HandlerThread线程 1handlerThread.start(); 将我们的handlerThread与Handler绑定在一起。还记得是怎样将Handler与线程对象绑定在一起的吗？其实很简单，就是将线程的looper与Handler绑定在一起，代码如下： 123456789mThreadHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; checkForUpdate(); if(isUpdate)&#123; mThreadHandler.sendEmptyMessage(MSG_UPDATE_INFO); &#125; &#125;&#125;; 注意必须按照以上三个步骤来，下面在讲解源码的时候会分析其原因 完整测试代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class MainActivity extends AppCompatActivity &#123; private TextView mTv; Handler mMainHandler = new Handler(); private Handler mThreadHandler; private static final int MSG_UPDATE_INFO = 0x100; private HandlerThread mHandlerThread; private boolean isUpdate=true; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTv = (TextView) findViewById(R.id.tv); initHandlerThread(); &#125; private void initHandlerThread() &#123; mHandlerThread = new HandlerThread("xujun"); mHandlerThread.start(); mThreadHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; checkForUpdate(); if(isUpdate)&#123; mThreadHandler.sendEmptyMessage(MSG_UPDATE_INFO); &#125; &#125; &#125;; &#125; /** * 模拟从服务器解析数据 */ private void checkForUpdate() &#123; try &#123; //模拟耗时 Thread.sleep(1200); mMainHandler.post(new Runnable() &#123; @Override public void run() &#123; String result = "实时更新中，当前股票行情：&lt;font color='red'&gt;%d&lt;/font&gt;"; result = String.format(result, (int) (Math.random() * 5000 + 1000)); mTv.setText(Html.fromHtml(result)); &#125; &#125;); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void onResume() &#123; isUpdate=true; super.onResume(); mThreadHandler.sendEmptyMessage(MSG_UPDATE_INFO); &#125; @Override protected void onPause() &#123; super.onPause(); isUpdate=false; mThreadHandler.removeMessages(MSG_UPDATE_INFO); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mHandlerThread.quit(); mMainHandler.removeCallbacksAndMessages(null); &#125;&#125; 运行以上测试代码，将可以看到如下效果图(例子不太恰当，主要使用场景是在handleMessage中执行耗时操作) HandlerThread源码分析官方源代码如下，是基于sdk23的，可以看到，只有一百多行代码而已 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class HandlerThread extends Thread &#123; int mPriority; int mTid = -1; Looper mLooper; public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; /** * Call back method that can be explicitly overridden if needed to execute some * setup before Looper loops. */ protected void onLooperPrepared() &#123; &#125; @Override public void run() &#123; mTid = Process.myTid(); Looper.prepare(); //持有锁机制来获得当前线程的Looper对象 synchronized (this) &#123; mLooper = Looper.myLooper(); //发出通知，当前线程已经创建mLooper对象成功，这里主要是通知getLooper方法中的wait notifyAll(); &#125; //设置线程的优先级别 Process.setThreadPriority(mPriority); //这里默认是空方法的实现，我们可以重写这个方法来做一些线程开始之前的准备，方便扩展 onLooperPrepared(); Looper.loop(); mTid = -1; &#125; public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // 直到线程创建完Looper之后才能获得Looper对象，Looper未创建成功，阻塞 synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper; &#125; public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false; &#125; public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false; &#125; /** * Returns the identifier of this thread. See Process.myTid(). */ public int getThreadId() &#123; return mTid; &#125;&#125; 1）首先我们先来看一下它的构造方法12345678public HandlerThread(String name) &#123; super(name); mPriority = Process.THREAD_PRIORITY_DEFAULT; &#125; public HandlerThread(String name, int priority) &#123; super(name); mPriority = priority; &#125; 有两个构造方法，一个参数的和两个参数的，name代表当前线程的名称，priority为线程的优先级别 2）接着我们来看一下run（）方法，在run方法里面我们可以看到我们会初始化一个Looper，并设置线程的优先级别12345678910111213141516public void run() &#123; mTid = Process.myTid(); Looper.prepare(); //持有锁机制来获得当前线程的Looper对象 synchronized (this) &#123; mLooper = Looper.myLooper(); //发出通知，当前线程已经创建mLooper对象成功，这里主要是通知getLooper方法中的wait notifyAll(); &#125; //设置线程的优先级别 Process.setThreadPriority(mPriority); //这里默认是空方法的实现，我们可以重写这个方法来做一些线程开始之前的准备，方便扩展 onLooperPrepared(); Looper.loop(); mTid = -1;&#125; 还记得我们前面我们说到使用HandlerThread的时候必须调用start（）方法，接着才可以将我们的HandlerThread和我们的handler绑定在一起吗?其实原因就是我们是在run（）方法才开始初始化我们的looper，而我们调用HandlerThread的start（）方法的时候，线程会交给虚拟机调度，由虚拟机自动调用run方法 12345678910mHandlerThread.start();mThreadHandler = new Handler(mHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; checkForUpdate(); if(isUpdate)&#123; mThreadHandler.sendEmptyMessage(MSG_UPDATE_INFO); &#125; &#125;&#125;; 这里我们为什么要使用锁机制和notifyAll();，原因我们可以从getLooper（）方法中知道 123456789101112131415public Looper getLooper() &#123; if (!isAlive()) &#123; return null; &#125; // 直到线程创建完Looper之后才能获得Looper对象，Looper未创建成功，阻塞 synchronized (this) &#123; while (isAlive() &amp;&amp; mLooper == null) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125; return mLooper;&#125; 总结：在获得mLooper对象的时候存在一个同步的问题，只有当线程创建成功并且Looper对象也创建成功之后才能获得mLooper的值。这里等待方法wait和run方法中的notifyAll方法共同完成同步问题。 3)接着我们来看一下quit方法和quitSafe方法12345678910111213141516171819//调用这个方法退出Looper消息循环，及退出线程public boolean quit() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quit(); return true; &#125; return false;&#125;//调用这个方法安全地退出线程@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)public boolean quitSafely() &#123; Looper looper = getLooper(); if (looper != null) &#123; looper.quitSafely(); return true; &#125; return false;&#125; 跟踪这两个方法容易知道只两个方法最终都会调用MessageQueue的quit（boolean safe）方法 12345678910111213141516171819void quit(boolean safe) &#123; if (!mQuitAllowed) &#123; throw new IllegalStateException("Main thread not allowed to quit."); &#125; synchronized (this) &#123; if (mQuitting) &#123; return; &#125; mQuitting = true; //安全退出调用这个方法 if (safe) &#123; removeAllFutureMessagesLocked(); &#125; else &#123;//不安全退出调用这个方法 removeAllMessagesLocked(); &#125; // We can assume mPtr != 0 because mQuitting was previously false. nativeWake(mPtr); &#125;&#125; 不安全的会调用removeAllMessagesLocked();这个方法，我们来看这个方法是怎样处理的，其实就是遍历Message链表，移除所有信息的回调，并重置为null 123456789private void removeAllMessagesLocked() &#123; Message p = mMessages; while (p != null) &#123; Message n = p.next; p.recycleUnchecked(); p = n; &#125; mMessages = null;&#125; 安全地会调用removeAllFutureMessagesLocked();这个方法，它会根据Message.when这个属性，判断我们当前消息队列是否正在处理消息，没有正在处理消息的话，直接移除所有回调，正在处理的话，等待该消息处理处理完毕再退出该循环。因此说quitSafe（）是安全的，而quit（）方法是不安全的，因为quit方法不管是否正在处理消息，直接移除所有回调。 12345678910111213141516171819202122232425262728private void removeAllFutureMessagesLocked() &#123; final long now = SystemClock.uptimeMillis(); Message p = mMessages; if (p != null) &#123; //判断当前队列中的消息是否正在处理这个消息，》没有的话，直接移除所有回调 if (p.when &gt; now) &#123; removeAllMessagesLocked(); &#125; else &#123;//正在处理的话，等待该消息处理处理完毕再退出该循环 Message n; for (;;) &#123; n = p.next; if (n == null) &#123; return; &#125; if (n.when &gt; now) &#123; break; &#125; p = n; &#125; p.next = null; do &#123; p = n; n = p.next; p.recycleUnchecked(); &#125; while (n != null); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>HandlerThread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android事件分发机制]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、 基础认知1.1 事件分发的对象是谁？答：事件 当用户触摸屏幕时（View或ViewGroup派生的控件），将产生点击事件（Touch事件）。 Touch事件相关细节（发生触摸的位置、时间、历史记录、手势动作等）被封装成MotionEvent对象 主要发生的Touch事件有如下四种： MotionEvent.ACTION_DOWN：按下View（所有事件的开始） MotionEvent.ACTION_MOVE：滑动View MotionEvent.ACTION_CANCEL：非人为原因结束本次事件 MotionEvent.ACTION_UP：抬起View（与DOWN对应） 事件列：从手指接触屏幕至手指离开屏幕，这个过程产生的一系列事件任何事件列都是以DOWN事件开始，UP事件结束，中间有无数的MOVE事件，如下图： 即当一个MotionEvent 产生后，系统需要把这个事件传递给一个具体的 View 去处理, 1.2 事件分发的本质答：将点击事件（MotionEvent）向某个View进行传递并最终得到处理 即当一个点击事件发生后，系统需要将这个事件传递给一个具体的View去处理。这个事件传递的过程就是分发过程。 1.3 事件在哪些对象之间进行传递？答：Activity、ViewGroup、View 一个点击事件产生后，传递顺序是：Activity（Window） -&gt; ViewGroup -&gt; View Android的UI界面是由Activity、ViewGroup、View及其派生类组合而成的 View是所有UI组件的基类 一般Button、ImageView、TextView等控件都是继承父类View ViewGroup是容纳UI组件的容器，即一组View的集合（包含很多子View和子VewGroup）， 其本身也是从View派生的，即ViewGroup是View的子类 是Android所有布局的父类或间接父类：项目用到的布局（LinearLayout、RelativeLayout等），都继承自ViewGroup，即属于ViewGroup子类。 与普通View的区别：ViewGroup实际上也是一个View，只不过比起View，它多了可以包含子View和定义布局参数的功能。 1.4 事件分发过程由哪些方法协作完成？答：dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent() 下文会对这3个方法进行详细介绍 1.5 总结 Android事件分发机制的本质是要解决： 点击事件由哪个对象发出，经过哪些对象，最终达到哪个对象并最终得到处理。 这里的对象是指Activity、ViewGroup、View Android中事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View 事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成 经过上述3个问题，相信大家已经对Android的事件分发有了感性的认知，接下来，我将详细介绍Android事件分发机制。 二、 事件分发机制方法&amp;流程介绍 事件分发过程由dispatchTouchEvent() 、onInterceptTouchEvent()和onTouchEvent()三个方法协助完成，如下图： 方法详细介绍 Android事件分发流程如下：（必须熟记） Android事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View 其中： super：调用父类方法 true：消费事件，即事件不继续往下传递 false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理 接下来，我将详细介绍这3个方法及相关流程。 2.1 dispatchTouchEvent() 属性 介绍 使用对象 Activity、ViewGroup、View 作用 分发点击事件 调用时刻 当点击事件能够传递给当前View时，该方法就会被调用 返回结果 是否消费当前事件，详细情况如下： 1. 默认情况：根据当前对象的不同而返回方法不同 对象 返回方法 备注 Activity super.dispatchTouchEvent() 即调用父类ViewGroup的dispatchTouchEvent() ViewGroup onIntercepTouchEvent() 即调用自身的onIntercepTouchEvent() View onTouchEvent（） 即调用自身的onTouchEvent（） 流程解析 2. 返回true 消费事件 事件不会往下传递 后续事件（Move、Up）会继续分发到该View 流程图如下： 3. 返回false 不消费事件 事件不会往下传递 将事件回传给父控件的onTouchEvent()处理 Activity例外：返回false=消费事件 后续事件（Move、Up）会继续分发到该View(与onTouchEvent()区别） 流程图如下： 2.2 onTouchEvent() 属性 介绍 使用对象 Activity、ViewGroup、View 作用 处理点击事件 调用时刻 在dispatchTouchEvent()内部调用 返回结果 是否消费（处理）当前事件，详细情况如下： 与dispatchTouchEvent()类似 1. 返回true 自己处理（消费）该事情 事件停止传递 该事件序列的后续事件（Move、Up）让其处理； 流程图如下： 2. 返回false（同默认实现：调用父类onTouchEvent()） 不处理（消费）该事件 事件往上传递给父控件的onTouchEvent()处理 当前View不再接受此事件列的其他事件（Move、Up）； 流程图如下： 2.3 onInterceptTouchEvent() 属性 介绍 使用对象 ViewGroup（注：Activity、View都没该方法） 作用 拦截事件，即自己处理该事件 调用时刻 在ViewGroup的dispatchTouchEvent()内部调用 返回结果 是否拦截当前事件，详细情况如下： 返回结果 流程图如下： 2.4 三者关系下面将用一段伪代码来阐述上述三个方法的关系和点击事件传递规则 1234567891011121314151617181920212223// 点击事件产生后，会直接调用dispatchTouchEvent（）方法public boolean dispatchTouchEvent(MotionEvent ev) &#123; //代表是否消耗事件 boolean consume = false; if (onInterceptTouchEvent(ev)) &#123; //如果onInterceptTouchEvent()返回true则代表当前View拦截了点击事件 //则该点击事件则会交给当前View进行处理 //即调用onTouchEvent (）方法去处理点击事件 consume = onTouchEvent (ev) ; &#125; else &#123; //如果onInterceptTouchEvent()返回false则代表当前View不拦截点击事件 //则该点击事件则会继续传递给它的子元素 //子元素的dispatchTouchEvent（）就会被调用，重复上述过程 //直到点击事件被最终处理为止 consume = child.dispatchTouchEvent (ev) ; &#125; return consume; &#125; 2.5 总结 对于事件分发的3个方法，你应该清楚了解 接下来，我将开始介绍Android事件分发的常见流程 三、事件分发场景介绍下面我将利用例子来说明常见的点击事件传递情况 3.1 背景描述我们将要讨论的布局层次如下： 最外层：Activiy A，包含两个子View：ViewGroup B、View C 中间层：ViewGroup B，包含一个子View：View C 最内层：View C 假设用户首先触摸到屏幕上View C上的某个点（如图中黄色区域），那么Action_DOWN事件就在该点产生，然后用户移动手指并最后离开屏幕。 3.2 一般的事件传递情况一般的事件传递场景有： 默认情况 处理事件 拦截DOWN事件 拦截后续事件（MOVE、UP） 3.2.1 默认情况 即不对控件里的方法(dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent())进行重写或更改返回值 那么调用的是这3个方法的默认实现：调用父类的方法 事件传递情况：（如图下所示） 从Activity A—-&gt;ViewGroup B—&gt;View C，从上往下调用dispatchTouchEvent() 再由View C—&gt;ViewGroup B —&gt;Activity A，从下往上调用onTouchEvent() 注：虽然ViewGroup B的onInterceptTouchEvent方法对DOWN事件返回了false，后续的事件（MOVE、UP）依然会传递给它的onInterceptTouchEvent() 这一点与onTouchEvent的行为是不一样的。 3.2.2 处理事件假设View C希望处理这个点击事件，即C被设置成可点击的（Clickable）或者覆写了C的onTouchEvent方法返回true。 最常见的：设置Button按钮来响应点击事件 事件传递情况：（如下图） DOWN事件被传递给C的onTouchEvent方法，该方法返回true，表示处理这个事件 因为C正在处理这个事件，那么DOWN事件将不再往上传递给B和A的onTouchEvent()； 该事件列的其他事件（Move、Up）也将传递给C的onTouchEvent() 3.2.3 拦截DOWN事件假设ViewGroup B希望处理这个点击事件，即B覆写了onInterceptTouchEvent()返回true、onTouchEvent()返回true。事件传递情况：（如下图） DOWN事件被传递给B的onInterceptTouchEvent()方法，该方法返回true，表示拦截这个事件，即自己处理这个事件（不再往下传递） 调用onTouchEvent()处理事件（DOWN事件将不再往上传递给A的onTouchEvent()） 该事件列的其他事件（Move、Up）将直接传递给B的onTouchEvent() 该事件列的其他事件（Move、Up）将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。 3.2.4 拦截DOWN的后续事件假设ViewGroup B没有拦截DOWN事件（还是View C来处理DOWN事件），但它拦截了接下来的MOVE事件。 DOWN事件传递到C的onTouchEvent方法，返回了true。 在后续到来的MOVE事件，B的onInterceptTouchEvent方法返回true拦截该MOVE事件，但该事件并没有传递给B；这个MOVE事件将会被系统变成一个CANCEL事件传递给C的onTouchEvent方法 后续又来了一个MOVE事件，该MOVE事件才会直接传递给B的onTouchEvent() 后续事件将直接传递给B的onTouchEvent()处理 后续事件将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。 C再也不会收到该事件列产生的后续事件。 特别注意： 如果ViewGroup A 拦截了一个半路的事件（如MOVE），这个事件将会被系统变成一个CANCEL事件并传递给之前处理该事件的子View； 该事件不会再传递给ViewGroup A的onTouchEvent() 只有再到来的事件才会传递到ViewGroup A的onTouchEvent() 3.3 总结 对于Android的事件分发机制，你应该已经非常清楚了 如果你只是希望了解Android事件分发机制而不想深入了解，那么你可以离开这篇文章了 对于程序猿来说，知其然还需要知其所以然，接下来，我将通过源码分析来深入了解Android事件分发机制 四、Android事件分发机制源码分析 Android中事件分发顺序：Activity（Window） -&gt; ViewGroup -&gt; View，再次贴出下图： 其中： super：调用父类方法 true：消费事件，即事件不继续往下传递 false：不消费事件，事件继续往下传递 / 交由给父控件onTouchEvent（）处理 所以，要想充分理解Android分发机制，本质上是要理解： Activity对点击事件的分发机制 ViewGroup对点击事件的分发机制 View对点击事件的分发机制 接下来，我将通过源码分析详细介绍Activity、View和ViewGroup的事件分发机制 4.1 Activity的事件分发机制4.1.1 源码分析 当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发 具体是由Activity的Window来完成 我们来看下Activity的dispatchTouchEvent()的源码 12345678910111213public boolean dispatchTouchEvent(MotionEvent ev) &#123; //关注点1 //一般事件列开始都是DOWN，所以这里基本是true if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //关注点2 onUserInteraction(); &#125; //关注点3 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 关注点1一般事件列开始都是DOWN（按下按钮），所以这里返回true，执行onUserInteraction() 关注点2先来看下onUserInteraction()源码 123456789101112131415161718192021 /** * Called whenever a key, touch, or trackball event is dispatched to the * activity. Implement this method if you wish to know that the user has * interacted with the device in some way while your activity is running. * This callback and &#123;@link #onUserLeaveHint&#125; are intended to help * activities manage status bar notifications intelligently; specifically, * for helping activities determine the proper time to cancel a notfication. * * &lt;p&gt;All calls to your activity's &#123;@link #onUserLeaveHint&#125; callback will * be accompanied by calls to &#123;@link #onUserInteraction&#125;. This * ensures that your activity will be told of relevant user activity such * as pulling down the notification pane and touching an item there. * * &lt;p&gt;Note that this callback will be invoked for the touch down action * that begins a touch gesture, but may not be invoked for the touch-moved * and touch-up actions that follow. * * @see #onUserLeaveHint() */public void onUserInteraction() &#123; &#125; 从源码可以看出： 该方法为空方法 从注释得知：当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法 所以onUserInteraction()主要用于屏保 关注点3 Window类是抽象类，且PhoneWindow是Window类的唯一实现类 superDispatchTouchEvent(ev)是抽象方法 通过PhoneWindow类中看一下superDispatchTouchEvent()的作用 123456@Overridepublic boolean superDispatchTouchEvent(MotionEvent event) &#123; return mDecor.superDispatchTouchEvent(event);//mDecor是DecorView的实例//DecorView是视图的顶层view，继承自FrameLayout，是所有界面的父类&#125; 接下来我们看mDecor.superDispatchTouchEvent(event)： 1234567public boolean superDispatchTouchEvent(MotionEvent event) &#123; return super.dispatchTouchEvent(event);//DecorView继承自FrameLayout//那么它的父类就是ViewGroup而super.dispatchTouchEvent(event)方法，其实就应该是ViewGroup的dispatchTouchEvent()&#125; 所以： 执行getWindow().superDispatchTouchEvent(ev)实际上是执行了ViewGroup.dispatchTouchEvent(event) 再回到最初的代码： 123456789101112public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; //关注点2 onUserInteraction(); &#125; //关注点3 if (getWindow().superDispatchTouchEvent(ev)) &#123; return true; &#125; return onTouchEvent(ev); &#125; 由于一般事件列开始都是DOWN，所以这里返回true，基本上都会进入getWindow().superDispatchTouchEvent(ev)的判断 所以，执行Activity.dispatchTouchEvent(ev)实际上是执行了ViewGroup.dispatchTouchEvent(event) 这样事件就从 Activity 传递到了 ViewGroup 4.1.2 汇总当一个点击事件发生时，调用顺序如下 事件最先传到Activity的dispatchTouchEvent()进行事件分发 调用Window类实现类PhoneWindow的superDispatchTouchEvent() 调用DecorView的superDispatchTouchEvent() 最终调用DecorView父类的dispatchTouchEvent()，即ViewGroup的dispatchTouchEvent() 4.1.3 结论 当一个点击事件发生时，事件最先传到Activity的dispatchTouchEvent()进行事件分发，最终是调用了ViewGroup的dispatchTouchEvent()方法 这样事件就从 Activity 传递到了 ViewGroup 4.2 ViewGroup事件的分发机制在讲解ViewGroup事件的分发机制之前我们先来看个Demo 4.2.1 Demo讲解布局如下： 结果测试：只点击Button 再点击空白处 从上面的测试结果发现： 当点击Button时，执行Button的onClick()，但ViewGroupLayout注册的onTouch（）不会执行 只有点击空白区域时才会执行ViewGroupLayout的onTouch（）; 结论：Button的onClick()将事件消费掉了，因此事件不会再继续向下传递。 接下来，我们开始进行ViewGroup事件分发的源码分析 4.2.2 源码分析ViewGroup的dispatchTouchEvent()源码分析,该方法比较复杂，篇幅有限，就截取几个重要的逻辑片段进行介绍，来解析整个分发流程。 123456789101112131415161718// 发生ACTION_DOWN事件或者已经发生过ACTION_DOWN,并且将mFirstTouchTarget赋值，才进入此区域，主要功能是拦截器 final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN|| mFirstTouchTarget != null) &#123; //disallowIntercept：是否禁用事件拦截的功能(默认是false),即不禁用 //可以在子View通过调用requestDisallowInterceptTouchEvent方法对这个值进行修改，不让该View拦截事件 final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0; //默认情况下会进入该方法 if (!disallowIntercept) &#123; //调用拦截方法 intercepted = onInterceptTouchEvent(ev); ev.setAction(action); &#125; else &#123; intercepted = false; &#125; &#125; else &#123; // 当没有触摸targets，且不是down事件时，开始持续拦截触摸。 intercepted = true; &#125; 这一段的内容主要是为判断是否拦截。如果当前事件的MotionEvent.ACTION_DOWN，则进入判断，调用ViewGroup onInterceptTouchEvent()方法的值，判断是否拦截。如果mFirstTouchTarget != null，即已经发生过MotionEvent.ACTION_DOWN，并且该事件已经有ViewGroup的子View进行处理了，那么也进入判断，调用ViewGroup onInterceptTouchEvent()方法的值，判断是否拦截。如果不是以上两种情况，即已经是MOVE或UP事件了，并且之前的事件没有对象进行处理，则设置成true，开始拦截接下来的所有事件。这也就解释了如果子View的onTouchEvent()方法返回false，那么接下来的一些列事件都不会交给他处理。如果VieGroup的onInterceptTouchEvent()第一次执行为true，则mFirstTouchTarget = null，则也会使得接下来不会调用onInterceptTouchEvent()，直接将拦截设置为true。 当ViewGroup不拦截事件的时候，事件会向下分发交由它的子View或ViewGroup进行处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 /* 从最底层的父视图开始遍历， ** 找寻newTouchTarget，即上面的mFirstTouchTarget ** 如果已经存在找寻newTouchTarget，说明正在接收触摸事件，则跳出循环。 */for (int i = childrenCount - 1; i &gt;= 0; i--) &#123; final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i; final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex); // 如果当前视图无法获取用户焦点，则跳过本次循环 if (childWithAccessibilityFocus != null) &#123; if (childWithAccessibilityFocus != child) &#123; continue; &#125; childWithAccessibilityFocus = null; i = childrenCount - 1; &#125; //如果view不可见，或者触摸的坐标点不在view的范围内，则跳过本次循环 if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) &#123; ev.setTargetAccessibilityFocus(false); continue; &#125; newTouchTarget = getTouchTarget(child); // 已经开始接收触摸事件,并退出整个循环。 if (newTouchTarget != null) &#123; newTouchTarget.pointerIdBits |= idBitsToAssign; break; &#125; //重置取消或抬起标志位 //如果触摸位置在child的区域内，则把事件分发给子View或ViewGroup if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123; // 获取TouchDown的时间点 mLastTouchDownTime = ev.getDownTime(); // 获取TouchDown的Index if (preorderedList != null) &#123; for (int j = 0; j &lt; childrenCount; j++) &#123; if (children[childIndex] == mChildren[j]) &#123; mLastTouchDownIndex = j; break; &#125; &#125; &#125; else &#123; mLastTouchDownIndex = childIndex; &#125; //获取TouchDown的x,y坐标 mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); //添加TouchTarget,则mFirstTouchTarget != null。 newTouchTarget = addTouchTarget(child, idBitsToAssign); //表示以及分发给NewTouchTarget alreadyDispatchedToNewTouchTarget = true; break;&#125; dispatchTransformedTouchEvent()方法实际就是调用子元素的dispatchTouchEvent()方法。其中dispatchTransformedTouchEvent()方法的重要逻辑如下： 12345if (child == null) &#123; handled = super.dispatchTouchEvent(event); &#125; else &#123; handled = child.dispatchTouchEvent(event); &#125; 由于其中传递的child不为空，所以就会调用子元素的dispatchTouchEvent()。如果子元素的dispatchTouchEvent()方法返回true，那么mFirstTouchTarget就会被赋值，同时跳出for循环。 1234//添加TouchTarget,则mFirstTouchTarget != null。newTouchTarget = addTouchTarget(child, idBitsToAssign); //表示以及分发给NewTouchTarget alreadyDispatchedToNewTouchTarget = true; 其中在addTouchTarget(child, idBitsToAssign);内部完成mFirstTouchTarget被赋值。如果mFirstTouchTarget为空，将会让ViewGroup默认拦截所有操作。如果遍历所有子View或ViewGroup，都没有消费事件。ViewGroup会自己处理事件。 结论 Android事件分发是先传递到ViewGroup，再由ViewGroup传递到View 在ViewGroup中通过onInterceptTouchEvent()对事件传递进行拦截 onInterceptTouchEvent方法返回true代表拦截事件，即不允许事件继续向子View传递； 返回false代表不拦截事件，即允许事件继续向子View传递；（默认返回false） 子View中如果将传递的事件消费掉，ViewGroup中将无法接收到任何事件。 4.3 View事件的分发机制View中dispatchTouchEvent()的源码分析 1234567public boolean dispatchTouchEvent(MotionEvent event) &#123; if (mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event)) &#123; return true; &#125; return onTouchEvent(event); &#125; 从上面可以看出： 只有以下三个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent(event)方法 123第一个条件：mOnTouchListener != null；第二个条件：(mViewFlags &amp; ENABLED_MASK) == ENABLED；第三个条件：mOnTouchListener.onTouch(this, event)； 下面，我们来看看下这三个判断条件： 第一个条件：mOnTouchListener!= null 123456//mOnTouchListener是在View类下setOnTouchListener方法里赋值的public void setOnTouchListener(OnTouchListener l) &#123; //即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值（不为空） mOnTouchListener = l; &#125; 第二个条件：(mViewFlags &amp; ENABLED_MASK) == ENABLED 该条件是判断当前点击的控件是否enable 由于很多View默认是enable的，因此该条件恒定为true 第三个条件：mOnTouchListener.onTouch(this, event) 回调控件注册Touch事件时的onTouch方法 123456789//手动调用设置button.setOnTouchListener(new OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; return false; &#125; &#125;); 如果在onTouch方法返回true，就会让上述三个条件全部成立，从而整个方法直接返回true。 如果在onTouch方法里返回false，就会去执行onTouchEvent(event)方法。 接下来，我们继续看：onTouchEvent(event)的源码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public boolean onTouchEvent(MotionEvent event) &#123; final int viewFlags = mViewFlags; if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123; // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)); &#125; if (mTouchDelegate != null) &#123; if (mTouchDelegate.onTouchEvent(event)) &#123; return true; &#125; &#125; //如果该控件是可以点击的就会进入到下两行的switch判断中去； if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)) &#123; //如果当前的事件是抬起手指，则会进入到MotionEvent.ACTION_UP这个case当中。 switch (event.getAction()) &#123; case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PREPRESSED) != 0; // 在经过种种判断之后，会执行到关注点1的performClick()方法。 //请往下看关注点1 if ((mPrivateFlags &amp; PRESSED) != 0 || prepressed) &#123; // take focus if we don't have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123; focusTaken = requestFocus(); &#125; if (!mHasPerformedLongPress) &#123; // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) &#123; // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) &#123; mPerformClick = new PerformClick(); &#125; if (!post(mPerformClick)) &#123; //关注点1 //请往下看performClick()的源码分析 performClick(); &#125; &#125; &#125; if (mUnsetPressedState == null) &#123; mUnsetPressedState = new UnsetPressedState(); &#125; if (prepressed) &#123; mPrivateFlags |= PRESSED; refreshDrawableState(); postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); &#125; else if (!post(mUnsetPressedState)) &#123; // If the post failed, unpress right now mUnsetPressedState.run(); &#125; removeTapCallback(); &#125; break; case MotionEvent.ACTION_DOWN: if (mPendingCheckForTap == null) &#123; mPendingCheckForTap = new CheckForTap(); &#125; mPrivateFlags |= PREPRESSED; mHasPerformedLongPress = false; postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); break; case MotionEvent.ACTION_CANCEL: mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); removeTapCallback(); break; case MotionEvent.ACTION_MOVE: final int x = (int) event.getX(); final int y = (int) event.getY(); // Be lenient about moving outside of buttons int slop = mTouchSlop; if ((x &lt; 0 - slop) || (x &gt;= getWidth() + slop) || (y &lt; 0 - slop) || (y &gt;= getHeight() + slop)) &#123; // Outside button removeTapCallback(); if ((mPrivateFlags &amp; PRESSED) != 0) &#123; // Remove any future long press/tap checks removeLongPressCallback(); // Need to switch from pressed to not pressed mPrivateFlags &amp;= ~PRESSED; refreshDrawableState(); &#125; &#125; break; &#125; //如果该控件是可以点击的，就一定会返回true return true; &#125; //如果该控件是不可以点击的，就一定会返回false return false; &#125; 关注点1：performClick()的源码分析 12345678910public boolean performClick() &#123; sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); if (mOnClickListener != null) &#123; playSoundEffect(SoundEffectConstants.CLICK); mOnClickListener.onClick(this); return true; &#125; return false; &#125; 只要mOnClickListener不为null，就会去调用onClick方法； 那么，mOnClickListener又是在哪里赋值的呢？请继续看： 123456public void setOnClickListener(OnClickListener l) &#123; if (!isClickable()) &#123; setClickable(true); &#125; mOnClickListener = l; &#125; 当我们通过调用setOnClickListener方法来给控件注册一个点击事件时，就会给mOnClickListener赋值（不为空），即会回调onClick（）。 结论 onTouch（）的执行高于onClick（） 每当控件被点击时： 如果在回调onTouch()里返回false，就会让dispatchTouchEvent方法返回false，那么就会执行onTouchEvent()；如果回调了setOnClickListener()来给控件注册点击事件的话，最后会在performClick()方法里回调onClick()。 onTouch()返回false（该事件没被onTouch()消费掉） = 执行onTouchEvent() = 执行OnClick() 如果在回调onTouch()里返回true，就会让dispatchTouchEvent方法返回true，那么将不会执行onTouchEvent()，即onClick()也不会执行； onTouch()返回true（该事件被onTouch()消费掉） = dispatchTouchEvent()返回true（不会再继续向下传递） = 不会执行onTouchEvent() = 不会执行OnClick() 下面我将用Demo验证上述的结论 Demo论证1. Demo1：在回调onTouch()里返回true 123456789101112131415161718//设置OnTouchListener() button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return true; &#125; &#125;);//设置OnClickListener button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;); 点击Button，测试结果如下： 2. Demo2：在回调onTouch()里返回false123456789101112131415161718//设置OnTouchListener() button.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; System.out.println("执行了onTouch(), 动作是:" + event.getAction()); return false; &#125; &#125;);//设置OnClickListener button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("执行了onClick()"); &#125; &#125;); 点击Button，测试结果如下： 总结：onTouch()返回true就认为该事件被onTouch()消费掉，因而不会再继续向下传递，即不会执行OnClick()。 五、 思考点5.1 onTouch()和onTouchEvent()的区别 这两个方法都是在View的dispatchTouchEvent中调用，但onTouch优先于onTouchEvent执行。 如果在onTouch方法中返回true将事件消费掉，onTouchEvent()将不会再执行。 特别注意：请看下面代码 123456//&amp;&amp;为短路与，即如果前面条件为false，将不再往下执行//所以，onTouch能够得到执行需要两个前提条件：//1. mOnTouchListener的值不能为空//2. 当前点击的控件必须是enable的。mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; mOnTouchListener.onTouch(this, event) 因此如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。对于这一类控件，如果我们想要监听它的touch事件，就必须通过在该控件中重写onTouchEvent方法来实现。 5.2 Touch事件的后续事件（MOVE、UP）层级传递 如果给控件注册了Touch事件，每次点击都会触发一系列action事件（ACTION_DOWN，ACTION_MOVE，ACTION_UP等） 当dispatchTouchEvent在进行事件分发的时候，只有前一个事件（如ACTION_DOWN）返回true，才会收到后一个事件（ACTION_MOVE和ACTION_UP） 即如果在执行ACTION_DOWN时返回false，后面一系列的ACTION_MOVE和ACTION_UP事件都不会执行 从上面对事件分发机制分析知： dispatchTouchEvent()和 onTouchEvent()消费事件、终结事件传递（返回true） 而onInterceptTouchEvent 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的ACTION_MOVE和ACTION_UP事件接收起到非常大的作用 请记住：接收了ACTION_DOWN事件的函数不一定能收到后续事件（ACTION_MOVE、ACTION_UP） 这里给出ACTION_MOVE和ACTION_UP事件的传递结论： 如果在某个对象（Activity、ViewGroup、View）的dispatchTouchEvent()消费事件（返回true），那么收到ACTION_DOWN的函数也能收到ACTION_MOVE和ACTION_UP 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE和ACTION_UP事件传递方向 如果在某个对象（Activity、ViewGroup、View）的onTouchEvent()消费事件（返回true），那么ACTION_MOVE和ACTION_UP的事件从上往下传到这个View后就不再往下传递了，而直接传给自己的onTouchEvent()并结束本次事件传递过程。 黑线：ACTION_DOWN事件传递方向红线：ACTION_MOVE和ACTION_UP事件传递方向]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android消息机制]]></title>
    <url>%2F2018%2F06%2F07%2FAndroid%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[一、消息机制概述1.消息机制的简介在Android中使用消息机制，我们首先想到的就是Handler。没错，Handler是Android消息机制的上层接口。Handler的使用过程很简单，通过它可以轻松地将一个任务切换到Handler所在的线程中去执行。通常情况下，Handler的使用场景就是更新UI。如下就是使用消息机制的一个简单实例： 1234567891011121314151617181920212223public class Activity extends android.app.Activity &#123; private Handler mHandler = new Handler()&#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); System.out.println(msg.what); &#125; &#125;; @Override public void onCreate(Bundle savedInstanceState, PersistableBundle persistentState) &#123; super.onCreate(savedInstanceState, persistentState); setContentView(R.layout.activity_main); new Thread(new Runnable() &#123; @Override public void run() &#123; ...............耗时操作 Message message = Message.obtain(); message.what = 1; mHandler.sendMessage(message); &#125; &#125;).start(); &#125;&#125; 在子线程中，进行耗时操作，执行完操作后，发送消息，通知主线程更新UI。这便是消息机制的典型应用场景。我们通常只会接触到Handler和Message来完成消息机制，其实内部还有两大助手来共同完成消息传递。 2.消息机制的模型消息机制主要包含：MessageQueue，Handler和Looper这三大部分，以及Message，下面我们一一介绍。 Message：需要传递的消息，可以传递数据； MessageQueue：消息队列，但是它的内部实现并不是用的队列，实际上是通过一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优势。主要功能向消息池投递消息(MessageQueue.enqueueMessage)和取走消息池的消息(MessageQueue.next)； Handler：消息辅助类，主要功能向消息池发送各种消息事件(Handler.sendMessage)和处理相应消息事件(Handler.handleMessage)； Looper：不断循环执行(Looper.loop)，从MessageQueue中读取消息，按分发机制将消息分发给目标处理者。 3.消息机制的架构消息机制的运行流程：在子线程执行完耗时操作，当Handler发送消息时，将会调用MessageQueue.enqueueMessage，向消息队列中添加消息。当通过Looper.loop开启循环后，会不断地从线程池中读取消息，即调用MessageQueue.next，然后调用目标Handler（即发送该消息的Handler）的dispatchMessage方法传递消息，然后返回到Handler所在线程，目标Handler收到消息，调用handleMessage方法，接收消息，处理消息。 MessageQueue，Handler和Looper三者之间的关系：每个线程中只能存在一个Looper，Looper是保存在ThreadLocal中的。主线程（UI线程）已经创建了一个Looper，所以在主线程中不需要再创建Looper，但是在其他线程中需要创建Looper。每个线程中可以有多个Handler，即一个Looper可以处理来自多个Handler的消息。 Looper中维护一个MessageQueue，来维护消息队列，消息队列中的Message可以来自不同的Handler。 下面是消息机制的整体架构图，接下来我们将慢慢解剖整个架构。 从中我们可以看出：Looper有一个MessageQueue消息队列；MessageQueue有一组待处理的Message；Message中记录发送和处理消息的Handler；Handler中有Looper和MessageQueue。 二、消息机制的源码解析1.Looper要想使用消息机制，首先要创建一个Looper。初始化Looper无参情况下，默认调用prepare(true);表示的是这个Looper可以退出，而对于false的情况则表示当前Looper不可以退出。。 12345678910public static void prepare() &#123; prepare(true); &#125; private static void prepare(boolean quitAllowed) &#123; if (sThreadLocal.get() != null) &#123; throw new RuntimeException("Only one Looper may be created per thread"); &#125; sThreadLocal.set(new Looper(quitAllowed)); &#125; 这里看出，不能重复创建Looper，只能创建一个。创建Looper,并保存在ThreadLocal。其中ThreadLocal是线程本地存储区（Thread Local Storage，简称为TLS），每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的TLS区域。开启Looper 123456789101112131415161718192021222324252627282930313233public static void loop() &#123; final Looper me = myLooper(); //获取TLS存储的Looper对象 if (me == null) &#123; throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread."); &#125; final MessageQueue queue = me.mQueue; //获取Looper对象中的消息队列 Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) &#123; //进入loop的主循环方法 Message msg = queue.next(); //可能会阻塞,因为next()方法可能会无限循环 if (msg == null) &#123; //消息为空，则退出循环 return; &#125; Printer logging = me.mLogging; //默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能 if (logging != null) &#123; logging.println("&gt;&gt;&gt;&gt;&gt; Dispatching to " + msg.target + " " + msg.callback + ": " + msg.what); &#125; msg.target.dispatchMessage(msg); //获取msg的目标Handler，然后用于分发Message if (logging != null) &#123; logging.println("&lt;&lt;&lt;&lt;&lt; Finished to " + msg.target + " " + msg.callback); &#125; final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; &#125; msg.recycleUnchecked(); &#125;&#125; loop()进入循环模式，不断重复下面的操作，直到消息为空时退出循环:读取MessageQueue的下一条Message（关于next()，后面详细介绍）；把Message分发给相应的target。 当next()取出下一条消息时，队列中已经没有消息时，next()会无限循环，产生阻塞。等待MessageQueue中加入消息，然后重新唤醒。 主线程中不需要自己创建Looper，这是由于在程序启动的时候，系统已经帮我们自动调用了Looper.prepare()方法。查看ActivityThread中的main()方法，代码如下所示： 12345678 public static void main(String[] args) &#123;.......................... Looper.prepareMainLooper(); .......................... Looper.loop(); .......................... &#125; 其中123456789101112131415161718192021###### 2.Handler**创建Handler**```javapublic Handler() &#123; this(null, false);&#125;public Handler(Callback callback, boolean async) &#123; ................................. //必须先执行Looper.prepare()，才能获取Looper对象，否则为null. mLooper = Looper.myLooper(); //从当前线程的TLS中获取Looper对象 if (mLooper == null) &#123; throw new RuntimeException(&quot;&quot;); &#125; mQueue = mLooper.mQueue; //消息队列，来自Looper对象 mCallback = callback; //回调方法 mAsynchronous = async; //设置消息是否为异步处理方式&#125; 对于Handler的无参构造方法，默认采用当前线程TLS中的Looper对象，并且callback回调方法为null，且消息为同步处理方式。只要执行的Looper.prepare()方法，那么便可以获取有效的Looper对象。 3.发送消息发送消息有几种方式，但是归根结底都是调用了sendMessageAtTime()方法。 在子线程中通过Handler的post()方式或send()方式发送消息，最终都是调用了sendMessageAtTime()方法。 post方法 12345678910111213141516 public final boolean post(Runnable r) &#123; return sendMessageDelayed(getPostMessage(r), 0); &#125;public final boolean postAtTime(Runnable r, long uptimeMillis) &#123; return sendMessageAtTime(getPostMessage(r), uptimeMillis); &#125; public final boolean postAtTime(Runnable r, Object token, long uptimeMillis) &#123; return sendMessageAtTime(getPostMessage(r, token), uptimeMillis); &#125; public final boolean postDelayed(Runnable r, long delayMillis) &#123; return sendMessageDelayed(getPostMessage(r), delayMillis); &#125; send方法 12345678910111213141516171819202122232425public final boolean sendMessage(Message msg) &#123; return sendMessageDelayed(msg, 0); &#125; public final boolean sendEmptyMessage(int what) &#123; return sendEmptyMessageDelayed(what, 0); &#125; public final boolean sendEmptyMessageDelayed(int what, long delayMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageDelayed(msg, delayMillis); &#125; public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) &#123; Message msg = Message.obtain(); msg.what = what; return sendMessageAtTime(msg, uptimeMillis); &#125; public final boolean sendMessageDelayed(Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis); &#125; 就连子线程中调用Activity中的runOnUiThread()中更新UI，其实也是发送消息通知主线程更新UI，最终也会调用sendMessageAtTime()方法。 1234567public final void runOnUiThread(Runnable action) &#123; if (Thread.currentThread() != mUiThread) &#123; mHandler.post(action); &#125; else &#123; action.run(); &#125; &#125; 如果当前的线程不等于UI线程(主线程)，就去调用Handler的post()方法，最终会调用sendMessageAtTime()方法。否则就直接调用Runnable对象的run()方法。 下面我们就来一探究竟，到底sendMessageAtTime()方法有什么作用？sendMessageAtTime() 123456789101112public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123; //其中mQueue是消息队列，从Looper中获取的 MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + " sendMessageAtTime() called with no mQueue"); Log.w("Looper", e.getMessage(), e); return false; &#125; //调用enqueueMessage方法 return enqueueMessage(queue, msg, uptimeMillis); &#125; 12345678private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123; msg.target = this; if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; //调用MessageQueue的enqueueMessage方法 return queue.enqueueMessage(msg, uptimeMillis); &#125; 可以看到sendMessageAtTime()`方法的作用很简单，就是调用MessageQueue的enqueueMessage()方法，往消息队列中添加一个消息。下面来看enqueueMessage()方法的具体执行逻辑。enqueueMessage() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546boolean enqueueMessage(Message msg, long when) &#123; // 每一个Message必须有一个target if (msg.target == null) &#123; throw new IllegalArgumentException("Message must have a target."); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + " This message is already in use."); &#125; synchronized (this) &#123; if (mQuitting) &#123; //正在退出时，回收msg，加入到消息池 msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; //p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支 msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; //将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非 //消息队头存在barrier，并且同时Message是队列中最早的异步消息。 needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; prev.next = msg; &#125; if (needWake) &#123; nativeWake(mPtr); &#125; &#125; return true;&#125; MessageQueue是按照Message触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。 4.获取消息当发送了消息后，在MessageQueue维护了消息队列，然后在Looper中通过loop()方法，不断地获取消息。上面对loop()方法进行了介绍，其中最重要的是调用了queue.next()方法,通过该方法来提取下一条信息。下面我们来看一下next()方法的具体流程。next() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Message next() &#123; final long ptr = mPtr; if (ptr == 0) &#123; //当消息循环已经退出，则直接返回 return null; &#125; int pendingIdleHandlerCount = -1; // 循环迭代的首次为-1 int nextPollTimeoutMillis = 0; for (;;) &#123; if (nextPollTimeoutMillis != 0) &#123; Binder.flushPendingCommands(); &#125; //阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) &#123; final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null &amp;&amp; msg.target == null) &#123; //当消息Handler为空时，查询MessageQueue中的下一条异步消息msg，为空则退出循环。 do &#123; prevMsg = msg; msg = msg.next; &#125; while (msg != null &amp;&amp; !msg.isAsynchronous()); &#125; if (msg != null) &#123; if (now &lt; msg.when) &#123; //当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长 nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); &#125; else &#123; // 获取一条消息，并返回 mBlocked = false; if (prevMsg != null) &#123; prevMsg.next = msg.next; &#125; else &#123; mMessages = msg.next; &#125; msg.next = null; //设置消息的使用状态，即flags |= FLAG_IN_USE msg.markInUse(); return msg; //成功地获取MessageQueue中的下一条即将要执行的消息 &#125; &#125; else &#123; //没有消息 nextPollTimeoutMillis = -1; &#125; //消息正在退出，返回null if (mQuitting) &#123; dispose(); return null; &#125; ............................... &#125;&#125; nativePollOnce是阻塞操作，其中nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。可以看出next()方法根据消息的触发时间，获取下一条需要执行的消息,队列中消息为空时，则会进行阻塞操作。 5.分发消息在loop()方法中，获取到下一条消息后，执行msg.target.dispatchMessage(msg)，来分发消息到目标Handler对象。下面就来具体看下dispatchMessage(msg)方法的执行流程。dispatchMessage() 123456789101112131415public void dispatchMessage(Message msg) &#123; if (msg.callback != null) &#123; //当Message存在回调方法，回调msg.callback.run()方法； handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; //当Handler存在Callback成员变量时，回调方法handleMessage()； if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; //Handler自身的回调方法handleMessage() handleMessage(msg); &#125;&#125; 123private static void handleCallback(Message message) &#123; message.callback.run(); &#125; 分发消息流程：当Message的msg.callback不为空时，则回调方法msg.callback.run();当Handler的mCallback不为空时，则回调方法mCallback.handleMessage(msg)；最后调用Handler自身的回调方法handleMessage()，该方法默认为空，Handler子类通过覆写该方法来完成具体的逻辑。 消息分发的优先级：Message的回调方法：message.callback.run()，优先级最高；Handler中Callback的回调方法：Handler.mCallback.handleMessage(msg)，优先级仅次于1；Handler的默认方法：Handler.handleMessage(msg)，优先级最低。 对于很多情况下，消息分发后的处理方法是第3种情况，即Handler.handleMessage()，一般地往往通过覆写该方法从而实现自己的业务逻辑。 三、总结以上便是消息机制的原理，以及从源码角度来解析消息机制的运行过程。可以简单地用下图来理解。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>handler</tag>
        <tag>message</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fragment详解]]></title>
    <url>%2F2018%2F06%2F07%2FFragment%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、目录 什么是Fragment Fragment的生命周期 Fragment的使用方式 什么是Fragment的回退栈？【重要】 Fragment与Activity之间的通信【难点】 Fragment与Activity通信的优化【超难点】 如何处理运行时配置发生变化【以屏幕翻转为例】 二、Fragment详解1. 什么是Fragment ？你可以简单的理解为，Fragment是显示在Activity中的Activity。它可以显示在Activity中，然后它也可以显示出一些内容。因为它拥有自己的生命周期，可以接受处理用户的事件，并且你可以在一个Activity中动态的添加，替换，移除不同的Fragment，因此对于信息的展示具有很大的便利性。 2. Fragment的生命周期因为Fragment是依附于Activity存在的，因此它的生命周期收到Activity的生命周期影响 Fragment比Activity多了几个生命周期的回调方法 onAttach(Activity) 当Fragment与Activity发生关联的时候调用 onCreateView(LayoutInflater, ViewGroup, Bundle) 创建该Fragment的视图 onActivityCreated(Bundle) 当Activity的onCreated方法返回时调用 onDestroyView() 与onCreateView方法相对应，当该Fragment的视图被移除时调用 onDetach() 与onAttach方法相对应，当Fragment与Activity取消关联时调用 PS：注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现 3. Fragment的使用方式静态使用Fragment 步骤： ① 创建一个类继承Fragment，重写onCreateView方法，来确定Fragment要显示的布局 ② 在Activity中声明该类，与普通的View对象一样 代码演示 MyFragment对应的布局文件item_fragment.xml 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:background="@color/colorAccent" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:src="@mipmap/ic_launcher" /&gt;&lt;/RelativeLayout&gt; 继承Frgmanet的类MyFragment【请注意导包的时候导v4的Fragment的包】 123456789101112public class MyFragment extends Fragment &#123; public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; /* * 参数1：布局文件的id * 参数2：容器 * 参数3：是否将这个生成的View添加到这个容器中去 * 作用是将布局文件封装在一个View对象中，并填充到此Fragment中 * */ View v = inflater.inflate(R.layout.item_fragment, container, false); return v; &#125;&#125; Activity对应的布局文件 1234567891011121314151617181920&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.usher.fragment.MainActivity"&gt; &lt;TextView android:layout_width="match_parent" android:layout_height="100dp" android:gravity="center" android:text="Good Boy" /&gt; &lt;fragment android:id="@+id/myfragment" android:name="com.usher.fragment.MyFragment" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; 运行效果图 动态使用Fragment 实现点击不同的按钮，在Activity中显示不同的Fragment 代码演示 Fragment对应的布局文件item_fragment.xml 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:background="@color/colorAccent" //背景红色 android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:src="@mipmap/ic_launcher" /&gt;&lt;/RelativeLayout&gt; 继承Frgmanet的类MyFragment 123456public class MyFragment extends Fragment &#123; public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.item_fragment, container, false); return v; &#125;&#125; Fragment2对应的布局文件item_fragment2.xml 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:background="@color/colorPrimary" //背景蓝色 android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;ImageView android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_centerInParent="true" android:src="@mipmap/ic_launcher" /&gt;&lt;/RelativeLayout&gt; 继承Fragment2的类 1234567public class MyFragment extends Fragment &#123; public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View v = inflater.inflate(R.layout.item_fragment2, container, false); return v; &#125;&#125; MainActivity对应的布局文件 1234567891011121314151617181920212223242526&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" tools:context="com.usher.fragment.MainActivity"&gt; &lt;Button android:id="@+id/bt_red" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Red" /&gt; &lt;Button android:id="@+id/bt_blue" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="Blue" /&gt; &lt;FrameLayout android:id="@+id/myframelayout" android:layout_width="match_parent" android:layout_height="match_parent" /&gt;&lt;/LinearLayout&gt; MainActivity类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends AppCompatActivity &#123; private Button bt_red; private Button bt_blue; private FragmentManager manager; private MyFragment fragment1; private MyFragment2 fragment2; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); fragment1 = new MyFragment(); fragment2 = new MyFragment2(); //初始化FragmentManager对象 manager = getSupportFragmentManager(); //使用FragmentManager对象用来开启一个Fragment事务 FragmentTransaction transaction = manager.beginTransaction(); //默认显示fragment1 transaction.add(R.id.myframelayout, fragment1).commit(); //对bt_red设置监听 bt_red.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; FragmentTransaction transaction = manager.beginTransaction(); transaction.replace(R.id.myframelayout, fragment1).commit(); &#125; &#125;); //对bt_blue设置监听 bt_blue.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; FragmentTransaction transaction = manager.beginTransaction(); transaction.replace(R.id.myframelayout, fragment2).commit(); &#125; &#125;); &#125; private void initView() &#123; bt_red = (Button) findViewById(R.id.bt_red); bt_blue = (Button) findViewById(R.id.bt_blue); &#125;&#125; 显示效果 默认显示 点击BLUE按钮时 点击RED按钮时 以上代码我写的比较臃肿但是比较容易看明白： ① 在Acitivity对应的布局中写上一个FramLayout控件，此空间的作用是当作Fragment的容器，Fragment通过FrameLayout显示在Acitivity里，这两个单词容易混淆，请注意 ② 准备好你的Fragment，然后再Activity中实例化，v4包的Fragment是通过getSupportFragmentManager()方法新建Fragment管理器对象，此处不讨论app包下的Fragment ③ 然后通过Fragment管理器对象调用beginTransaction()方法，实例化FragmentTransaction对象，有人称之为事务 ④ FragmentTransaction对象【以下直接用transaction代替】，transaction的方法主要有以下几种： transaction.add() 向Activity中添加一个Fragment transaction.remove() 从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈（回退栈后面会详细说），这个Fragment实例将会被销毁 transaction.replace() 使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体 transaction.hide() 隐藏当前的Fragment，仅仅是设为不可见，并不会销毁 transaction.show() 显示之前隐藏的Fragment detach() 会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护 attach() 重建view视图，附加到UI上并显示 ransatcion.commit() 提交事务 注意：在add/replace/hide/show以后都要commit其效果才会在屏幕上显示出来 4. 什么是Fragment的回退栈？ Fragment的回退栈是用来保存每一次Fragment事务发生的变化如果你将Fragment任务添加到回退栈，当用户点击后退按钮时，将看到上一次的保存的Fragment。一旦Fragment完全从后退栈中弹出，用户再次点击后退键，则退出当前Activity 那么这句话要怎么理解？ 首先来看一下这个东西： 首先显示第一个FragmentOne页面有一个Button in FragmentOne，上面有个输入框显示的是Fragment One 然后输入change，点击Button in FragmentOne，然后显示第二个Fragment，里面有一个Button in FragmentTwo，一个输入框显示Fragment Two 输入change，点击按钮，显示第三个Fragment，上面有个Button in FragmentThree，点击按钮显示出一个Toast 【注意】点击返回键，跳转到前一个FragmentTwo，这个时候可以看到上面的输入框中显示的是Fragment Two change，也就是说保留了我们离开这个Fragment时候他所呈现的状态 【注意】再点击返回键，跳转到FragmentOne，但是这个时候我们可以看到上面的输入框中只有Fragment One，并没有change这几个字母 那么原因是什么？ 这里先要学习一个方法：FragmentTransaction.addToBackStack(String)【把当前事务的变化情况添加到回退栈】 代码如下： MainActivity的布局文件 123456789101112&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;FrameLayout android:id="@+id/id_content" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;/FrameLayout&gt; &lt;/RelativeLayout&gt; MainActivity.java文件【这里添加的是app包下的Fragment，推荐v4包下的】 123456789101112131415public class MainActivity extends Activity &#123; protected void onCreate(Bundle savedInstanceState)&#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); FragmentManager fm = getFragmentManager(); FragmentTransaction tx = fm.beginTransaction(); tx.add(R.id.id_content, new FragmentOne(),"ONE"); tx.commit(); &#125; &#125; FragmentOne.class文件 12345678910111213141516171819202122232425public class FragmentOne extends Fragment implements OnClickListener &#123; private Button mBtn; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_one, container, false); mBtn = (Button) view.findViewById(R.id.id_fragment_one_btn); mBtn.setOnClickListener(this); return view; &#125; @Override public void onClick(View v) &#123; FragmentTwo fTwo = new FragmentTwo(); FragmentManager fm = getFragmentManager(); FragmentTransaction tx = fm.beginTransaction(); tx.replace(R.id.id_content, fTwo, "TWO"); tx.addToBackStack(null); tx.commit(); &#125; &#125; Fragment的点击事件里写的是replace方法，相当于remove和add的合体，并且如果不添加事务到回退栈，前一个Fragment实例会被销毁。这里很明显，我们调用tx.addToBackStack(null)将当前的事务添加到了回退栈，所以FragmentOne实例不会被销毁，但是视图层次依然会被销毁，即会调用onDestoryView和onCreateView。所以【请注意】，当之后我们从FragmentTwo返回到前一个页面的时候，视图层仍旧是重新按照代码绘制，这里仅仅是是实例没有销毁，因此显示的页面中没有change几个字。 FragmentTwo.class文件 123456789101112131415161718192021222324252627public class FragmentTwo extends Fragment implements OnClickListener &#123; private Button mBtn ; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_two, container, false); mBtn = (Button) view.findViewById(R.id.id_fragment_two_btn); mBtn.setOnClickListener(this); return view ; &#125; @Override public void onClick(View v) &#123; FragmentThree fThree = new FragmentThree(); FragmentManager fm = getFragmentManager(); FragmentTransaction tx = fm.beginTransaction(); tx.hide(this); tx.add(R.id.id_content , fThree, "THREE"); //tx.replace(R.id.id_content, fThree, "THREE"); tx.addToBackStack(null); tx.commit(); &#125; &#125; 这里点击时，我们没有使用replace，而是先隐藏了当前的Fragment，然后添加了FragmentThree的实例，最后将事务添加到回退栈。这样做的目的是为了给大家提供一种方案：如果不希望视图重绘该怎么做，请再次仔细看效果图，我们在FragmentTwo的EditText填写的内容，用户点击返回键回来时，内容还在。 FragmentThree.class文件 123456789101112131415161718192021public class FragmentThree extends Fragment implements OnClickListener &#123; private Button mBtn; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_three, container, false); mBtn = (Button) view.findViewById(R.id.id_fragment_three_btn); mBtn.setOnClickListener(this); return view; &#125; @Override public void onClick(View v) &#123; Toast.makeText(getActivity(), " i am a btn in Fragment three", Toast.LENGTH_SHORT).show(); &#125; &#125; 如果你还是不明白请仔细将上面的代码反复敲几遍 5. Fragment与Activity之间的通信Fragment依附于Activity存在，因此与Activity之间的通信可以归纳为以下几点： [ ] 如果你Activity中包含自己管理的Fragment的引用，可以通过引用直接访问所有的Fragment的public方法 [ ] 如果Activity中未保存任何Fragment的引用，那么没关系，每个Fragment都有一个唯一的TAG或者ID,可以通过getFragmentManager.findFragmentByTag()或者findFragmentById()获得任何Fragment实例，然后进行操作 [ ] Fragment中可以通过getActivity()得到当前绑定的Activity的实例，然后进行操作。 6. Fragment与Activity通信的优化因为要考虑Fragment的重复使用，所以必须降低Fragment与Activity的耦合，而且Fragment更不应该直接操作别的Fragment，毕竟Fragment操作应该由它的管理者Activity来决定。 实现与上一个代码案例一模一样的功能与效果 FragmentOne.class文件 123456789101112131415161718192021222324252627public class FragmentOne extends Fragment implements OnClickListener &#123; private Button mBtn; //设置按钮点击的回调 public interface FOneBtnClickListener &#123; void onFOneBtnClick(); &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_one, container, false); mBtn = (Button) view.findViewById(R.id.id_fragment_one_btn); mBtn.setOnClickListener(this); return view; &#125; //交给宿主Activity处理，如果它希望处理 @Override public void onClick(View v) &#123; if (getActivity() instanceof FOneBtnClickListener) &#123; ((FOneBtnClickListener) getActivity()).onFOneBtnClick(); &#125; &#125; &#125; 可以看到，现在的FragmentOne不和任何Activity耦合，任何Activity都可以使用，并且我们声明了一个接口，来回调其点击事件，想要重写其点击事件的Activity实现此接口即可，可以看到我们在onClick中首先判断了当前绑定的Activity是否实现了该接口，如果实现了则调用。 FragmentTwo.class文件 12345678910111213141516171819202122232425262728293031public class FragmentTwo extends Fragment implements OnClickListener &#123; private Button mBtn ; private FTwoBtnClickListener fTwoBtnClickListener ; public interface FTwoBtnClickListener &#123; void onFTwoBtnClick(); &#125; //设置回调接口 public void setfTwoBtnClickListener(FTwoBtnClickListener fTwoBtnClickListener) &#123; this.fTwoBtnClickListener = fTwoBtnClickListener; &#125; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.fragment_two, container, false); mBtn = (Button) view.findViewById(R.id.id_fragment_two_btn); mBtn.setOnClickListener(this); return view ; &#125; @Override public void onClick(View v) &#123; if(fTwoBtnClickListener != null) &#123; fTwoBtnClickListener.onFTwoBtnClick(); &#125; &#125; &#125; 与FragmentOne极其类似，但是我们提供了setListener这样的方法，意味着Activity不仅需要实现该接口，还必须显示调用mFTwo.setfTwoBtnClickListener(this)。 MainActivity.class文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class MainActivity extends Activity implements FOneBtnClickListener, FTwoBtnClickListener &#123; private FragmentOne mFOne; private FragmentTwo mFTwo; private FragmentThree mFThree; //FragmentThree代码参考上一个例子中的代码 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); mFOne = new FragmentOne(); FragmentManager fm = getFragmentManager(); FragmentTransaction tx = fm.beginTransaction(); tx.add(R.id.id_content, mFOne, "ONE"); tx.commit(); &#125; //FragmentOne 按钮点击时的回调 @Override public void onFOneBtnClick() &#123; if (mFTwo == null) &#123; mFTwo = new FragmentTwo(); mFTwo.setfTwoBtnClickListener(this); &#125; FragmentManager fm = getFragmentManager(); FragmentTransaction tx = fm.beginTransaction(); tx.replace(R.id.id_content, mFTwo, "TWO"); tx.addToBackStack(null); tx.commit(); &#125; //FragmentTwo按钮点击时的回调 @Override public void onFTwoBtnClick() &#123; if (mFThree == null) &#123; mFThree = new FragmentThree(); &#125; FragmentManager fm = getFragmentManager(); FragmentTransaction tx = fm.beginTransaction(); tx.hide(mFTwo); tx.add(R.id.id_content, mFThree, "THREE"); //tx.replace(R.id.id_content, fThree, "THREE"); tx.addToBackStack(null); tx.commit(); &#125; &#125; 代码重构结束，与开始的效果一模一样。上面两种通信方式都是值得推荐的，随便选择一种自己喜欢的。这里再提一下：虽然Fragment和Activity可以通过getActivity与findFragmentByTag或者findFragmentById，进行任何操作，甚至在Fragment里面操作另外的Fragment，但是没有特殊理由是绝对不提倡的。Activity担任的是Fragment间类似总线一样的角色，应当由它决定Fragment如何操作。另外虽然Fragment不能响应Intent打开，但是Activity可以，Activity可以接收Intent，然后根据参数判断显示哪个Fragment。 7. 如何处理运行时配置发生变化 在Activity的学习中我们都知道，当屏幕旋转时，是对屏幕上的视图进行了重新绘制。因为当屏幕发生旋转，Activity发生重新启动，默认的Activity中的Fragment也会跟着Activity重新创建，用脚趾头都明白…横屏和竖屏显示的不一样肯定是进行了重新绘制视图的操作。所以，不断的旋转就不断绘制，这是一种很耗费内存资源的操作，那么如何来进行优化？ 代码分析： Fragment的class文件 12345678910111213141516171819202122232425262728293031323334public class FragmentOne extends Fragment &#123; private static final String TAG = "FragmentOne"; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; Log.e(TAG, "onCreateView"); View view = inflater.inflate(R.layout.fragment_one, container, false); return view; &#125; @Override public void onCreate(Bundle savedInstanceState) &#123; // TODO Auto-generated method stub super.onCreate(savedInstanceState); Log.e(TAG, "onCreate"); &#125; @Override public void onDestroyView() &#123; // TODO Auto-generated method stub super.onDestroyView(); Log.e(TAG, "onDestroyView"); &#125; @Override public void onDestroy() &#123; // TODO Auto-generated method stub super.onDestroy(); Log.e(TAG, "onDestroy"); &#125; &#125; 然后你多次翻转屏幕都会打印如下log 12345607-20 08:18:46.651: E/FragmentOne(1633): onCreate 07-20 08:18:46.651: E/FragmentOne(1633): onCreate 07-20 08:18:46.651: E/FragmentOne(1633): onCreate 07-20 08:18:46.681: E/FragmentOne(1633): onCreateView 07-20 08:18:46.831: E/FragmentOne(1633): onCreateView 07-20 08:18:46.891: E/FragmentOne(1633): onCreateView 因为当屏幕发生旋转，Activity发生重新启动，默认的Activity中的Fragment也会跟着Activity重新创建；这样造成当旋转的时候，本身存在的Fragment会重新启动，然后当执行Activity的onCreate时，又会再次实例化一个新的Fragment，这就是出现的原因。 那么如何解决呢： 通过检查onCreate的参数Bundle savedInstanceState就可以判断，当前是否发生Activity的重新创建 默认的savedInstanceState会存储一些数据，包括Fragment的实例 所以，我们简单改一下代码，判断只有在savedInstanceState==null时，才进行创建Fragment实例 MainActivity.class文件 1234567891011121314151617181920212223public class MainActivity extends Activity &#123; private static final String TAG = "FragmentOne"; private FragmentOne mFOne; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); requestWindowFeature(Window.FEATURE_NO_TITLE); setContentView(R.layout.activity_main); Log.e(TAG, savedInstanceState+""); if(savedInstanceState == null) &#123; mFOne = new FragmentOne(); FragmentManager fm = getFragmentManager(); FragmentTransaction tx = fm.beginTransaction(); tx.add(R.id.id_content, mFOne, "ONE"); tx.commit(); &#125; &#125; &#125; 现在无论进行多次旋转都只会有一个Fragment实例在Activity中，现在还存在一个问题，就是重新绘制时，Fragment发生重建，原本的数据如何保持？和Activity类似，Fragment也有onSaveInstanceState的方法，在此方法中进行保存数据，然后在onCreate或者onCreateView或者onActivityCreated进行恢复都可以。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ContentProvider的使用与了解]]></title>
    <url>%2F2018%2F06%2F07%2FContentProvider%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、定义ContentProvider，即内容提供者属于Android的四大组件之一。 二、 作用进程间 进行数据交互 &amp; 共享，即跨进程通信 三、 原理ContentProvider的底层是采用 Android中的Binder机制 四、具体使用关于ContentProvider的使用主要介绍以下内容： 4.1 统一资源标识符（URI） 定义：Uniform Resource Identifier，即统一资源标识符 作用：唯一标识 ContentProvider &amp; 其中的数据 外界进程通过 URI 找到对应的ContentProvider &amp; 其中的数据，再进行数据操作 具体使用 URI分为 系统预置 &amp; 自定义，分别对应系统内置的数据（如通讯录、日程表等等）和自定义数据库 关于 系统预置URI 此处不作过多讲解，需要的同学可自行查看 此处主要讲解 自定义URI 123456789101112// 设置URIUri uri = Uri.parse("content://com.carson.provider/User/1") // 上述URI指向的资源是：名为 `com.carson.provider`的`ContentProvider` 中表名 为`User` 中的 `id`为1的数据// 特别注意：URI模式存在匹配通配符* &amp; ＃// *：匹配任意长度的任何有效字符的字符串// 以下的URI 表示 匹配provider的任何内容content://com.example.app.provider/* // ＃：匹配任意长度的数字字符的字符串// 以下的URI 表示 匹配provider中的table表的所有行content://com.example.app.provider/table/# 4.2 MIME数据类型 解释：MIME：全称Multipurpose Internet Mail Extensions，多功能Internet 邮件扩充服务。它是一种多用途网际邮件扩充协议，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。MIME类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型，当该扩展名文件被访问的时候，浏览器会自动使用指定应用程序来打开。多用于指定一些客户端自定义的文件名，以及一些媒体文件打开方式。 作用：指定某个扩展名的文件用某种应用程序来打开如指定.html文件采用text应用程序打开、指定.pdf文件采用flash应用程序打开 具体使用： 4.2.1 ContentProvider根据 URI 返回MIME类型 1ContentProvider.geType(uri) ； 4.2.2 MIME类型组成每种MIME类型 由2部分组成 = 类型 + 子类型 MIME类型是 一个 包含2部分的字符串 123456text / html// 类型 = text、子类型 = htmltext/csstext/xmlapplication/pdf 4.2.3 MIME类型形式MIME类型有2种形式： 123456789// 形式1：单条记录 vnd.android.cursor.item/自定义// 形式2：多条记录（集合）vnd.android.cursor.dir/自定义 // 注： // 1. vnd：表示父类型和子类型具有非标准的、特定的形式。 // 2. 父类型已固定好（即不能更改），只能区别是单条还是多条记录 // 3. 子类型可自定义 实例说明1234567891011121314151617&lt;-- 单条记录 --&gt; // 单个记录的MIME类型 vnd.android.cursor.item/vnd.yourcompanyname.contenttype // 若一个Uri如下 content://com.example.transportationprovider/trains/122 // 则ContentProvider会通过ContentProvider.geType(url)返回以下MIME类型 vnd.android.cursor.item/vnd.example.rail&lt;-- 多条记录 --&gt; // 多个记录的MIME类型 vnd.android.cursor.dir/vnd.yourcompanyname.contenttype // 若一个Uri如下 content://com.example.transportationprovider/trains // 则ContentProvider会通过ContentProvider.geType(url)返回以下MIME类型 vnd.android.cursor.dir/vnd.example.rail 4.3 ContentProvider类4.3.1 组织数据方式 ContentProvider主要以表格的形式组织数据 同时也支持文件数据，只是表格形式用得比较多 每个表格中包含多张表，每张表包含行 &amp; 列，分别对应记录 &amp; 字段 同数据库 4.3.2 主要方法 进程间共享数据的本质是：添加、删除、获取 &amp; 修改（更新）数据 所以ContentProvider的核心方法也主要是上述4个作用 1234567891011121314151617181920212223242526&lt;-- 4个核心方法 --&gt; public Uri insert(Uri uri, ContentValues values) // 外部进程向 ContentProvider 中添加数据 public int delete(Uri uri, String selection, String[] selectionArgs) // 外部进程 删除 ContentProvider 中的数据 public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) // 外部进程更新 ContentProvider 中的数据 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) // 外部应用 获取 ContentProvider 中的数据// 注： // 1. 上述4个方法由外部进程回调，并运行在ContentProvider进程的Binder线程池中（不是主线程） // 2. 存在多线程并发访问，需要实现线程同步 // a. 若ContentProvider的数据存储方式是使用SQLite &amp; 一个，则不需要，因为SQLite内部实现好了线程同步，若是多个SQLite则需要，因为SQL对象之间无法进行线程同步 // b. 若ContentProvider的数据存储方式是内存，则需要自己实现线程同步&lt;-- 2个其他方法 --&gt;public boolean onCreate() // ContentProvider创建后 或 打开系统后其它进程第一次访问该ContentProvider时 由系统进行调用// 注：运行在ContentProvider进程的主线程，故不能做耗时操作public String getType(Uri uri)// 得到数据类型，即返回当前 Url 所代表数据的MIME类型 Android为常见的数据（如通讯录、日程表等）提供了内置了默认的ContentProvider 但也可根据需求自定义ContentProvider，但上述6个方法必须重写 本文主要讲解自定义ContentProvider ContentProvider类并不会直接与外部进程交互，而是通过ContentResolver 类 4.4 ContentResolver类4.41 作用 统一管理不同 ContentProvider间的操作 通过 URI 即可操作 不同的ContentProvider 中的数据 外部进程通过 ContentResolver类 从而与ContentProvider类进行交互 4.2 为什么要使用通过ContentResolver类从而与ContentProvider类进行交互，而不直接访问ContentProvider类？ 一般来说，一款应用要使用多个ContentProvider，若需要了解每个ContentProvider的不同实现从而再完成数据交互，操作成本高 &amp; 难度大 所以再ContentProvider类上加多了一个 ContentResolver类对所有的ContentProvider进行统一管理。 4.3 具体使用 ContentResolver 类提供了与ContentProvider类相同名字 &amp; 作用的4个方法 1234567891011// 外部进程向 ContentProvider 中添加数据public Uri insert(Uri uri, ContentValues values) // 外部进程 删除 ContentProvider 中的数据public int delete(Uri uri, String selection, String[] selectionArgs)// 外部进程更新 ContentProvider 中的数据public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) // 外部应用 获取 ContentProvider 中的数据public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) 实例说明 12345678910// 使用ContentResolver前，需要先获取ContentResolver// 可通过在所有继承Context的类中 通过调用getContentResolver()来获得ContentResolverContentResolver resolver = getContentResolver(); // 设置ContentProvider的URIUri uri = Uri.parse("content://cn.scu.myprovider/user"); // 根据URI 操作 ContentProvider中的数据// 此处是获取ContentProvider中 user表的所有记录 Cursor cursor = resolver.query(uri, null, null, null, "userid desc"); Android 提供了3个用于辅助ContentProvide的工具类： ContentUris UriMatcher ContentObserver 4.5 ContentUris类 作用：操作 URI 具体使用核心方法有两个：withAppendedId（） &amp;parseId（） 123456789// withAppendedId（）作用：向URI追加一个idUri uri = Uri.parse("content://cn.scu.myprovider/user") Uri resultUri = ContentUris.withAppendedId(uri, 7); // 最终生成后的Uri为：content://cn.scu.myprovider/user/7// parseId（）作用：从URL中获取IDUri uri = Uri.parse("content://cn.scu.myprovider/user/7") long personid = ContentUris.parseId(uri); //获取的结果为:7 4.6 UriMatcher类 作用 在ContentProvider 中注册URI 根据 URI 匹配 ContentProvider 中对应的数据表 具体使用 123456789101112131415161718192021222324252627282930// 步骤1：初始化UriMatcher对象UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH);//常量UriMatcher.NO_MATCH = 不匹配任何路径的返回码// 即初始化时不匹配任何东西// 步骤2：在ContentProvider 中注册URI（addURI（））int URI_CODE_a = 1；int URI_CODE_b = 2；matcher.addURI("cn.scu.myprovider", "user1", URI_CODE_a);matcher.addURI("cn.scu.myprovider", "user2", URI_CODE_b);// 若URI资源路径 = content://cn.scu.myprovider/user1 ，则返回注册码URI_CODE_a// 若URI资源路径 = content://cn.scu.myprovider/user2 ，则返回注册码URI_CODE_b// 步骤3：根据URI 匹配 URI_CODE，从而匹配ContentProvider中相应的资源（match（））@Overridepublic String getType (Uri uri)&#123; Uri uri = Uri.parse(" content://cn.scu.myprovider/user1"); switch (matcher.match(uri)) &#123; // 根据URI匹配的返回码是URI_CODE_a // 即matcher.match(uri) == URI_CODE_a case URI_CODE_a: return tableNameUser1; // 如果根据URI匹配的返回码是URI_CODE_a，则返回ContentProvider中的名为tableNameUser1的表 case URI_CODE_b: return tableNameUser2; // 如果根据URI匹配的返回码是URI_CODE_b，则返回ContentProvider中的名为tableNameUser2的表 &#125;&#125; 4.7 ContentObserver类 定义：内容观察者 作用：观察 Uri引起ContentProvider 中的数据变化 &amp; 通知外界（即访问该数据访问者） 当ContentProvider 中的数据发生变化（增、删 &amp; 改）时，就会触发该 ContentObserver类 具体使用 12345678910111213141516// 步骤1：注册内容观察者ContentObservergetContentResolver().registerContentObserver（uri）；// 通过ContentResolver类进行注册，并指定需要观察的URI// 步骤2：当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者）public class UserContentProvider extends ContentProvider &#123; public Uri insert(Uri uri, ContentValues values) &#123; db.insert("user", "userid", values); getContext().getContentResolver().notifyChange(uri, null); // 通知访问者 &#125;&#125;// 步骤3：解除观察者getContentResolver().unregisterContentObserver（uri）；// 同样需要通过ContentResolver类进行解除 至此，关于ContentProvider的使用已经讲解完毕 五、 实例说明 由于ContentProvider不仅常用于进程间通信，同时也适用于进程内通信 所以本实例会采用ContentProvider讲解： 进程内通信 进程间通信 实例说明：采用的数据源是Android中的SQLite数据库 5.1 进程内通信 步骤说明： 创建数据库类 自定义 ContentProvider 类 注册 创建的 ContentProvider类 进程内访问 ContentProvider的数据 具体使用 步骤1：创建数据库类DBHelper.java 1234567891011121314151617181920212223242526272829public class DBHelper extends SQLiteOpenHelper &#123; // 数据库名 private static final String DATABASE_NAME = "finch.db"; // 表名 public static final String USER_TABLE_NAME = "user"; public static final String JOB_TABLE_NAME = "job"; private static final int DATABASE_VERSION = 1; //数据库版本号 public DBHelper(Context context) &#123; super(context, DATABASE_NAME, null, DATABASE_VERSION); &#125; @Override public void onCreate(SQLiteDatabase db) &#123; // 创建两个表格:用户表 和职业表 db.execSQL("CREATE TABLE IF NOT EXISTS " + USER_TABLE_NAME + "(_id INTEGER PRIMARY KEY AUTOINCREMENT," + " name TEXT)"); db.execSQL("CREATE TABLE IF NOT EXISTS " + JOB_TABLE_NAME + "(_id INTEGER PRIMARY KEY AUTOINCREMENT," + " job TEXT)"); &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125;&#125; 步骤2：自定义 ContentProvider 类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133public class MyProvider extends ContentProvider &#123; private Context mContext; DBHelper mDbHelper = null; SQLiteDatabase db = null; public static final String AUTOHORITY = "cn.scu.myprovider"; // 设置ContentProvider的唯一标识 public static final int User_Code = 1; public static final int Job_Code = 2; // UriMatcher类使用:在ContentProvider 中注册URI private static final UriMatcher mMatcher; static &#123; mMatcher = new UriMatcher(UriMatcher.NO_MATCH); // 初始化 mMatcher.addURI(AUTOHORITY, "user", User_Code); mMatcher.addURI(AUTOHORITY, "job", Job_Code); // 若URI资源路径 = content://cn.scu.myprovider/user ，则返回注册码User_Code // 若URI资源路径 = content://cn.scu.myprovider/job ，则返回注册码Job_Code &#125; // 以下是ContentProvider的6个方法 /** * 初始化ContentProvider */ @Override public boolean onCreate() &#123; mContext = getContext(); // 在ContentProvider创建时对数据库进行初始化 // 运行在主线程，故不能做耗时操作,此处仅作展示 mDbHelper = new DBHelper(getContext()); db = mDbHelper.getWritableDatabase(); // 初始化两个表的数据(先清空两个表,再各加入一个记录) db.execSQL("delete from user"); db.execSQL("insert into user values(1,'Carson');"); db.execSQL("insert into user values(2,'Kobe');"); db.execSQL("delete from job"); db.execSQL("insert into job values(1,'Android');"); db.execSQL("insert into job values(2,'iOS');"); return true; &#125; /** * 添加数据 */ @Override public Uri insert(Uri uri, ContentValues values) &#123; // 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名 // 该方法在最下面 String table = getTableName(uri); // 向该表添加数据 db.insert(table, null, values); // 当该URI的ContentProvider数据发生变化时，通知外界（即访问该ContentProvider数据的访问者） mContext.getContentResolver().notifyChange(uri, null);// // 通过ContentUris类从URL中获取ID// long personid = ContentUris.parseId(uri);// System.out.println(personid); return uri; &#125; /** * 查询数据 */ @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; // 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名 // 该方法在最下面 String table = getTableName(uri);// // 通过ContentUris类从URL中获取ID// long personid = ContentUris.parseId(uri);// System.out.println(personid); // 查询数据 return db.query(table, projection, selection, selectionArgs, null, null, sortOrder, null); &#125; /** * 更新数据 */ @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) &#123; // 由于不展示,此处不作展开 return 0; &#125; /** * 删除数据 */ @Override public int delete(Uri uri, String selection, String[] selectionArgs) &#123; // 由于不展示,此处不作展开 return 0; &#125; @Override public String getType(Uri uri) &#123; // 由于不展示,此处不作展开 return null; &#125; /** * 根据URI匹配 URI_CODE，从而匹配ContentProvider中相应的表名 */ private String getTableName(Uri uri) &#123; String tableName = null; switch (mMatcher.match(uri)) &#123; case User_Code: tableName = DBHelper.USER_TABLE_NAME; break; case Job_Code: tableName = DBHelper.JOB_TABLE_NAME; break; &#125; return tableName; &#125;&#125; 步骤3：注册 创建的 ContentProvider类AndroidManifest.xml 12&lt;provider android:name="MyProvider" android:authorities="cn.scu.myprovider"/&gt; 步骤4：进程内访问 ContentProvider中的数据 MainActivity.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 对user表进行操作 */ // 设置URI Uri uri_user = Uri.parse("content://cn.scu.myprovider/user"); // 插入表中数据 ContentValues values = new ContentValues(); values.put("_id", 3); values.put("name", "Iverson"); // 获取ContentResolver ContentResolver resolver = getContentResolver(); // 通过ContentResolver 根据URI 向ContentProvider中插入数据 resolver.insert(uri_user,values); // 通过ContentResolver 向ContentProvider中查询数据 Cursor cursor = resolver.query(uri_user, new String[]&#123;"_id","name"&#125;, null, null, null); while (cursor.moveToNext())&#123; System.out.println("query book:" + cursor.getInt(0) +" "+ cursor.getString(1)); // 将表中数据全部输出 &#125; cursor.close(); // 关闭游标 /** * 对job表进行操作 */ // 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源 Uri uri_job = Uri.parse("content://cn.scu.myprovider/job"); // 插入表中数据 ContentValues values2 = new ContentValues(); values2.put("_id", 3); values2.put("job", "NBA Player"); // 获取ContentResolver ContentResolver resolver2 = getContentResolver(); // 通过ContentResolver 根据URI 向ContentProvider中插入数据 resolver2.insert(uri_job,values2); // 通过ContentResolver 向ContentProvider中查询数据 Cursor cursor2 = resolver2.query(uri_job, new String[]&#123;"_id","job"&#125;, null, null, null); while (cursor2.moveToNext())&#123; System.out.println("query job:" + cursor2.getInt(0) +" "+ cursor2.getString(1)); // 将表中数据全部输出 &#125; cursor2.close(); // 关闭游标&#125;&#125; 结果 5.2 进程间进行数据共享 实例说明：本文需要创建2个进程，即创建两个工程，作用如下 进程1使用步骤如下： 创建数据库类 自定义 ContentProvider 类 注册 创建的 ContentProvider 类 前2个步骤同上例相同，此处不作过多描述，此处主要讲解步骤3. 步骤3：注册 创建的 ContentProvider类AndroidManifest.xml 12345678910111213141516171819202122&lt;provider android:name="MyProvider" android:authorities="scut.carson_ho.myprovider" // 声明外界进程可访问该Provider的权限（读 &amp; 写） android:permission="scut.carson_ho.PROVIDER" // 权限可细分为读 &amp; 写的权限 // 外界需要声明同样的读 &amp; 写的权限才可进行相应操作，否则会报错 // android:readPermisson = "scut.carson_ho.Read" // android:writePermisson = "scut.carson_ho.Write" // 设置此provider是否可以被其他进程使用 android:exported="true" /&gt;// 声明本应用 可允许通信的权限 &lt;permission android:name="scut.carson_ho.Read" android:protectionLevel="normal"/&gt; // 细分读 &amp; 写权限如下，但本Demo直接采用全权限 // &lt;permission android:name="scut.carson_ho.Write" android:protectionLevel="normal"/&gt; // &lt;permission android:name="scut.carson_ho.PROVIDER" android:protectionLevel="normal"/&gt; 至此，进程1创建完毕，即创建ContentProvider &amp; 数据 准备好了。 进程2步骤1：声明可访问的权限 AndroidManifest.xml 12345678 // 声明本应用可允许通信的权限（全权限） &lt;uses-permission android:name="scut.carson_ho.PROVIDER"/&gt; // 细分读 &amp; 写权限如下，但本Demo直接采用全权限 // &lt;uses-permission android:name="scut.carson_ho.Read"/&gt; // &lt;uses-permission android:name="scut.carson_ho.Write"/&gt;// 注：声明的权限必须与进程1中设置的权限对应 步骤2：访问 ContentProvider的类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); /** * 对user表进行操作 */ // 设置URI Uri uri_user = Uri.parse("content://scut.carson_ho.myprovider/user"); // 插入表中数据 ContentValues values = new ContentValues(); values.put("_id", 4); values.put("name", "Jordan"); // 获取ContentResolver ContentResolver resolver = getContentResolver(); // 通过ContentResolver 根据URI 向ContentProvider中插入数据 resolver.insert(uri_user,values); // 通过ContentResolver 向ContentProvider中查询数据 Cursor cursor = resolver.query(uri_user, new String[]&#123;"_id","name"&#125;, null, null, null); while (cursor.moveToNext())&#123; System.out.println("query book:" + cursor.getInt(0) +" "+ cursor.getString(1)); // 将表中数据全部输出 &#125; cursor.close(); // 关闭游标 /** * 对job表进行操作 */ // 和上述类似,只是URI需要更改,从而匹配不同的URI CODE,从而找到不同的数据资源 Uri uri_job = Uri.parse("content://scut.carson_ho.myprovider/job"); // 插入表中数据 ContentValues values2 = new ContentValues(); values2.put("_id", 4); values2.put("job", "NBA Player"); // 获取ContentResolver ContentResolver resolver2 = getContentResolver(); // 通过ContentResolver 根据URI 向ContentProvider中插入数据 resolver2.insert(uri_job,values2); // 通过ContentResolver 向ContentProvider中查询数据 Cursor cursor2 = resolver2.query(uri_job, new String[]&#123;"_id","job"&#125;, null, null, null); while (cursor2.moveToNext())&#123; System.out.println("query job:" + cursor2.getInt(0) +" "+ cursor2.getString(1)); // 将表中数据全部输出 &#125; cursor2.close(); // 关闭游标 &#125;&#125; 结果展示在进程展示时，需要先运行准备数据的进程1，再运行需要访问数据的进程2 运行准备数据的进程1在进程1中，我们准备好了一系列数据 运行需要访问数据的进程2在进程2中，我们先向ContentProvider中插入数据，再查询数据 六、优点6.1 安全ContentProvider为应用间的数据交互提供了一个安全的环境：允许把自己的应用数据根据需求开放给 其他应用 进行 增、删、改、查，而不用担心因为直接开放数据库权限而带来的安全问题 6.2 访问简单 &amp; 高效对比于其他对外共享数据的方式，数据访问方式会因数据存储的方式而不同： 采用 文件方式 对外共享数据，需要进行文件操作读写数据； 采用 Sharedpreferences 共享数据，需要使用sharedpreferences API读写数据 这使得访问数据变得复杂 &amp; 难度大。 而采用ContentProvider方式，其解耦了底层数据的存储方式，使得无论底层数据存储采用何种方式，外界对数据的访问方式都是统一的，这使得访问简单 &amp; 高效 如一开始数据存储方式 采用 SQLite 数据库，后来把数据库换成 MongoDB，也不会对上层数据ContentProvider使用代码产生影响 七、 总结 我用一张图总结本文内容]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ContentProvider</tag>
        <tag>MVVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BroadcastReceiver的使用与了解]]></title>
    <url>%2F2018%2F06%2F07%2FBroadcastReceiver%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、 定义 BroadcastReceiver（广播接收器），属于Android四大组件之一 在Android开发中，BroadcastReceiver的应用场景非常多广播，是一个全局的监听器，属于Android四大组件之一 Android 广播分为两个角色：广播发送者、广播接收者 二、 作用 用于监听 / 接收 应用发出的广播消息，并做出响应 应用场景a. 不同组件之间通信（包括应用内 / 不同应用之间） b. 与 Android 系统在特定情况下的通信 如当电话呼入时、网络可用时 c. 多线程通信 三、实现原理 Android中的广播使用了设计模式中的观察者模式：基于消息的发布/订阅事件模型。 因此，Android将广播的发送者 和 接收者 解耦，使得系统方便集成，更易扩展 模型中有3个角色： 消息订阅者（广播接收者） 消息发布者（广播发布者） 消息中心（AMS，即Activity Manager Service） 原理描述： 广播接收者 通过 Binder机制在 AMS 注册 广播发送者 通过 Binder 机制向 AMS 发送广播 AMS 根据 广播发送者 要求，在已注册列表中，寻找合适的广播接收者 寻找依据：IntentFilter / Permission AMS将广播发送到合适的广播接收者相应的消息循环队列中； 广播接收者通过 消息循环 拿到此广播，并回调 onReceive() 特别注意：广播发送者 和 广播接收者的执行 是 异步的，发出去的广播不会关心有无接收者接收，也不确定接收者到底是何时才能接收到； 四、具体使用具体使用流程如下： 接下来我将一步步介绍如何使用 即上图中的 开发者手动完成部分 4.1 自定义广播接收者BroadcastReceiver 继承自BroadcastReceivre基类 必须复写抽象方法onReceive()方法 广播接收器接收到相应广播后，会自动回调onReceive()方法 一般情况下，onReceive方法会涉及与其他组件之间的交互，如发送Notification、启动service等 默认情况下，广播接收器运行在UI线程，因此，onReceive方法不能执行耗时操作，否则将导致ANR。 代码范例mBroadcastReceiver.java 12345678public class mBroadcastReceiver extends BroadcastReceiver &#123; //接收到广播后自动调用该方法 @Override public void onReceive(Context context, Intent intent) &#123; //写入接收广播后的操作 &#125;&#125; 4.2 广播接收器注册注册的方式分为两种：静态注册、动态注册 4.2.1 静态注册 在AndroidManifest.xml里通过 标签声明 属性说明： 12345678910111213141516171819202122&lt;receiver android:enabled=["true" | "false"] //此broadcastReceiver能否接收其他App的发出的广播 //默认值是由receiver中有无intent-filter决定的：如果有intent-filter，默认值为true，否则为false android:exported=["true" | "false"] android:icon="drawable resource" android:label="string resource" //继承BroadcastReceiver子类的类名 android:name=".mBroadcastReceiver" //具有相应权限的广播发送者发送的广播才能被此BroadcastReceiver所接收； android:permission="string" //BroadcastReceiver运行所处的进程 //默认为app的进程，可以指定独立的进程 //注：Android四大基本组件都可以通过此属性指定自己的独立进程 android:process="string" &gt; //用于指定此广播接收器将接收的广播类型 //本示例中给出的是用于接收网络状态改变时发出的广播 &lt;intent-filter&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 注册示例 12345678&lt;receiver //此广播接收者类是mBroadcastReceiver android:name=".mBroadcastReceiver" &gt; //用于接收网络状态改变时发出的广播 &lt;intent-filter&gt; &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 当此App首次启动时，系统会自动实例化mBroadcastReceiver类，并注册到系统中。 4.2.2 动态注册在代码中通过调用Context的registerReceiver（）方法进行动态注册BroadcastReceiver，具体代码如下： 1234567891011121314151617181920212223242526@Overrideprotected void onResume() &#123; super.onResume(); //实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver mBroadcastReceiver = new mBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); //设置接收广播的类型 intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE); //调用Context的registerReceiver（）方法进行动态注册 registerReceiver(mBroadcastReceiver, intentFilter);&#125;//注册广播后，要在相应位置记得销毁广播//即在onPause() 中unregisterReceiver(mBroadcastReceiver)//当此Activity实例化时，会动态将MyBroadcastReceiver注册到系统中//当此Activity销毁时，动态注册的MyBroadcastReceiver将不再接收到相应的广播。@Overrideprotected void onPause() &#123; super.onPause(); //销毁在onResume()方法中的广播 unregisterReceiver(mBroadcastReceiver);&#125; 特别注意 动态广播最好在Activity的onResume()注册、onPause()注销。 原因： 对于动态广播，有注册就必然得有注销，否则会导致内存泄露 重复注册、重复注销也不允许 4.2.3 两种注册方式的区别 4.3 广播发送者向AMS发送广播4.3.1 广播的发送 广播是用”意图（Intent）“标识 定义广播的本质：定义广播所具备的“意图（Intent）” 广播发送：广播发送者将此广播的”意图“通过sendBroadcast()方法发送出去 4.3.2 广播的类型广播的类型主要分为5类： 普通广播（Normal Broadcast） 系统广播（System Broadcast） 有序广播（Ordered Broadcast） 粘性广播（Sticky Broadcast） App应用内广播（Local Broadcast） 具体说明如下： ①. 普通广播（Normal Broadcast） 即开发者自身定义intent的广播（最常用）。发送广播使用如下： 12345Intent intent = new Intent();//对应BroadcastReceiver中intentFilter的actionintent.setAction(BROADCAST_ACTION);//发送广播sendBroadcast(intent); 若被注册了的广播接收者中注册时intentFilter的action与上述匹配，则会接收此广播（即进行回调onReceive()）。如下mBroadcastReceiver则会接收上述广播 12345678&lt;receiver //此广播接收者类是mBroadcastReceiver android:name=".mBroadcastReceiver" &gt; //用于接收网络状态改变时发出的广播 &lt;intent-filter&gt; &lt;action android:name="BROADCAST_ACTION" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 若发送广播有相应权限，那么广播接收者也需要相应权限 ②. 系统广播（System Broadcast） Android中内置了多个系统广播：只要涉及到手机的基本操作（如开机、网络状态变化、拍照等等），都会发出相应的广播 每个广播都有特定的Intent - Filter（包括具体的action），Android系统广播action如下： 系统操作 action 监听网络变化 android.net.conn.CONNECTIVITY_CHANGE 关闭或打开飞行模式 Intent.ACTION_AIRPLANE_MODE_CHANGED 充电时或电量发生变化 Intent.ACTION_BATTERY_CHANGED 电池电量低 Intent.ACTION_BATTERY_LOW 电池电量充足（即从电量低变化到饱满时会发出广播 Intent.ACTION_BATTERY_OKAY 系统启动完成后(仅广播一次) Intent.ACTION_BOOT_COMPLETED 按下照相时的拍照按键(硬件按键)时 Intent.ACTION_CAMERA_BUTTON 屏幕锁屏 Intent.ACTION_CLOSE_SYSTEM_DIALOGS 设备当前设置被改变时(界面语言、设备方向等) Intent.ACTION_CONFIGURATION_CHANGED 插入耳机时 Intent.ACTION_HEADSET_PLUG 未正确移除SD卡但已取出来时(正确移除方法:设置–SD卡和设备内存–卸载SD卡) Intent.ACTION_MEDIA_BAD_REMOVAL 插入外部储存装置（如SD卡） Intent.ACTION_MEDIA_CHECKING 成功安装APK Intent.ACTION_PACKAGE_ADDED 成功删除APK Intent.ACTION_PACKAGE_REMOVED 重启设备 Intent.ACTION_REBOOT 屏幕被关闭 Intent.ACTION_SCREEN_OFF 屏幕被打开 Intent.ACTION_SCREEN_ON 关闭系统时 Intent.ACTION_SHUTDOWN 重启设备 Intent.ACTION_REBOOT 注：当使用系统广播时，只需要在注册广播接收者时定义相关的action即可，并不需要手动发送广播，当系统有相关操作时会自动进行系统广播 ③. 有序广播（Ordered Broadcast） 定义发送出去的广播被广播接收者按照先后顺序接收 有序是针对广播接收者而言的 广播接受者接收广播的顺序规则（同时面向静态和动态注册的广播接受者） 按照Priority属性值从大-小排序； Priority属性相同者，动态注册的广播优先； 特点 接收广播按顺序接收 先接收的广播接收者可以对广播进行截断，即后接收的广播接收者不再接收到此广播； 先接收的广播接收者可以对广播进行修改，那么后接收的广播接收者将接收到被修改后的广播 具体使用有序广播的使用过程与普通广播非常类似，差异仅在于广播的发送方式： 1sendOrderedBroadcast(intent); ④. App应用内广播（Local Broadcast） 背景Android中的广播可以跨App直接通信（exported对于有intent-filter情况下默认值为true） 冲突可能出现的问题： 其他App针对性发出与当前App intent-filter相匹配的广播，由此导致当前App不断接收广播并处理； 其他App注册与当前App一致的intent-filter用于接收广播，获取广播具体信息；即会出现安全性 &amp; 效率性的问题。 解决方案使用App应用内广播（Local Broadcast） App应用内广播可理解为一种局部广播，广播的发送者和接收者都同属于一个App。 相比于全局广播（普通广播），App应用内广播优势体现在：安全性高 &amp; 效率高 具体使用1 - 将全局广播设置成局部广播 注册广播时将exported属性设置为false，使得非本App内部发出的此广播不被接收； 在广播发送和接收时，增设相应权限permission，用于权限验证； 发送广播时指定该广播接收器所在的包名，此广播将只会发送到此包中的App内与之相匹配的有效广播接收器中。 通过 intent.setPackage(packageName) 指定报名 具体使用2 - 使用封装好的LocalBroadcastManager类使用方式上与全局广播几乎相同，只是注册/取消注册广播接收器和发送广播时将参数的context变成了LocalBroadcastManager的单一实例 注：对于LocalBroadcastManager方式发送的应用内广播，只能通过LocalBroadcastManager动态注册，不能静态注册 123456789101112131415161718192021//注册应用内广播接收器//步骤1：实例化BroadcastReceiver子类 &amp; IntentFilter mBroadcastReceiver mBroadcastReceiver = new mBroadcastReceiver(); IntentFilter intentFilter = new IntentFilter(); //步骤2：实例化LocalBroadcastManager的实例localBroadcastManager = LocalBroadcastManager.getInstance(this);//步骤3：设置接收广播的类型 intentFilter.addAction(android.net.conn.CONNECTIVITY_CHANGE);//步骤4：调用LocalBroadcastManager单一实例的registerReceiver（）方法进行动态注册 localBroadcastManager.registerReceiver(mBroadcastReceiver, intentFilter);//取消注册应用内广播接收器localBroadcastManager.unregisterReceiver(mBroadcastReceiver);//发送应用内广播Intent intent = new Intent();intent.setAction(BROADCAST_ACTION);localBroadcastManager.sendBroadcast(intent); ⑤. 粘性广播（Sticky Broadcast） 由于在Android5.0 &amp; API 21中已经失效，所以不建议使用，在这里也不作过多的总结。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>BroadcastReceiver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service的使用与了解]]></title>
    <url>%2F2018%2F06%2F07%2FService%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、Service简介Service是Android程序中四大基础组件之一，它和Activity一样都是Context的子类，只不过它没有UI界面，是在后台运行的组件。 Service是Android中实现程序后台运行的解决方案，它非常适用于去执行那些不需要和用户交互而且还要求长期运行的任务。Service默认并不会运行在子线程中，它也不运行在一个独立的进程中，它同样执行在UI线程中，因此，不要在Service中执行耗时的操作，除非你在Service中创建了子线程来完成耗时操作。 二、Service种类按运行地点分类： 按运行类型分类： 按使用方式分类： 三、Service生命周期 OnCreate()系统在service第一次创建时执行此方法，来执行只运行一次的初始化工作。如果service已经运行，这个方法不会被调用。 onStartCommand()每次客户端调用startService()方法启动该Service都会回调该方法（多次调用）。一旦这个方法执行，service就启动并且在后台长期运行。通过调用stopSelf()或stopService()来停止服务。 OnBind()当组件调用bindService()想要绑定到service时(比如想要执行进程间通讯)系统调用此方法（一次调用，一旦绑定后，下次再调用bindService()不会回调该方法）。在你的实现中，你必须提供一个返回一个IBinder来以使客户端能够使用它与service通讯，你必须总是实现这个方法，但是如果你不允许绑定，那么你应返回null。 OnUnbind()当前组件调用unbindService()，想要解除与service的绑定时系统调用此方法（一次调用，一旦解除绑定后，下次再调用unbindService()会抛出异常）。 OnDestory()系统在service不再被使用并要销毁时调用此方法（一次调用）。service应在此方法中释放资源，比如线程，已注册的侦听器，接收器等等．这是service收到的最后一个调用。 下面介绍三种不同情况下Service的生命周期情况。 1.startService / stopService生命周期顺序：onCreate-&gt;onStartCommand-&gt;onDestroy 如果一个Service被某个Activity 调用 Context.startService方法启动，那么不管是否有Activity使用bindService绑定或unbindService解除绑定到该Service，该Service都在后台运行，直到被调用stopService，或自身的stopSelf方法。当然如果系统资源不足，android系统也可能结束服务，还有一种方法可以关闭服务，在设置中，通过应用-&gt;找到自己应用-&gt;停止。 注意点： ①第一次 startService 会触发 onCreate 和 onStartCommand，以后在服务运行过程中，每次 startService 都只会触发 onStartCommand ②不论 startService 多少次，stopService 一次就会停止服务 2.bindService / unbindService生命周期顺序：onCreate-&gt;onBind-&gt;onUnBind-&gt;onDestroy 如果一个Service在某个Activity中被调用bindService方法启动，不论bindService被调用几次，Service的onCreate方法只会执行一次，同时onStartCommand方法始终不会调用。 当建立连接后，Service会一直运行，除非调用unbindService来接触绑定、断开连接或调用该Service的Context不存在了（如Activity被Finish——即通过bindService启动的Service的生命周期依附于启动它的Context），系统在这时会自动停止该Service。 注意点： 第一次 bindService 会触发 onCreate 和 onBind，以后在服务运行过程中，每次 bindService 都不会触发任何回调 3.混合型（上面两种方式的交互）当一个Service在被启动(startService)的同时又被绑定(bindService)，该Service将会一直在后台运行，并且不管调用几次，onCreate方法始终只会调用一次，onStartCommand的调用次数与startService调用的次数一致（使用bindService方法不会调用onStartCommand）。同时，调用unBindService将不会停止Service，必须调用stopService或Service自身的stopSelf来停止服务。 在什么情况下使用 startService 或 bindService 或 同时使用startService 和 bindService？①如果你只是想要启动一个后台服务长期进行某项任务那么使用 startService 便可以了。 ②如果你想要与正在运行的 Service 取得联系，那么有两种方法，一种是使用 broadcast ，另外是使用 bindService ，前者的缺点是如果交流较为频繁，容易造成性能上的问题，并且 BroadcastReceiver 本身执行代码的时间是很短的（也许执行到一半，后面的代码便不会执行），而后者则没有这些问题，因此我们肯定选择使用 bindService（这个时候你便同时在使用 startService 和 bindService 了，这在 Activity 中更新 Service 的某些运行状态是相当有用的）。 ③如果你的服务只是公开一个远程接口，供连接上的客服端（android 的 Service 是C/S架构）远程调用执行方法。这个时候你可以不让服务一开始就运行，而只用 bindService ，这样在第一次 bindService 的时候才会创建服务的实例运行它，这会节约很多系统资源，特别是如果你的服务是Remote Service，那么该效果会越明显（当然在 Service 创建的时候会花去一定时间，你应当注意到这点）。 四、Service的几种典型使用实例1.不可交互的后台服务不可交互的后台服务即是普通的Service，通过startService()方式开启。Service的生命周期很简单，分别为onCreate、onStartCommand、onDestroy这三个。 创建服务类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BackService extends Service &#123; private Thread mThread; @Override public void onCreate() &#123; super.onCreate(); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; System.out.println("onBind"); return null; &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; //执行耗时操作 mThread = new Thread() &#123; @Override public void run() &#123; try &#123; while (true) &#123; //等待停止线程 if (this.isInterrupted()) &#123; throw new InterruptedException(); &#125; //耗时操作。 System.out.println("执行耗时操作"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; mThread.start(); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); //停止线程 mThread.interrupt(); &#125;&#125; 配置服务： 12&lt;service android:name=".BackService"&gt;&lt;/service&gt; 如果想配置成远程服务，加如下代码： 1android:process="remote" 配置好Service类，只需要在前台，调用startService()方法，就会启动耗时操作。 注意： ①不运行在一个独立的进程中，它同样执行在UI线程中，因此，在Service中创建了子线程来完成耗时操作。 ②当Service关闭后，如果在onDestory()方法中不关闭线程，你会发现我们的子线程进行的耗时操作是一直存在的，此时关闭该子线程的方法需要直接关闭该应用程序。因此，在onDestory()方法中要进行必要的清理工作。 2.可交互的后台服务可交互的后台服务是指前台页面可以调用后台服务的方法，通过bindService()方式开启。Service的生命周期很简单，分别为onCreate、onBind、onUnBind、onDestroy这四个。可交互的后台服务实现步骤是和不可交互的后台服务实现步骤是一样的，区别在于启动的方式和获得Service的代理对象。 创建服务类和普通Service不同在于这里返回一个代理对象，返回给前台进行获取，即前台可以获取该代理对象执行后台服务的方法 1234567891011121314151617181920212223242526public class BackService extends Service &#123; @Override public void onCreate() &#123; super.onCreate(); &#125; @Nullable @Override public IBinder onBind(Intent intent) &#123; //返回MyBinder对象 return new MyBinder(); &#125; //需要返回给前台的Binder类 class MyBinder extends Binder &#123; public void showTip()&#123; System.out.println("我是来此服务的提示"); &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); &#125;&#125; 前台调用通过以下方式绑定服务： 1bindService(mIntent,con,BIND_AUTO_CREATE); 其中第二个参数： 123456789101112private ServiceConnection con = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; BackService.MyBinder myBinder = (BackService.MyBinder) service; myBinder.showTip(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125; &#125;; 当建立绑定后，onServiceConnected中的service便是Service类中onBind的返回值。如此便可以调用后台服务类的方法，实现交互。 当调用unbindService()停止服务，同时要在onDestory()方法中做好清理工作。 注意：通过bindService启动的Service的生命周期依附于启动它的Context。因此当前台调用bindService的Context销毁后，那么服务会自动停止。 3.混合型后台服务将上面两种启动方式结合起来就是混合性交互的后台服务了，即可以单独运行后台服务，也可以运行后台服务中提供的方法，其完整的生命周期是：onCreate-&gt;onStartCommand-&gt;onBind-&gt;onUnBind-&gt;onDestroy 4.前台服务所谓前台服务只不是通过一定的方式将服务所在的进程级别提升了。前台服务会一直有一个正在运行的图标在系统的状态栏显示，非常类似于通知的效果。 由于后台服务优先级相对比较低，当系统出现内存不足的情况下，它就有可能会被回收掉，所以前台服务就是来弥补这个缺点的，它可以一直保持运行状态而不被系统回收。 创建服务类 前台服务创建很简单，其实就在Service的基础上创建一个Notification，然后使用Service的startForeground()方法即可启动为前台服务。 1234567891011121314151617181920212223242526272829303132333435363738public class ForeService extends Service&#123; @Nullable @Override public IBinder onBind(Intent intent) &#123; return null; &#125; @Override public void onCreate() &#123; super.onCreate(); beginForeService(); &#125; private void beginForeService() &#123; //创建通知 Notification.Builder mBuilder = new Notification.Builder(this) .setSmallIcon(R.mipmap.ic_launcher) .setContentText("2017-2-27") .setContentText("您有一条未读短信..."); //创建点跳转的Intent(这个跳转是跳转到通知详情页) Intent intent = new Intent(this,NotificationShow.class); //创建通知详情页的栈 TaskStackBuilder stackBulider = TaskStackBuilder.create(this); //为其添加父栈 当从通知详情页回退时，将退到添加的父栈中 stackBulider.addParentStack(NotificationShow.class); PendingIntent pendingIntent = stackBulider.getPendingIntent(0,PendingIntent.FLAG_UPDATE_CURRENT); //设置跳转Intent到通知中 mBuilder.setContentIntent(pendingIntent); //获取通知服务 NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); //构建通知 Notification notification = mBuilder.build(); //显示通知 nm.notify(0,notification); //启动前台服务 startForeground(0,notification); &#125;&#125; 启动前台服务 1startService(new Intent(this, ForeService.class)); 关于TaskStackBuilder 这一段，可能不是看的很明白，下面详细介绍。 TaskStackBuilder在Notification通知栏中的使用首先是用一般的PendingIntent来进行跳转 12345678mBuilder = new NotificationCompat.Builder(this).setContent(view) .setSmallIcon(R.drawable.icon).setTicker("新资讯") .setWhen(System.currentTimeMillis()) .setOngoing(false) .setAutoCancel(true);Intent intent = new Intent(this, NotificationShow.class);PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);mBuilder.setContentIntent(pendingIntent); 这里是直接用PendingIntent来跳转到NotificationShow。 在运行效果上来看，首先发送了一条Notification到通知栏上，然后这时，退出程序，即MainActivity已经不存在了，回到home主菜单，看到Notification仍然存在，当然，我们还没有点击或者cancel它，现在去点击Notification，跳转到NotificationShow界面，然后我们按下Back键，发现直接回到home菜单了。现在大多数android应用都是在通知栏中如果有Notification通知的话，点击它，然后会直接跳转到对应的应用程序的某个界面，这时如果回退，即按下Back键，会返回到该应用程序的主界面，而不是系统的home菜单。所以用上面这种PendingIntent的做法达不到目的。这里我们使用TaskStackBuilder来做。 12345678910111213mBuilder = new NotificationCompat.Builder(this) .setContent(view) .setSmallIcon(R.drawable.icon).setTicker("新资讯") .setWhen(System.currentTimeMillis()) .setOngoing(false) .setAutoCancel(true);Intent intent = new Intent(this, NotificationShow.class);TaskStackBuilder stackBuilder = TaskStackBuilder.create(this);stackBuilder.addParentStack(NotificationShow.class);stackBuilder.addNextIntent(intent);PendingIntent pendingIntent = stackBuilder.getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);//PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);mBuilder.setContentIntent(pendingIntent); 显示用TaskStackBuilder.create(this)创建一个stackBuilder实例，接下来addParentStack(); 关于这个方法，我们查一下官方API文档： Add the activity parent chain as specified by the parentActivityName attribute of the activity (or activity-alias) element in the application’s manifest to the task stack builder 这句话意思是：为跳转后的activity添加一个父activity，在activity中的manifest中添加parentActivityName即可。 那么我们就在manifest文件中添加这个属性 1234&lt;activity android:name="com.lvr.service.NotificationShow" android:parentActivityName=".MainActivity" &gt;&lt;/activity&gt; 这里我让它的parentActivity为MainActivity，也就是说在NotificationShow这个界面点击回退时，会跳转到MainActivity这个界面，而不是像上面一样直接回到了home菜单。 注意：通过 stopForeground()方法可以取消通知，即将前台服务降为后台服务。此时服务依然没有停止。通过stopService()可以把前台服务停止。 以上是关于Service的内容。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity的使用与了解]]></title>
    <url>%2F2018%2F06%2F07%2FActivity%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、Activity的生命周期本节内容将生命周期的情况分为两部分介绍，第一部分先了解典型的生命周期的7个部分及Activity的状态。第二部分会介绍Activity在一些特殊情况下的生命周期的经历过程。 1.典型的生命周期的了解先上经典图片。 关于这张图片，我们可能在初学Android时就有接触，今天我们继续回顾一下。 在正常情况下，一个Activity从启动到结束会以如下顺序经历整个生命周期：onCreate()-&gt;onStart()-&gt;onResume()-&gt;onPause()-&gt;onStop()-&gt;onDestory()。包含了六个部分，还有一个onRestart()没有调用，下面我们一一介绍这七部分内容。 (1) onCreate()：当 Activity 第一次创建时会被调用。这是生命周期的第一个方法。在这个方法中，可以做一些初始化工作，比如调用setContentView去加载界面布局资源，初始化Activity所需的数据。当然也可借助onCreate()方法中的Bundle对象来回复异常情况下Activity结束时的状态（后面会介绍）。 (2) onRestart()：表示Activity正在重新启动。一般情况下，当当前Activity从不可见重新变为可见状态时，onRestart就会被调用。这种情形一般是用户行为导致的，比如用户按Home键切换到桌面或打开了另一个新的Activity，接着用户又回到了这个Actvity。（关于这部分生命周期的历经过程，后面会介绍。） (3) onStart(): 表示Activity正在被启动，即将开始，这时Activity已经出现了，但是还没有出现在前台，无法与用户交互。这个时候可以理解为Activity已经显示出来，但是我们还看不到。 (4) onResume():表示Activity已经可见了，并且出现在前台并开始活动。需要和onStart()对比，onStart的时候Activity还在后台，onResume的时候Activity才显示到前台。 (5) onPause():表示 Activity正在停止，仍可见，正常情况下，紧接着onStop就会被调用。在特殊情况下，如果这个时候快速地回到当前Activity，那么onResume就会被调用（极端情况）。onPause中不能进行耗时操作，会影响到新Activity的显示。因为onPause必须执行完，新的Activity的onResume才会执行。 (6) onStop():表示Activity即将停止，不可见，位于后台。可以做稍微重量级的回收工作，同样不能太耗时。 (7) onDestory():表示Activity即将销毁，这是Activity生命周期的最后一个回调，可以做一些回收工作和最终的资源回收。 在平常的开发中，我们经常用到的就是 onCreate()和onDestory()，做一些初始化和回收操作。 生命周期的几种普通情况①针对一个特定的Activity，第一次启动，回调如下：onCreate()-&gt;onStart()-&gt;onResume() ②用户打开新的Activiy的时候，上述Activity的回调如下：onPause()-&gt;onStop() ③再次回到原Activity时，回调如下：onRestart()-&gt;onStart()-&gt;onResume() ④按back键回退时，回调如下：onPause()-&gt;onStop()-&gt;onDestory() ⑤按Home键切换到桌面后又回到该Actitivy，回调如下：onPause()-&gt;onStop()-&gt;onRestart()-&gt;onStart()-&gt;onResume() ⑥调用finish()方法后，回调如下：onDestory()(以在onCreate()方法中调用为例，不同方法中回调不同，通常都是在onCreate()方法中调用) 2.特殊情况下的生命周期上面是普通情况下Activity生命周期的一些流程，但是在一些特殊情况下，Activity的生命周期的经历有些异常，下面就是两种特殊情况。①横竖屏切换在横竖屏切换的过程中，会发生Activity被销毁并重建的过程。 在了解这种情况下的生命周期时，首先应该了解这两个回调：onSaveInstanceState和onRestoreInstanceState。 在Activity由于异常情况下终止时，系统会调用onSaveInstanceState来保存当前Activity的状态。这个方法的调用是在onStop之前，它和onPause没有既定的时序关系，该方法只在Activity被异常终止的情况下调用。当异常终止的Activity被重建以后，系统会调用onRestoreInstanceState，并且把Activity销毁时onSaveInstanceState方法所保存的Bundle对象参数同时传递给onRestoreInstanceState和onCreate方法。因此，可以通过onRestoreInstanceState方法来恢复Activity的状态，该方法的调用时机是在onStart之后。其中onCreate和onRestoreInstanceState方法来恢复Activity的状态的区别： onRestoreInstanceState回调则表明其中Bundle对象非空，不用加非空判断。onCreate需要非空判断。建议使用onRestoreInstanceState。 横竖屏切换的生命周期：onPause()-&gt;onSaveInstanceState()-&gt; onStop()-&gt;onDestroy()-&gt;onCreate()-&gt;onStart()-&gt;onRestoreInstanceState-&gt;onResume() 可以通过在AndroidManifest文件的Activity中指定如下属性： 1android:configChanges = "orientation| screenSize" 来避免横竖屏切换时，Activity的销毁和重建，而是回调了下面的方法： 1234@Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); &#125; ②资源内存不足导致优先级低的Activity被杀死Activity优先级的划分和下面的Activity的三种运行状态是对应的。 (1) 前台Activity——正在和用户交互的Activity，优先级最高。 (2) 可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户交互。 (3) 后台Activity——已经被暂停的Activity，比如执行了onStop，优先级最低。 当系统内存不足时，会按照上述优先级从低到高去杀死目标Activity所在的进程。我们在平常使用手机时，能经常感受到这一现象。这种情况下数组存储和恢复过程和上述情况一致，生命周期情况也一样。 3.Activity的三种运行状态①Resumed（活动状态） 又叫Running状态，这个Activity正在屏幕上显示，并且有用户焦点。这个很好理解，就是用户正在操作的那个界面。 ②Paused（暂停状态） 这是一个比较不常见的状态。这个Activity在屏幕上是可见的，但是并不是在屏幕最前端的那个Activity。比如有另一个非全屏或者透明的Activity是Resumed状态，没有完全遮盖这个Activity。 ③Stopped（停止状态） 当Activity完全不可见时，此时Activity还在后台运行，仍然在内存中保留Activity的状态，并不是完全销毁。这个也很好理解，当跳转的另外一个界面，之前的界面还在后台，按回退按钮还会恢复原来的状态，大部分软件在打开的时候，直接按Home键，并不会关闭它，此时的Activity就是Stopped状态。 二、Activity的启动模式1.启动模式的类别Android提供了四种Activity启动方式： 标准模式（standard）栈顶复用模式（singleTop）栈内复用模式（singleTask）单例模式（singleInstance） 2.启动模式的结构——栈Activity的管理是采用任务栈的形式，任务栈采用“后进先出”的栈结构。 3.Activity的LaunchMode(1)标准模式（standard）每启动一次Activity，就会创建一个新的Activity实例并置于栈顶。谁启动了这个Activity，那么这个Activity就运行在启动它的那个Activity所在的栈中。 例如：Activity A启动了Activity B，则就会在A所在的栈顶压入一个新的Activity。 特殊情况，如果在Service或Application中启动一个Activity，其并没有所谓的任务栈，可以使用标记位Flag来解决。解决办法：为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK标记位，创建一个新栈。 应用场景： 绝大多数Activity。如果以这种方式启动的Activity被跨进程调用，在5.0之前新启动的Activity实例会放入发送Intent的Task的栈的顶部，尽管它们属于不同的程序，这似乎有点费解看起来也不是那么合理，所以在5.0之后，上述情景会创建一个新的Task，新启动的Activity就会放入刚创建的Task中，这样就合理的多了。 (2)栈顶复用模式（singleTop）如果需要新建的Activity位于任务栈栈顶，那么此Activity的实例就不会重建，而是重用栈顶的实例。并回调如下方法： 1234@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent);&#125; 由于不会重建一个Activity实例，则不会回调其他生命周期方法。如果栈顶不是新建的Activity,就会创建该Activity新的实例，并放入栈顶。 应用场景： 在通知栏点击收到的通知，然后需要启动一个Activity，这个Activity就可以用singleTop，否则每次点击都会新建一个Activity。当然实际的开发过程中，测试妹纸没准给你提过这样的bug：某个场景下连续快速点击，启动了两个Activity。如果这个时候待启动的Activity使用 singleTop模式也是可以避免这个Bug的。同standard模式，如果是外部程序启动singleTop的Activity，在Android 5.0之前新创建的Activity会位于调用者的Task中，5.0及以后会放入新的Task中。 (3)栈内复用模式（singleTask）该模式是一种单例模式，即一个栈内只有一个该Activity实例。该模式，可以通过在AndroidManifest文件的Activity中指定该Activity需要加载到那个栈中，即singleTask的Activity可以指定想要加载的目标栈。singleTask和taskAffinity配合使用，指定开启的Activity加入到哪个栈中。 12345&lt;activity android:name=".Activity1" android:launchMode="singleTask" android:taskAffinity="com.lvr.task" android:label="@string/app_name"&gt;&lt;/activity&gt; 关于taskAffinity的值： 每个Activity都有taskAffinity属性，这个属性指出了它希望进入的Task。如果一个Activity没有显式的指明该Activity的taskAffinity，那么它的这个属性就等于Application指明的taskAffinity，如果Application也没有指明，那么该taskAffinity的值就等于包名。 执行逻辑： 在这种模式下，如果Activity指定的栈不存在，则创建一个栈，并把创建的Activity压入栈内。如果Activity指定的栈存在，如果其中没有该Activity实例，则会创建Activity并压入栈顶，如果其中有该Activity实例，则把该Activity实例之上的Activity杀死清除出栈，重用并让该Activity实例处在栈顶，然后调用onNewIntent()方法。 对应如下三种情况： 应用场景： 大多数App的主页。对于大部分应用，当我们在主界面点击回退按钮的时候都是退出应用，那么当我们第一次进入主界面之后，主界面位于栈底，以后不管我们打开了多少个Activity，只要我们再次回到主界面，都应该使用将主界面Activity上所有的Activity移除的方式来让主界面Activity处于栈顶，而不是往栈顶新加一个主界面Activity的实例，通过这种方式能够保证退出应用时所有的Activity都能报销毁。在跨应用Intent传递时，如果系统中不存在singleTask Activity的实例，那么将创建一个新的Task，然后创建SingleTask Activity的实例，将其放入新的Task中。 (4)单例模式（singleInstance）作为栈内复用模式（singleTask）的加强版,打开该Activity时，直接创建一个新的任务栈，并创建该Activity实例放入新栈中。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例。 应用场景： 呼叫来电界面。这种模式的使用情况比较罕见，在Launcher中可能使用。或者你确定你需要使Activity只有一个实例。建议谨慎使用。 3.特殊情况——前台栈和后台栈的交互假如目前有两个任务栈。前台任务栈为AB，后台任务栈为CD，这里假设CD的启动模式均为singleTask,现在请求启动D，那么这个后台的任务栈都会被切换到前台，这个时候整个后退列表就变成了ABCD。当用户按back返回时，列表中的activity会一一出栈，如下图。 如果不是请求启动D而是启动C，那么情况又不一样，如下图。 调用SingleTask模式的后台任务栈中的Activity，会把整个栈的Actvity压入当前栈的栈顶。singleTask会具有clearTop特性，把之上的栈内Activity清除。 4.Activity的FlagsActivity的Flags很多，这里介绍集中常用的，用于设定Activity的启动模式。可以在启动Activity时，通过Intent的addFlags()方法设置。 (1)FLAG_ACTIVITY_NEW_TASK其效果与指定Activity为singleTask模式一致。 (2)FLAG_ACTIVITY_SINGLE_TOP其效果与指定Activity为singleTop模式一致。 (3)FLAG_ACTIVITY_CLEAR_TOP具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。如果和singleTask模式一起出现，若被启动的Activity已经存在栈中，则清除其之上的Activity，并调用该Activity的onNewIntent方法。如果被启动的Activity采用standard模式，那么该Activity连同之上的所有Activity出栈，然后创建新的Activity实例并压入栈中。]]></content>
      <categories>
        <category>Android</category>
        <category>Android基础</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于网易的一次面试经历]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%85%B3%E4%BA%8E%E7%BD%91%E6%98%93%E7%9A%84%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[面试经历：1、动画的区别；2、rn实现动画的原理；3、rn的原理机制；4、view事件触发；5、自定义view的onMesure, onLayout, onDraw过程;6、第三方库的原理；7、recyclerview header的原理；8、app启动原理；9、传统动画跟属性动画的区别；10、http1、http1.1,http2 区别及有了哪些改进；11、tcp 三次握手步骤；12、链接断开需要经过几次握手；13、webview原理；14、RN自定义注册组件；15、网络请求原理；16、事件触摸传输流程；17、context创建的时机；18、handle机制，Loop分发消息的原理；19、frescoURL转成bitmap的过程；20、fresco匿名存储的原理；21、内存泄漏问题；22、检测内存泄漏工具；23、leakcanary原理；24、检测卡顿问题；25、父布局如何拦截并处理事件再通知子view;26、View测量、布局及绘制原理；27、RGB_565与RGB_888区别；28、字节相关； 、学习weex; 、多总结，多表达自己的观点；]]></content>
      <categories>
        <category>面试经历</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解析Dagger2]]></title>
    <url>%2F2018%2F05%2F24%2F%E8%A7%A3%E6%9E%90Dagger2%2F</url>
    <content type="text"><![CDATA[http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2018/0102/9047.html 关于Dagger2什么是依赖注入主要用来解决什么问题Dagger其实是一个依赖注入的框架。 通常依赖注入有以下几种方式 通过接口注入; 通过set方法注入; 通过构造方法注入; 通过注解的方式注入; @Inject 程序会将Dagger2会将带有此注解的变量或者构造方法参与到依赖注入当中，Dagger2会实例化这个对象 @Module 带有该注解的类需要对外提供依赖，其实就是提供实例化需要的参数，Dagger2在实例化的过程中发现一些参数，Dagger2就会到该类中寻找带有@Provides注解的以provide开头的需找对应的参数 @Component 带有该注解的接口或抽象类起到一个关联桥梁的作用，作用就是将带有@Inject的方法或对象和带有@Module的类进行关联，只有通过该接口或抽象类才可以在实例化的时候到带有 @Module中类中去寻找需要的参数，也就是依赖注入。 Dagger2 注解开篇我们就提到Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。 @Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖； @Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。 @Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值； @Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入； @Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。—-一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示； @Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例； @Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下： 步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。步骤2：若存在提供依赖的方法，查看该方法是否存在参数。a：若存在参数，则按从步骤1开始依次初始化每个参数；b：若不存在，则直接初始化该类实例，完成一次依赖注入。 步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。a：若存在参数，则从步骤1开始依次初始化每一个参数b：若不存在，则直接初始化该类实例，完成一次依赖注入。 LoginActivity中的代码12345678910111213141516171819202122public class LoginActivity extends AppCompatActivity implements ILoginView,View.OnClickListener&#123; .......... //注意此处使用了注解 @Inject LoginPresenterCompl loginPresenter ; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mLogin = (Button) findViewById(R.id.btn_login); mClear = (Button) findViewById(R.id.btn_clear); mName = (EditText) findViewById(R.id.et_name); mPassWord = (EditText) findViewById(R.id.et_password); mLogin.setOnClickListener(this); mClear.setOnClickListener(this); DaggerMainComponent.builder().mainModule(new MainModule(this)).build().inject(this); &#125; .......&#125; LoginPresenterCompl中的代码1234567891011public class LoginPresenterCompl implements ILoginPresenter &#123; private ILoginView loginView ; private User user ; //注意此处使用了注解 @Inject public LoginPresenterCompl(ILoginView view)&#123; loginView = view ; user = new User(&quot;张三&quot;,&quot;123456&quot;) ; &#125; ...... &#125; 新增的MainModule类1234567891011@Modulepublic class MainModule &#123; private final ILoginView view ; public MainModule(ILoginView view)&#123; this.view = view ; &#125; @Provides ILoginView provideILogView()&#123; return view ; &#125;&#125; 新增的MainComponent接口1234@Component(modules = MainModule.class)public interface MainComponent &#123; public void inject(LoginActivity activity) ;&#125; 在LoginActivity中是通过1DaggerMainComponent.builder().mainModule(new MainModule(this)).build().inject(this) 下面我们来捋捋思路。 1、在这个示例代码中，LoginActivity中需要LoginPresenterCompl，所以在LoginActivity中定义了该对象并且通过@Inject将其注解，同时到LoginPresenterCompl的构造方法中也通过@Inject将其注解，表明这些是需要依赖注入的。 2、因为在LoginPresenterCompl的构造方法需要ILoginView类型的参数，所以需要通过依赖将获取这些参数，所以就需要带有@Module注解的类用于获取需要的参数，在@Module注解的类中通过被@Provides注解的以provide开头的方法对外提供需要的参数，一般而言有几个参数就需要有几个带有@Provides的方法。 3、此时还需要一个桥梁将两者联系到一起，带有@Component的接口或抽象类就起到这个桥梁的作用。注解中有一个module的值，这个值指向需要依赖的Module类，同时其中有一个抽象方法inject()，其中的参数就是我们需要在哪个类中实例化LoginPreserentCompl，因为我们需要在LoginActivity中实例化，所以参数类型就是LoginActivity类型。然后在Android studio中rebuild我们的项目，就会生成DaggerMainComponent类，通过1DaggerMainComponent.builder().mainModule(new MainModule(this)).build().inject(this);]]></content>
      <categories>
        <category>开源库</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>dagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MVC、MVP和MVVM了解]]></title>
    <url>%2F2018%2F05%2F24%2F%E5%85%B3%E4%BA%8EMVC%E3%80%81MVP%E5%92%8CMVVM%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言在开发应用程序的时候，以求更好的管理应用程序的复杂性，基于职责分离的思想都会对应用程序进行分层。在开发图形界面应用程序的时候，会吧管理用户界面的层次称为View，应用程序的数据称为Model(注意这里的Model指的是Domain Model,这个应用程序对需要解决的问题的数据抽象，不包含应用的状态，可以理解为对象)。Model层对应用程序的业务逻辑无知，只保存数据结构和提供数据操作的接口: 有了View和Model的分层，那么就有了两个问题： 1、响应用户操作的业务逻辑（例如排序）的管理；2、View如何同步Model的变更； 带着这两个问题开始探索MV*模式，会发现这些模式之间的差异可以归纳为这两个问题处理方式的不同。而几乎所有的MV*模式都是经典的MVC的修改版。 MVCMVC的依赖关系MVC除了 把应用程序分成View、Model层，还额外的加了一个Controller层，它的职责就是专门管理应用程序的业务逻辑。Model、View、Controller三层的依赖关系如下： Controller和View都依赖Model层，Controller和View可以相互依赖。在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的业务逻辑的处理权交给Controller。 MVC的调用关系用户对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller(Pass calls)；Controller接着会执行相关的业务逻辑，这些业务逻辑可能需要对Model进行相应的操作；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View;View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。如下图： 看似没有什么特别的地方，但是由几个需要特别关注的关键点： 1、View是把控制权交移给Controller，自己不执行业务逻辑。2、Controller执行业务逻辑并且操作Model，但不会直接操作View，可以说它是对View无知的。3、 View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。 需要特别注意的是MVC模式的精髓在于第三点：Model的更新是通过观察者模式告知View的，具体表现形式可以是Pub/Sub或者是触发Events。而网上很对对MVC的描述都没有强调这一点。通过观察者模式的好处就是：不同MVC三角关系可能会有共同的Model，一个MVC三角中的Controller操作了Model以后，两个MVC三角的View都会接收到通知，然后更新自己。保持了依赖同一块Model的不同View显示数据的实时性和准确性。我们每天都在用观察者模式，在几十年前就已经被大神们整合到MVC的架构当中。 MVC的优缺点优点： 1、 把业务逻辑全部分离到Controller中， 模块化程度高。当业务逻辑变更的时候， 不需要变更View和Model，只需要Controller换成另外一个Controller就行了（Swappable Controller）.2、 观察者模式可以做到多视图同时更新。 缺点： 1、Controller测试困难。因为视图同步操作是由View自己执行， 而View只能在由UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候， 无法对View的更新操作进行断言。 2、View无法组件化。View是强依赖特定的Model的， 如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的Domain Model是不一样的。 MVC Model2在Web服务端开发的时候也会接触到MVC模式， 而这种MVC模式不能严格称为MVC模式。经典的MVC模式只是解决客户端图形界面应用程序的问题， 而对服务端无效。服务端的MVC模式有自己特定的名字：MVC Model 2, 或者叫JSP Model 2, 或者直接就是Model 2。 Model2 客户端服务端的交互模式如下： 服务端接收到客户端的请求，服务端通过路由规则把这个请求交由特定的Controller进行处理， Controller执行相应的业务逻辑， 对数据库数据（Model）进行操作， 然后用数据去渲染特定的模板， 返回给客户端。 因为HTTP协议是单公协议并且是无状态的， 服务器无法直接给客户端推送数据。除非客户端再次发起请求， 否则服务器端的Model的变更就无法告知客户端。所以可以看到经典的MVC中Model通过观察者模式告知View更新这一环被无情的打破， 不能称为严格的MVC。 Model 2模式最早在1998年应用在JSP应用程序当中，JSP Model 1应用管理的混乱诱发了JSP参考了客户端MVC模式，催生了Model 2。 后来这种模式几乎被应用在所有语言的Web开发框架当中。PHP的ThinkPHP，Python的Dijango、Flask，NodeJS的Express，Ruby的RoR，基本都采纳了这种模式。平常所讲的MVC基本是这种服务端的MVC。 MVPMVP模式有两种： 1、Passive View2、Supervising Controller 而大多数情况下讨论的都是Passive View模式。 本文对PV模式进行较为详细的介绍， 而SC模式则简单提及。 历史背景 MVP模式是MVC模式的改良。 在上世纪90年代， IBM旗下的子公司Taligent在用C/C++开发一个叫CommonPoint的图形界面应用系统的时候提出来的。 MVP(Passive View)的依赖关系MVP模式把MVC模式中的Controller换成Presenter。MVP层次之间的依赖关系如下： MVP打破了View原来对于Model的依赖。其余的依赖关系和MVC模式一致。 MVP（Passive View）的调用关系既然View对Model的依赖被打破了， 那View如何同步Model的变更？看看MVP的调用关系： 和MVC模式一样， 用户对View的操作都会从View交移给Presenter。Presenter同样的会执行相应的业务逻辑， 并且对Model进行相应的操作；而这个时候Model也是通过观察者模式把自己变更的消息传递出去， 但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后， 通过View提供的接口更新界面。 关键点： 1、View不再负责同步的逻辑， 而是由Presenter负责。Presenter中既有业务逻辑也有同步逻辑。2、View需要提供操作界面的接口给Presenter进行调用。（关键） 对比在MVC中， Controller是不能操作View的， View也没有提供相应的接口；而在MVP当中，Presenter可以操作View, View需要提一组对界面操作的接口给Presenter进行调用；Model仍然通过事件广播自己的变更，但有Presenter监听而不是View。 MVP模式， 这里也提供一个用MVP例子todo-mvp； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 定义一个View层的统一接口 */public interface IView &#123; void updateUI(String text);&#125;/** * View层，负责界面的展示 */public class TestActivity extends AppCompatActivity implements IView &#123; TestPresent mPresent;//Present层实例 @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); mPresent=new TestPresent(this);//创建Present层的实例 mPresent.updateUI();//调用Present层的更新UI的方法 &#125; @Override public void updateUI(String text) &#123; ((TextView)findViewById(R.id.textview)).setText(text); &#125;&#125;/** * Present类，调用Model层的业务方法，更新View层的界面展示 */public class TestPresent &#123; IView mView;//View层实例 TestModel mModel;//Model层实例 //构造方法，传入View层的实例 public TestPresent(IView view)&#123; this.mView=view; this.mModel=new TestModel();//创建Model层的实例 &#125; //更新UI的方法 public void updateUI()&#123; mView.updateUI(mModel.getText());//调用Model层是业务逻辑，更新View层的界面展示 &#125;&#125;/** * Model类，实现具体的业务逻辑 */public class TestModel &#123; public TestModel()&#123; &#125; //返回需要展示的信息 public String getText()&#123; return &quot;Dagger2应用实践...&quot;; &#125;&#125; MVP（Passive View）的优缺点优点： 1、便于测试。Presenter对View是通过接口进行， 在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个对象，这个对象只需实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter业务逻辑的正确性。 2、View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务逻辑完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。 缺点： 1、Presenter中除了业务逻辑以外，还有大量的View-&gt;Model, Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。 MVP(Supervising Controller)上面讲的是MVP的Passive View模式，该模式下View非常Passive，它几乎什么都不知道，Presenter让它干什么它就干什么。而Supervising Controller模式中， Presenter会把一部分简单的同步逻辑交给View自己去做， Presenter只负责比较复杂的、高层次的UI操作，所以可以把它看成是一个Supervising Controller。 Supervising Controller模式中的依赖和调用关系： 因为Supervising Controller用得比较少，对它的讨论就这里为止。 MVVMMVVM可以看作是一种特殊的MVP（Passive View）模式，或者说是对MVP模式的一种改良。 ViewModelMVVM代表的是Model-View-ViewModel，这里需要解释下什么是ViewModel。ViewModel的含义就是“Model of View”，在图形界面应用程序当中， 界面所提供的信息可能不仅仅包含应用程序的领域模型。还可能包含一些领域模型不包含的视图状态，例如电子表格程序上需要显示当前排序的状态时顺序的还是逆序的，而这时Domain Model所不包含的， 但也是需要显示的信息。 可以简单吧ViewModel理解为页面上所显示内容的数据抽象， 和Domain Model不一样， ViewModel更适合用来描述View。 MVVM的依赖MVVM的依赖关系和MVP的依赖，只不过是把P换成了VM。 MVVM的调用关系MVVM的调用关系和MVP一样。但是， 在ViewModel当中会有一个叫Binder， 或者是Data-binding enginer的东西，以前全部有Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模板语法当中，指令式地声明View上的显示的内容是喝Model的哪一块数据绑定的。当ViewModel进行对Model更新的时候， Binder会自动把数据更新到View上去， 当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding, 双向数据绑定。可以简单而不恰当的理解为一个模板引擎，但会根据数据变更实施渲染。 MVVM的优缺点优点： 1、提高可维护性。解决了MVP大量的手动View和Model同步的问题， 提供双向定制机制， 提高了代码的可维护性。 2、简化测试。因为同步逻辑是交由Binder做的， View跟Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。 缺点： 1、过于简单的图形界面不适合， 或说牛刀杀鸡。 2、对于大型的图形应用程序，视图状态较多， ViewModel的构建和维护的成本都会比较高。 3、数据绑定的声明是指令式地写在View的模板当中的， 这些内容是没办法去打断点debug的。 结语可以看到，从MVC-&gt;MVP-&gt;MVVM，就像一个打怪升级的过程。后者解决了前者遗留的问题，把前者的缺点优化成了优点。同样的Demo功能，代码从最开始的一堆文件，优化成了最后只需要20几行代码就完成。MV*模式之间的区分还是蛮清晰的，希望可以给对这些模式理解比较模糊的同学带来一些参考和思路。]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>MVVM</tag>
        <tag>MVP</tag>
        <tag>MVC</tag>
      </tags>
  </entry>
</search>
