<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="MVVM,MVP,MVC," />










<meta name="description" content="前言在开发应用程序的时候，以求更好的管理应用程序的复杂性，基于职责分离的思想都会对应用程序进行分层。在开发图形界面应用程序的时候，会吧管理用户界面的层次称为View，应用程序的数据称为Model(注意这里的Model指的是Domain Model,这个应用程序对需要解决的问题的数据抽象，不包含应用的状态，可以理解为对象)。Model层对应用程序的业务逻辑无知，只保存数据结构和提供数据操作的接口:">
<meta property="og:type" content="article">
<meta property="og:title" content="关于MVC、MVP和MVVM了解">
<meta property="og:url" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/index.html">
<meta property="og:site_name" content="WinnerCode">
<meta property="og:description" content="前言在开发应用程序的时候，以求更好的管理应用程序的复杂性，基于职责分离的思想都会对应用程序进行分层。在开发图形界面应用程序的时候，会吧管理用户界面的层次称为View，应用程序的数据称为Model(注意这里的Model指的是Domain Model,这个应用程序对需要解决的问题的数据抽象，不包含应用的状态，可以理解为对象)。Model层对应用程序的业务逻辑无知，只保存数据结构和提供数据操作的接口:">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/01.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/02.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/03.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/04.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/05.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/06.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/07.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/08.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/09.png">
<meta property="og:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/10.png">
<meta property="og:updated_time" content="2018-05-30T09:51:26.289Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于MVC、MVP和MVVM了解">
<meta name="twitter:description" content="前言在开发应用程序的时候，以求更好的管理应用程序的复杂性，基于职责分离的思想都会对应用程序进行分层。在开发图形界面应用程序的时候，会吧管理用户界面的层次称为View，应用程序的数据称为Model(注意这里的Model指的是Domain Model,这个应用程序对需要解决的问题的数据抽象，不包含应用的状态，可以理解为对象)。Model层对应用程序的业务逻辑无知，只保存数据结构和提供数据操作的接口:">
<meta name="twitter:image" content="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/"/>





  <title>关于MVC、MVP和MVVM了解 | WinnerCode</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?642f81466b73ae68d2149c1678952ac8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">WinnerCode</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/24/关于MVC、MVP和MVVM了解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Winner Liu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="WinnerCode">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">关于MVC、MVP和MVVM了解</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-24T14:34:19+08:00">
                2018-05-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/架构设计/" itemprop="url" rel="index">
                    <span itemprop="name">架构设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在开发应用程序的时候，以求更好的管理应用程序的复杂性，基于职责分离的思想都会对应用程序进行分层。在开发图形界面应用程序的时候，会吧管理用户界面的层次称为View，应用程序的数据称为Model(注意这里的Model指的是Domain Model,这个应用程序对需要解决的问题的数据抽象，不包含应用的状态，可以理解为对象)。Model层对应用程序的业务逻辑无知，只保存数据结构和提供数据操作的接口:</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/01.png" alt="01.png" title="">
<p>有了View和Model的分层，那么就有了两个问题：</p>
<blockquote>
<p>1、响应用户操作的业务逻辑（例如排序）的管理；<br>2、View如何同步Model的变更；</p>
</blockquote>
<p>带着这两个问题开始探索MV*模式，会发现这些模式之间的差异可以归纳为这两个问题处理方式的不同。而几乎所有的MV*模式都是经典的MVC的修改版。</p>
<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><h5 id="MVC的依赖关系"><a href="#MVC的依赖关系" class="headerlink" title="MVC的依赖关系"></a>MVC的依赖关系</h5><p>MVC除了 把应用程序分成View、Model层，还额外的加了一个Controller层，它的职责就是专门管理应用程序的业务逻辑。Model、View、Controller三层的依赖关系如下：</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/02.png" alt="依赖关系" title="依赖关系">
<p>Controller和View都依赖Model层，Controller和View可以相互依赖。在一些网上的资料Controller和View之间的依赖关系可能不一样，有些是单向依赖，有些是双向依赖，这个其实关系不大，后面会看到它们的依赖关系都是为了把处理用户行为触发的业务逻辑的处理权交给Controller。</p>
<h5 id="MVC的调用关系"><a href="#MVC的调用关系" class="headerlink" title="MVC的调用关系"></a>MVC的调用关系</h5><p>用户对View操作以后，View捕获到这个操作，会把处理的权利交移给Controller(Pass calls)；Controller接着会执行相关的业务逻辑，这些业务逻辑可能需要对Model进行相应的操作；当Model变更了以后，会通过观察者模式（Observer Pattern）通知View;View通过观察者模式收到Model变更的消息以后，会向Model请求最新的数据，然后重新更新界面。如下图：</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/03.png" alt="03.png" title="">
<p>看似没有什么特别的地方，但是由几个需要特别关注的关键点：</p>
<blockquote>
<p>1、View是把控制权交移给Controller，自己不执行业务逻辑。<br>2、Controller执行业务逻辑并且操作Model，但不会直接操作View，可以说它是对View无知的。<br>3、 View和Model的同步消息是通过观察者模式进行，而同步操作是由View自己请求Model的数据然后对视图进行更新。</p>
</blockquote>
<p>需要特别注意的是MVC模式的精髓在于第三点：Model的更新是通过观察者模式告知View的，具体表现形式可以是Pub/Sub或者是触发Events。而网上很对对MVC的描述都没有强调这一点。通过观察者模式的好处就是：不同MVC三角关系可能会有共同的Model，一个MVC三角中的Controller操作了Model以后，两个MVC三角的View都会接收到通知，然后更新自己。保持了依赖同一块Model的不同View显示数据的实时性和准确性。我们每天都在用观察者模式，在几十年前就已经被大神们整合到MVC的架构当中。</p>
<h5 id="MVC的优缺点"><a href="#MVC的优缺点" class="headerlink" title="MVC的优缺点"></a>MVC的优缺点</h5><p>优点：</p>
<blockquote>
<p>1、 把业务逻辑全部分离到Controller中， 模块化程度高。当业务逻辑变更的时候， 不需要变更View和Model，只需要Controller换成另外一个Controller就行了（Swappable Controller）.<br>2、 观察者模式可以做到多视图同时更新。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>1、Controller测试困难。因为视图同步操作是由View自己执行， 而View只能在由UI的环境下运行。在没有UI环境下对Controller进行单元测试的时候，Controller业务逻辑的正确性是无法验证的：Controller更新Model的时候， 无法对View的更新操作进行断言。</p>
<p>2、View无法组件化。View是强依赖特定的Model的， 如果需要把这个View抽出来作为一个另外一个应用程序可复用的组件就困难了。因为不同程序的Domain Model是不一样的。</p>
</blockquote>
<h5 id="MVC-Model2"><a href="#MVC-Model2" class="headerlink" title="MVC Model2"></a>MVC Model2</h5><p>在Web服务端开发的时候也会接触到MVC模式， 而这种MVC模式不能严格称为MVC模式。经典的MVC模式只是解决客户端图形界面应用程序的问题， 而对服务端无效。服务端的MVC模式有自己特定的名字：MVC Model 2, 或者叫JSP Model 2, 或者直接就是Model 2。 Model2 客户端服务端的交互模式如下：</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/04.png" alt="04.png" title="">
<p>服务端接收到客户端的请求，服务端通过路由规则把这个请求交由特定的Controller进行处理， Controller执行相应的业务逻辑， 对数据库数据（Model）进行操作， 然后用数据去渲染特定的模板， 返回给客户端。</p>
<p>因为HTTP协议是单公协议并且是无状态的， 服务器无法直接给客户端推送数据。除非客户端再次发起请求， 否则服务器端的Model的变更就无法告知客户端。所以可以看到经典的MVC中Model通过观察者模式告知View更新这一环被无情的打破， 不能称为严格的MVC。</p>
<p>Model 2模式最早在1998年应用在JSP应用程序当中，JSP Model 1应用管理的混乱诱发了JSP参考了客户端MVC模式，催生了Model 2。</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/05.png" alt="05.png" title="">
<p>后来这种模式几乎被应用在所有语言的Web开发框架当中。PHP的ThinkPHP，Python的Dijango、Flask，NodeJS的Express，Ruby的RoR，基本都采纳了这种模式。平常所讲的MVC基本是这种服务端的MVC。</p>
<h4 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h4><p>MVP模式有两种：</p>
<blockquote>
<p>1、Passive View<br>2、Supervising Controller</p>
</blockquote>
<p>而大多数情况下讨论的都是Passive View模式。 本文对PV模式进行较为详细的介绍， 而SC模式则简单提及。</p>
<p>历史背景</p>
<p>MVP模式是MVC模式的改良。 在上世纪90年代， IBM旗下的子公司Taligent在用C/C++开发一个叫CommonPoint的图形界面应用系统的时候提出来的。</p>
<h5 id="MVP-Passive-View-的依赖关系"><a href="#MVP-Passive-View-的依赖关系" class="headerlink" title="MVP(Passive View)的依赖关系"></a>MVP(Passive View)的依赖关系</h5><p>MVP模式把MVC模式中的Controller换成Presenter。MVP层次之间的依赖关系如下：</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/06.png" alt="06.png" title="">
<p>MVP打破了View原来对于Model的依赖。其余的依赖关系和MVC模式一致。</p>
<h5 id="MVP（Passive-View）的调用关系"><a href="#MVP（Passive-View）的调用关系" class="headerlink" title="MVP（Passive View）的调用关系"></a>MVP（Passive View）的调用关系</h5><p>既然View对Model的依赖被打破了， 那View如何同步Model的变更？看看MVP的调用关系：</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/07.png" alt="07.png" title="">
<p>和MVC模式一样， 用户对View的操作都会从View交移给Presenter。Presenter同样的会执行相应的业务逻辑， 并且对Model进行相应的操作；而这个时候Model也是通过观察者模式把自己变更的消息传递出去， 但是是传给Presenter而不是View。Presenter获取到Model变更的消息以后， <strong>通过View提供的接口更新界面。</strong></p>
<p>关键点：</p>
<blockquote>
<p>1、View不再负责同步的逻辑， 而是由Presenter负责。Presenter中既有业务逻辑也有同步逻辑。<br>2、View需要提供操作界面的接口给Presenter进行调用。（关键）</p>
</blockquote>
<p>对比在MVC中， Controller是不能操作View的， View也没有提供相应的接口；而在MVP当中，Presenter可以操作View, View需要提一组对界面操作的接口给Presenter进行调用；Model仍然通过事件广播自己的变更，但有Presenter监听而不是View。</p>
<p>MVP模式， 这里也提供一个用<a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" title="MVP例子" target="_blank" rel="external">MVP例子todo-mvp</a>；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 定义一个View层的统一接口</div><div class="line"> */</div><div class="line">public interface IView &#123;</div><div class="line">    void updateUI(String text);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * View层，负责界面的展示</div><div class="line"> */</div><div class="line">public class TestActivity extends AppCompatActivity implements IView &#123;</div><div class="line">    TestPresent mPresent;//Present层实例</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_test);</div><div class="line">        mPresent=new TestPresent(this);//创建Present层的实例</div><div class="line">        mPresent.updateUI();//调用Present层的更新UI的方法</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void updateUI(String text) &#123;</div><div class="line">        ((TextView)findViewById(R.id.textview)).setText(text);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * Present类，调用Model层的业务方法，更新View层的界面展示</div><div class="line"> */</div><div class="line">public class TestPresent &#123;</div><div class="line">    IView mView;//View层实例</div><div class="line">    TestModel mModel;//Model层实例</div><div class="line">    //构造方法，传入View层的实例</div><div class="line">    public TestPresent(IView view)&#123;</div><div class="line">        this.mView=view;</div><div class="line">        this.mModel=new TestModel();//创建Model层的实例</div><div class="line">    &#125;</div><div class="line">    //更新UI的方法</div><div class="line">    public void updateUI()&#123;</div><div class="line">        mView.updateUI(mModel.getText());//调用Model层是业务逻辑，更新View层的界面展示</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> * Model类，实现具体的业务逻辑</div><div class="line"> */</div><div class="line">public class TestModel &#123;</div><div class="line">    public TestModel()&#123;</div><div class="line">    &#125;</div><div class="line">    //返回需要展示的信息</div><div class="line">    public String getText()&#123;</div><div class="line">        return &quot;Dagger2应用实践...&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="MVP（Passive-View）的优缺点"><a href="#MVP（Passive-View）的优缺点" class="headerlink" title="MVP（Passive View）的优缺点"></a>MVP（Passive View）的优缺点</h5><p>优点：</p>
<blockquote>
<p>1、便于测试。Presenter对View是通过接口进行， 在对Presenter进行不依赖UI环境的单元测试的时候。可以通过Mock一个对象，这个对象只需实现了View的接口即可。然后依赖注入到Presenter中，单元测试的时候就可以完整的测试Presenter业务逻辑的正确性。</p>
<p>2、View可以进行组件化。在MVP当中，View不依赖Model。这样就可以让View从特定的业务场景中脱离出来，可以说View可以做到对业务逻辑完全无知。它只需要提供一系列接口提供给上层操作。这样就可以做到高度可复用的View组件。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>1、Presenter中除了业务逻辑以外，还有大量的View-&gt;Model, Model-&gt;View的手动同步逻辑，造成Presenter比较笨重，维护起来会比较困难。</p>
</blockquote>
<h5 id="MVP-Supervising-Controller"><a href="#MVP-Supervising-Controller" class="headerlink" title="MVP(Supervising Controller)"></a>MVP(Supervising Controller)</h5><p>上面讲的是MVP的Passive View模式，该模式下View非常Passive，它几乎什么都不知道，Presenter让它干什么它就干什么。而Supervising Controller模式中， Presenter会把一部分简单的同步逻辑交给View自己去做， Presenter只负责比较复杂的、高层次的UI操作，所以可以把它看成是一个Supervising Controller。<br> Supervising Controller模式中的依赖和调用关系：</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/08.png" alt="08.png" title="">
<p>因为Supervising Controller用得比较少，对它的讨论就这里为止。</p>
<h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><p>MVVM可以看作是一种特殊的MVP（Passive View）模式，或者说是对MVP模式的一种改良。</p>
<h5 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h5><p>MVVM代表的是Model-View-ViewModel，这里需要解释下什么是ViewModel。ViewModel的含义就是“Model of View”，在图形界面应用程序当中， 界面所提供的信息可能不仅仅包含应用程序的领域模型。还可能包含一些领域模型不包含的视图状态，例如电子表格程序上需要显示当前排序的状态时顺序的还是逆序的，而这时Domain Model所不包含的， 但也是需要显示的信息。</p>
<p>可以简单吧ViewModel理解为页面上所显示内容的数据抽象， 和Domain Model不一样， ViewModel更适合用来描述View。</p>
<h5 id="MVVM的依赖"><a href="#MVVM的依赖" class="headerlink" title="MVVM的依赖"></a>MVVM的依赖</h5><p>MVVM的依赖关系和MVP的依赖，只不过是把P换成了VM。</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/09.png" alt="09.png" title="">
<h5 id="MVVM的调用关系"><a href="#MVVM的调用关系" class="headerlink" title="MVVM的调用关系"></a>MVVM的调用关系</h5><p>MVVM的调用关系和MVP一样。但是， 在ViewModel当中会有一个叫Binder， 或者是Data-binding enginer的东西，以前全部有Presenter负责的View和Model之间数据同步操作交由给Binder处理。你只需要在View的模板语法当中，指令式地声明View上的显示的内容是喝Model的哪一块数据绑定的。当ViewModel进行对Model更新的时候， Binder会自动把数据更新到View上去， 当用户对View进行操作（例如表单输入），Binder也会自动把数据更新到Model上去。这种方式称为：Two-way data-binding, 双向数据绑定。可以简单而不恰当的理解为一个模板引擎，但会根据数据变更实施渲染。</p>
<img src="/2018/05/24/关于MVC、MVP和MVVM了解/10.png" alt="10.png" title="">
<h5 id="MVVM的优缺点"><a href="#MVVM的优缺点" class="headerlink" title="MVVM的优缺点"></a>MVVM的优缺点</h5><p>优点：</p>
<blockquote>
<p>1、提高可维护性。解决了MVP大量的手动View和Model同步的问题， 提供双向定制机制， 提高了代码的可维护性。</p>
<p>2、简化测试。因为同步逻辑是交由Binder做的， View跟Model同时变更，所以只需要保证Model的正确性，View就正确。大大减少了对View同步更新的测试。</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>1、过于简单的图形界面不适合， 或说牛刀杀鸡。</p>
<p>2、对于大型的图形应用程序，视图状态较多， ViewModel的构建和维护的成本都会比较高。</p>
<p>3、数据绑定的声明是指令式地写在View的模板当中的， 这些内容是没办法去打断点debug的。</p>
</blockquote>
<h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>可以看到，从MVC-&gt;MVP-&gt;MVVM，就像一个打怪升级的过程。后者解决了前者遗留的问题，把前者的缺点优化成了优点。同样的Demo功能，代码从最开始的一堆文件，优化成了最后只需要20几行代码就完成。MV*模式之间的区分还是蛮清晰的，希望可以给对这些模式理解比较模糊的同学带来一些参考和思路。</p>

      
    </div>
    
    
    

    
      <div>
        <div id="wechat_subscriber" style="display: block; padding: 10px 0; margin: 20px auto; width: 100%; text-align: center">
    <img id="wechat_subscriber_qcode" src="/uploads/wechat-qcode.jpg" alt="Winner Liu wechat" style="width: 200px; max-width: 100%;"/>
    <div>欢迎您扫一扫上面的微信公众号，订阅我的博客！</div>
</div>

      </div>
    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/MVVM/" rel="tag"># MVVM</a>
          
            <a href="/tags/MVP/" rel="tag"># MVP</a>
          
            <a href="/tags/MVC/" rel="tag"># MVC</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/05/24/解析Dagger2/" rel="prev" title="解析Dagger2">
                解析Dagger2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Winner Liu" />
            
              <p class="site-author-name" itemprop="name">Winner Liu</p>
              <p class="site-description motion-element" itemprop="description">燃烧吧，我的小宇宙！</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVC"><span class="nav-number">2.</span> <span class="nav-text">MVC</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MVC的依赖关系"><span class="nav-number">2.1.</span> <span class="nav-text">MVC的依赖关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVC的调用关系"><span class="nav-number">2.2.</span> <span class="nav-text">MVC的调用关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVC的优缺点"><span class="nav-number">2.3.</span> <span class="nav-text">MVC的优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVC-Model2"><span class="nav-number">2.4.</span> <span class="nav-text">MVC Model2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVP"><span class="nav-number">3.</span> <span class="nav-text">MVP</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#MVP-Passive-View-的依赖关系"><span class="nav-number">3.1.</span> <span class="nav-text">MVP(Passive View)的依赖关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVP（Passive-View）的调用关系"><span class="nav-number">3.2.</span> <span class="nav-text">MVP（Passive View）的调用关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVP（Passive-View）的优缺点"><span class="nav-number">3.3.</span> <span class="nav-text">MVP（Passive View）的优缺点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVP-Supervising-Controller"><span class="nav-number">3.4.</span> <span class="nav-text">MVP(Supervising Controller)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MVVM"><span class="nav-number">4.</span> <span class="nav-text">MVVM</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ViewModel"><span class="nav-number">4.1.</span> <span class="nav-text">ViewModel</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVVM的依赖"><span class="nav-number">4.2.</span> <span class="nav-text">MVVM的依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVVM的调用关系"><span class="nav-number">4.3.</span> <span class="nav-text">MVVM的调用关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#MVVM的优缺点"><span class="nav-number">4.4.</span> <span class="nav-text">MVVM的优缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结语"><span class="nav-number">5.</span> <span class="nav-text">结语</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Winner Liu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
